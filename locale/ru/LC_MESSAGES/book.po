# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-09-23 12:27+0300\n"
"PO-Revision-Date: 2016-09-23 13:01+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"
"Language: ru\n"
"X-Generator: Poedit 1.8.9\n"

#: ../book/administration.rst:30
msgid "Server administration"
msgstr "Администрирование серверной части"

#: ../book/administration.rst:32
msgid ""
"Typical server administration tasks include starting and stopping the server, "
"reloading configuration, taking snapshots, log rotation."
msgstr ""
"Типичные задачи администрирования серверной части включают в себя запуск и "
"остановку сервера, перезагрузку настроек, создание снимков, ротацию логов."

#: ../book/administration.rst:39
msgid "Using tarantool as a client"
msgstr "Использование tarantool в качестве клиента"

#: ../book/administration.rst:43
msgid ""
"If :program:`tarantool` is started without an :ref:`initialization file <index-"
"init_label>`, or if the initialization file contains :ref:`console.start() "
"<console-start>`, then :program:`tarantool` enters interactive mode. There will "
"be a prompt (\"``tarantool>``\") and it will be possible to enter requests. When "
"used this way, :program:`tarantool` can be a client for a remote server."
msgstr ""
"Если :program:`tarantool` запущен без :ref:`файла инициализации <index-"
"init_label>`, или же в файле инициализации указана функция :ref:`console.start() "
"<console-start>`, то :program:`tarantool` стартует в интерактивном режиме: он "
"выводит приглашение командной строки (\"``tarantool>``\"), и запросы можно "
"вводить прямо в консоли. В таком режиме :program:`tarantool` можно использовать "
"в качестве клиента для удаленного сервера."

#: ../book/administration.rst:49
msgid ""
"This section shows all legal syntax for the :program:`tarantool` program, with "
"short notes and examples. Other client programs may have similar options and "
"request syntaxes. Some of the information in this section is duplicated in the "
"chapter :ref:`Configuration reference <index-book_cfg>`."
msgstr ""
"В этом разделе описаны синтаксические правила для ввода запросов в консоли "
"Tarantool'а, с примечаниями и примерами. Другие клиентские программы могут иметь "
"схожие параметры и синтаксис запросов. Некоторые сведения из этого раздела "
"дублируются в главе :ref:`Справочник по конфигурированию <index-book_cfg>`."

#: ../book/administration.rst:56
msgid "Conventions used in this section"
msgstr "Условные обозначения, используемые в этом разделе"

#: ../book/administration.rst:58
msgid ""
"Tokens are character sequences which are treated as syntactic units within "
"requests. Square brackets [ and ] enclose optional syntax. Three dots in a "
"row ... mean the preceding tokens may be repeated. A vertical bar | means the "
"preceding and following tokens are mutually exclusive alternatives."
msgstr ""
"Токены — это последовательности символов, которые рассматриваются как "
"синтаксические единицы в рамках запроса. Квадратные скобки [ и ] используются "
"для обозначения необязательных токенов. Три точки в строке ... означают, что "
"предыдущие токены могут повторяться. Вертикальная черта | означает, что "
"предыдущие и последующие токены являются взаимоисключающими альтернативами."

#: ../book/administration.rst:65
msgid "Options when starting client from the command line"
msgstr "Параметры запуска клиента из командной строки"

#: ../book/administration.rst:67
msgid "General form:"
msgstr "Общий вид:"

#: ../book/administration.rst:72
msgid ""
"$ **tarantool**\n"
"OR\n"
"$ **tarantool** *options*\n"
"OR\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""
"$ tarantool\n"
"ИЛИ\n"
"$ tarantool опции\n"
"ИЛИ\n"
"$ tarantool файл-инициализации-на-lua [ аргументы ]"

#: ../book/administration.rst:78
msgid ""
"Here *lua-initialization-file* can be any script containing code for "
"initializing. Effect: The code in the file is executed during startup. Example: :"
"samp:`init.lua`. |br| Notes: If a script is used, there will be no prompt. The "
"script should contain configuration information including :samp:`box.cfg{..."
"listen=...}` or :samp:`box.listen(...)` so that a separate program can connect "
"to the server via one of the ports."
msgstr ""
"*файл-инициализации-на-lua* — это любой скрипт, содержащий логику инициализации. "
"Код из этого файла выполняется при запуске Tarantool'а.  Например: :samp:`init."
"lua`. |br| Примечания: При использовании скрипта, Tarantool не выводит "
"приглашение командной строки. Скрипт должен содержать конфигурационные "
"настройки, в т.ч. :samp:`box.cfg{...listen=...}` или :samp:`box.listen(...)`, "
"чтобы внешние программы могли установить соединение с Tarantool-сервером на "
"одном из указанных портов."

#: ../book/administration.rst:85
msgid ""
"*Option* is one of the following (in alphabetical order by the long form of the "
"option):"
msgstr ""
"*Опция* — это одно из следующих значений (указаны в алфавитном порядке, по "
"полному имени опции):"

#: ../book/administration.rst:90
msgid ""
"Client displays a help message including a list of options. Example: :samp:"
"`tarantool --help` The program stops after displaying the help."
msgstr ""
"Tarantool-клиент выводит краткую справку, включая список всех параметров. "
"Например: :samp:`tarantool --help`. Вывод останавливается после показа справки."

#: ../book/administration.rst:96
msgid ""
"Client displays version information. Example: :samp:`tarantool --version`. The "
"program stops after displaying the version."
msgstr ""
"Tarantool-клиент выводит свой номер версии. Например: :samp:`tarantool --"
"version`. Вывод останавливается после показа номера версии."

#: ../book/administration.rst:102
msgid "Tokens, requests, and special key combinations"
msgstr "Токены, запросы и специальные комбинации клавиш"

#: ../book/administration.rst:104
msgid ""
"Procedure identifiers are: Any sequence of letters, digits, or underscores which "
"is legal according to the rules for Lua identifiers. Procedure identifiers are "
"also called function names. |br| Note: function names are case sensitive so "
"``insert`` and ``Insert`` are not the same thing."
msgstr ""
"Идентификатором процедуры может быть любая последовательность букв, цифр и/или "
"подчеркиваний, которая отвечает правилам именования идентификаторов в Lua. "
"Термин \"идентификаторы процедур\" также применяют к именам функций. |br| "
"Примечание: в случае с именами функций регистр имеет значение, поэтому "
"``insert`` и ``Insert`` — это не одно и то же."

#: ../book/administration.rst:110
msgid ""
"String literals are: Any sequence of zero or more characters enclosed in single "
"quotes. Double quotes are legal but single quotes are preferred. Enclosing in "
"double square brackets is good for multi-line strings as described in `Lua "
"documentation <http://www.lua.org/pil/2.4.html>`_. |br| Examples: 'Hello, "
"world', 'A', [[A\\\\B!]]."
msgstr ""
"Строковым литералом может быть любая последовательность из нуля и более "
"символов, которая заключена в *одинарные кавычки*. *Двойные кавычки* также "
"допустимы, но предпочтительным вариантом являются одинарные кавычки. А *двойные "
"квадратные скобки* нужны для многострочных литералов (см. `документацию по языку "
"Lua <http://www.lua.org/pil/2.4.html>`_). |br| Например: 'Hello, world', 'A', [[A"
"\\\\B!]]."

#: ../book/administration.rst:116
msgid ""
"Numeric literals are: Any sequence of one or more digits, not enclosed in "
"quotes, optionally preceded by - (minus sign). Large or floating-point numeric "
"literals may include decimal points, exponential notation, or suffixes.|br| "
"Examples: 500, -500, 5e2, 500.1, 5LL, 5ULL."
msgstr ""
"Числовым литералом может быть любая последовательность символов, состоящая из "
"одной и более цифр с необязательным знаком + или - в начале. В состав больших "
"числовых литералов, а также числовых литералов с плавающей точкой может входить "
"десятичный разделитель (запятая или точка), символы для экспоненциального "
"представления и суффиксы. |br| Например: 500, -500, 5e2, 500.1, 5LL, 5ULL."

#: ../book/administration.rst:122
msgid ""
"Single-byte tokens are: , or ( or ) or arithmetic operators. |br| Examples: * , "
"( )."
msgstr ""
"Однобайтовым символом может быть запятая, открывающая или закрывающая круглая "
"скобка, а также арифметический оператор. |br| Например: * , ( )."

#: ../book/administration.rst:125
msgid ""
"Tokens must be separated from each other by one or more spaces, except that "
"spaces are not necessary around single-byte tokens or string literals."
msgstr ""
"Токены должны разделяться одним или бОльшим количеством пробелов. Исключением "
"являются однобайтовые токены и строковые литералы — вокруг них пробелы не нужны."

#: ../book/administration.rst:132
msgid "Requests"
msgstr "Запросы"

#: ../book/administration.rst:134
msgid ""
"Generally requests are entered following the prompt in interactive mode while :"
"program:`tarantool` is running. (A prompt will be the word 'tarantool' and a "
"greater-than sign, for example :samp:`tarantool>`). The end-of-request marker is "
"by default a newline (line feed)."
msgstr ""
"Запросы вводятся после приглашения командной строки, когда Tarantool работает в "
"интерактивном режиме. (Приглашение — это слово tarantool и знак \"больше\", вот "
"так: :samp:`tarantool>`). Маркером конца запроса по умолчанию является перевод "
"строки."

#: ../book/administration.rst:139
msgid ""
"For multi-line requests, it is possible to change the end-of-request marker. "
"Syntax: :samp:`console = require('console'); console.delimiter({string-"
"literal})`. The string-literal must be a value in single quotes. Effect: string "
"becomes end-of-request delimiter, so newline alone is not treated as end of "
"request. To go back to normal mode: :samp:`console.delimiter(''){string-literal}"
"`. Delimiters are usually not necessary because Tarantool can tell when a multi-"
"line request has not ended (for example, if it sees that a function declaration "
"does not have an :samp:`end` keyword). Example:"
msgstr ""
"Для ввода многострочных запросов можно задать другой маркер конца запроса. Для "
"этого введите команду следующего вида: :samp:`console = require('console'); "
"console.delimiter({новый-маркер})`. В качестве нового маркера укажите строковый "
"литерал в одинарных кавычках. После этого вам нужно будет вводить указанный "
"маркер в конце каждого запроса, потому что Tarantool перестанет интерпретировать "
"перевод строки как конец запроса. Чтобы вернуться к обычному режиму, введите: :"
"samp:`console.delimiter(''){string-literal}`. Как правило, задавать свой маркер "
"нет необходимости, поскольку Tarantool сам распознает, что запрос введен не "
"полностью (скажем, когда Tarantool не встречает слова :samp:`end` в объявлении "
"функции). Например:"

#: ../book/administration.rst:148
msgid ""
"console = require('console'); console.delimiter('!')\n"
"function f ()\n"
"  statement_1 = 'a'\n"
"  statement_2 = 'b'\n"
"end!\n"
"console.delimiter('')!"
msgstr ""
"console = require('console'); console.delimiter('!')\n"
"function f ()\n"
"  statement_1 = 'a'\n"
"  statement_2 = 'b'\n"
"end!\n"
"console.delimiter('')!"

#: ../book/administration.rst:157
msgid ""
"See :ref:`here <box_protocol-iproto_protocol>` a condensed Backus-Naur Form "
"[BNF] description of the suggested form of client requests."
msgstr ""
"См. также :ref:`описание формата клиентских запросов <box_protocol-"
"iproto_protocol>` в виде аннотированных BNF-диаграмм (Backus-Naur Form)."

#: ../book/administration.rst:160
msgid ""
"In *interactive* mode, one types requests and gets results. Typically the "
"requests are typed in by the user following prompts. Here is an example of an "
"interactive-mode Tarantool client session:"
msgstr ""
"Работая в  *интерактивном* режиме, Tarantool-сервер принимает введенные запросы "
"и выводит результаты. Запросы, как правило, вводит пользователь. Вот пример "
"интерактивной пользовательской сессии:"

#: ../book/administration.rst:164
msgid ""
"$ tarantool\n"
"[ tarantool will display an introductory message\n"
"  including version number here ]\n"
"tarantool> box.cfg{listen = 3301}\n"
"[ tarantool will display configuration information here ]\n"
"tarantool> s = box.schema.space.create('tester')\n"
"[ tarantool may display an in-progress message here ]\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{1,'My first tuple'}\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:select(1)\n"
"---\n"
"- - [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:drop()\n"
"---\n"
"...\n"
"tarantool> os.exit()\n"
"2014-04-30 10:28:00.886 [20436] main/101/spawner I> Exiting: master shutdown\n"
"$"
msgstr ""
"$ tarantool\n"
"[ здесь tarantool выводит приветствие и номер версии ]\n"
"tarantool> box.cfg{listen = 3301}\n"
"[ здесь tarantool выводит свои текущие настройки ]\n"
"tarantool> s = box.schema.space.create('tester')\n"
"[ здесь tarantool может вывести сообщение о том,\n"
"  что идет обработка запроса ]\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{1,'My first tuple'}\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:select(1)\n"
"---\n"
"- - [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:drop()\n"
"---\n"
"...\n"
"tarantool> os.exit()\n"
"2014-04-30 10:28:00.886 [20436] main/101/spawner I> Exiting: master shutdown\n"
"$"

#: ../book/administration.rst:193
msgid "Explanatory notes about what Tarantool displayed in the above example:"
msgstr "Пояснения к приведенному выше примеру:"

#: ../book/administration.rst:195
msgid ""
"Many requests return typed objects. In the case of :samp:`box.cfg{listen=3301}`, "
"this result is displayed on the screen. If the request had assigned the result "
"to a variable, for example :samp:`c = box.cfg{listen=3301}`, then the result "
"would not have been displayed on the screen."
msgstr ""
"На многие запросы Tarantool возвращает типизированные объекты. В ответ на "
"запрос :samp:`box.cfg{listen=3301}` Tarantool выведет результат на экран. Если в "
"запросе задано, что его результат должен быть записан в некоторую переменную, "
"например :samp:`c = box.cfg{listen=3301}`, то в таком случае вывода результата "
"на экран не происходит."

#: ../book/administration.rst:199
msgid ""
"A display of an object always begins with \"``---``\" and ends with \"``...``\"."
msgstr ""
"Вывод объекта в Tarantool'е всегда начинается со строки \"``---``\" и "
"заканчивается строкой \"``...``\"."

#: ../book/administration.rst:200
msgid ""
"The insert request returns an object of type = tuple, so the object display line "
"begins with a single dash ('``-``'). However, the select request returns an "
"object of type = table of tuples, so the object display line begins with two "
"dashes ('``- -``')."
msgstr ""
"По запросу на вставку данных возвращается объект типа кортеж (tuple), и в этом "
"случае перед выводом будет стоять одиночное тире ('``-``'). А по запросу на "
"выборку данных возвращается объект типа таблица кортежей (table of tuples), и в "
"этом случае перед выводом будут стоять два тире ('``- -``')."

#: ../book/administration.rst:209
msgid "Utility tarantoolctl"
msgstr "Утилита tarantoolctl"

#: ../book/administration.rst:213
msgid ""
"With :program:`tarantoolctl`, you can say: \"start an instance of the Tarantool "
"server which runs a single user-written Lua program, allocating disk resources "
"specifically for that program, via a standardized deployment method.\""
msgstr ""

#: ../book/administration.rst:217
msgid ""
"If Tarantool was installed with Debian or Red Hat installation packages, the "
"script is in :file:`/usr/bin/tarantoolctl` or :file:`/usr/local/bin/"
"tarantoolctl`. The script handles such things as: starting, stopping, rotating "
"logs, logging in to the application's console, and checking status."
msgstr ""

#: ../book/administration.rst:224
#, fuzzy
msgid ""
"Also, you can use :program:`tarantoolctl` :ref:`as a client <administration-"
"tarantoolctl_connect>` to connect to another instance of Tarantool server and "
"pass requests."
msgstr ""
"Данная команда означает \"использовать утилиту :ref:`tarantoolctl "
"<administration-tarantoolctl_connect>` для соединения с Tarantool-сервером, "
"который слушает на ``localhost:3301``.\""

#: ../book/administration.rst:230
msgid "Configuration for tarantoolctl"
msgstr "Конфигурирование tarantoolctl"

#: ../book/administration.rst:232
msgid ""
"The :program:`tarantoolctl` script will look for a configuration file in the "
"current directory (:file:`$PWD/.tarantoolctl`). If that fails, it looks in the "
"current user's home directory (:file:`$HOME/.config/tarantool/tarantool`). If "
"that fails, it looks in the SYSCONFDIR directory (usually :file:`/etc/sysconfig/"
"tarantool`, but it may be different on some platforms). Most of the settings are "
"similar to the settings used by :samp:`box.cfg{...}`; however, :program:"
"`tarantoolctl` adjusts some of them by adding an application name. A copy of :"
"file:`usr/local/etc/default/tarantool`, with defaults for all settings, would "
"look like this:"
msgstr ""
"Скрипт :program:`tarantoolctl` сначала проверяет наличие файла конфигурации в "
"текущей директории (:file:`$PWD/.tarantoolctl`). Если не находит, то проверяет "
"домашнюю директорию текущего пользователя (:file:`$HOME/.config/tarantool/"
"tarantool`). Если опять не находит, то проверяет директорию, указанную в "
"переменной SYSCONFDIR (обычно это :file:`/etc/sysconfig/tarantool`, но на разных "
"платформах этот путь может различаться). Большинство параметров :program:"
"`tarantoolctl` аналогичны тем, что задаются в запросе :samp:`box.cfg{...}`; "
"однако :program:`tarantoolctl` меняет значение некоторых параметров, дописывая к "
"ним имя приложения. Далее приводится копия файла :file:`usr/local/etc/default/"
"tarantool`, где для всех параметров указаны их значения по умолчанию:"

#: ../book/administration.rst:243
msgid ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\",\n"
"    wal_dir    = \"/var/lib/tarantool\",\n"
"    snap_dir   = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    logger     = \"/var/log/tarantool\",\n"
"    username   = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""
msgstr ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\",\n"
"    wal_dir    = \"/var/lib/tarantool\",\n"
"    snap_dir   = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    logger     = \"/var/log/tarantool\",\n"
"    username   = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""

#: ../book/administration.rst:255
msgid "The settings in the above script are:"
msgstr "Комментарии к параметрам в приведенном выше скрипте:"

#: ../book/administration.rst:259
msgid "``pid_file``"
msgstr "``pid_file``"

#: ../book/administration.rst:258
msgid ""
"The directory for the pid file and control-socket file. The script will add \":"
"samp:`/{instance-name}`\" to the directory name."
msgstr ""
"Директория, где хранятся pid-файл и socket-файл. Скрипт :program:`tarantoolctl` "
"добавляет \":samp:`/{instance-name}`\" к имени директории."

#: ../book/administration.rst:263
msgid "``wal_dir``"
msgstr "``wal_dir``"

#: ../book/administration.rst:262
msgid ""
"The directory for the write-ahead :file:`*.xlog` files. The script will add \":"
"samp:`/{instance-name}`\" to the directory-name."
msgstr ""
"Директория, где хранятся :file:`*.xlog`-файлы. Скрипт :program:`tarantoolctl` "
"добавляет \":samp:`/{instance-name}`\" к имени директории."

#: ../book/administration.rst:267
msgid "``snap_dir``"
msgstr "``snap_dir``"

#: ../book/administration.rst:266
msgid ""
"The directory for the snapshot :file:`*.snap` files. The script will add \":samp:"
"`/{instance-name}`\" to the directory-name."
msgstr ""
"Директория, где хранятся :file:`*.snap`-файлы. Скрипт :program:`tarantoolctl` "
"добавляет \":samp:`/{instance-name}`\" к имени директории."

#: ../book/administration.rst:271
msgid "``vinyl_dir``"
msgstr "``vinyl_dir``"

#: ../book/administration.rst:270
msgid ""
"The directory for the vinyl-storage-engine files. The script will add \":samp:`/"
"vinyl/{instance-name}`\" to the directory-name."
msgstr ""
"Директория, где хранятся файлы движка vinyl. Скрипт :program:`tarantoolctl` "
"добавляет \":samp:`/{instance-name}`\" к имени директории."

#: ../book/administration.rst:275
msgid "``logger``"
msgstr "``logger``"

#: ../book/administration.rst:274
msgid ""
"The place where the application log will go. The script will add \":samp:`/"
"{instance-name}.log`\" to the name."
msgstr ""
"Директория, где хранятся файлы журнала с сообщениями от Tarantool-приложений. "
"Скрипт :program:`tarantoolctl` добавляет \":samp:`/{instance-name}`\" к имени "
"директории."

#: ../book/administration.rst:279
msgid "``username``"
msgstr "``username``"

#: ../book/administration.rst:278
msgid ""
"The user that runs the Tarantool server. This is the operating-system user name "
"rather than the Tarantool-client user name."
msgstr ""
"Имя пользователя, из-под которого запущен Tarantool-сервер. Это имя пользователя "
"в операционной системе, а не в Tarantool-клиенте."

#: ../book/administration.rst:286
msgid "``instance_dir``"
msgstr "``instance_dir``"

#: ../book/administration.rst:282
msgid ""
"The directory where all applications for this host are stored. The user who "
"writes an application for :program:`tarantoolctl` must put the application's "
"source code in this directory, or a symbolic link. For examples in this section "
"the application name ``my_app`` will be used, and its source will have to be in :"
"samp:`{instance_dir}/my_app.lua`."
msgstr ""
"Имя директории, где хранятся исходные файлы всех Tarantool-приложений для "
"данного хоста. Пользователю, который пишет приложение для :program:"
"`tarantoolctl`, нужно положить исходный код своего приложения в эту директорию "
"или настроить симлинк. Далее для примеров в этом разделе мы используем Tarantool-"
"приложение с именем ``my_app``, и его исходный код должен лежать в файле :samp:"
"`{instance_dir}/my_app.lua`."

#: ../book/administration.rst:290
msgid "Commands for tarantoolctl"
msgstr "Команды для tarantoolctl"

#: ../book/administration.rst:292
msgid ""
"The command format is :samp:`tarantoolctl {operation} {application_name}`, where "
"operation is one of: start, stop, enter, logrotate, status, eval. Thus ..."
msgstr ""
"Команды для :program:`tarantoolctl` имеют вид :samp:`tarantoolctl {операция} "
"{имя_приложения}`. В качестве *операции* можно указать одно из следующих "
"значений: start, stop, enter, logrotate, status, eval."

#: ../book/administration.rst:297
msgid "Start application *<application>*"
msgstr "Запустить приложение с именем *<application>*"

#: ../book/administration.rst:301
msgid "Stop application"
msgstr "Остановить приложение"

#: ../book/administration.rst:305
msgid "Show application's admin console"
msgstr "Вывести консоль для управления приложением"

#: ../book/administration.rst:309
msgid "Rotate application's log files (make new, remove old)"
msgstr ""
"Произвести ротацию журналов указанного приложения (создать новые, удалить старые)"

#: ../book/administration.rst:313
msgid "Check application's status"
msgstr "Проверить статус приложения"

#: ../book/administration.rst:317
msgid "Execute code from *<scriptname>* on an instance of application"
msgstr ""
"Выполнить код из файла *<scriptname>* от имени запущенного экземпляра приложения "
"*<application>*"

#: ../book/administration.rst:321
msgid ""
"Connect to a Tarantool server running at the specified :ref:`URI <index-uri>`"
msgstr ""

#: ../book/administration.rst:325
msgid "Typical code snippets for tarantoolctl"
msgstr "Примеры кода для tarantoolctl"

#: ../book/administration.rst:327
msgid "A user can check whether ``my_app`` is running with these lines:"
msgstr "Проверить, запущено ли приложение ``my_app``:"

#: ../book/administration.rst:329
msgid ""
"if tarantoolctl status my_app; then\n"
"...\n"
"fi"
msgstr ""
"if tarantoolctl status my_app; then\n"
"...\n"
"fi"

#: ../book/administration.rst:335
msgid "A user can initiate, for boot time, an :file:`init.d` set of instructions:"
msgstr "Выполнить инструкции из файла :file:`init.d` во время запуска приложения:"

#: ../book/administration.rst:337
msgid ""
"for (each file mentioned in the instance_dir directory):\n"
"    tarantoolctl start `basename $ file .lua`"
msgstr ""
"for (каждый файл в директории instance_dir):\n"
"    tarantoolctl start `basename $ file .lua`"

#: ../book/administration.rst:342
msgid "A user can set up a further configuration file for log rotation, like this:"
msgstr "Указать файл конфигурации для ротации журнала, например:"

#: ../book/administration.rst:347
msgid ""
"/path/to/tarantool/\\*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /path/to/tarantoolctl logrotate `basename $ 1 .log`\n"
"    endscript\n"
"}"
msgstr ""
"/path/to/tarantool/\\*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /path/to/tarantoolctl logrotate `basename $ 1 .log`\n"
"    endscript\n"
"}"

#: ../book/administration.rst:362
msgid "A detailed example for tarantoolctl"
msgstr "Подробный пример для tarantoolctl"

#: ../book/administration.rst:364
#, fuzzy
msgid ""
"The example's objective is to make a temporary directory where :program:"
"`tarantoolctl` can start a long-running application and monitor it."
msgstr ""
"В этом примере мы создадим временную директорию, в которой :program:"
"`tarantoolctl` сможет запускать и мониторить некое долго работающее приложение."

#: ../book/administration.rst:367
msgid ""
"The assumptions are: the root password is known, the computer is only being used "
"for tests, the Tarantool server is ready to run but is not currently running, "
"tarantoolctl is installed along the user's path, and there currently is no "
"directory named :file:`tarantool_test`."
msgstr ""
"Итак, наши исходные условия: нам известен пароль root-пользователя; компьютер "
"используется только для тестирования; Tarantool-сервер настроен и готов к "
"запуску, но пока еще не запущен ;программа :program:`tarantoolctl` установлена в "
"пользовательском окружении; пока не существует директории с именем :file:"
"`tarantool_test`."

#: ../book/administration.rst:372
msgid "Create a directory named :file:`/tarantool_test`:"
msgstr "Создадим директорию с именем :file:`/tarantool_test`:"

#: ../book/administration.rst:374
msgid "$ sudo mkdir /tarantool_test"
msgstr "$ sudo mkdir /tarantool_test"

#: ../book/administration.rst:378
msgid ""
"Edit :file:`/usr/local/etc/default/tarantool`. It might be necessary to say :"
"samp:`sudo mkdir /usr/local/etc/default` first. Let the new file contents be:"
msgstr ""
"Отредактируем файл :file:`/usr/local/etc/default/tarantool`. Для этого нам "
"сначала может понадобиться выполнить команду :samp:`sudo mkdir /usr/local/etc/"
"default`. Указанный файл будет содержать следующие настройки:"

#: ../book/administration.rst:382
msgid ""
"default_cfg = {\n"
"    pid_file = \"/tarantool_test/my_app.pid\",\n"
"    wal_dir = \"/tarantool_test\",\n"
"    snap_dir = \"/tarantool_test\",\n"
"    vinyl_dir = \"/tarantool_test\",\n"
"    logger = \"/tarantool_test/log\",\n"
"    username = \"tarantool\",\n"
"}\n"
"instance_dir = \"/tarantool_test\""
msgstr ""
"default_cfg = {\n"
"    pid_file = \"/tarantool_test/my_app.pid\",\n"
"    wal_dir = \"/tarantool_test\",\n"
"    snap_dir = \"/tarantool_test\",\n"
"    vinyl_dir = \"/tarantool_test\",\n"
"    logger = \"/tarantool_test/log\",\n"
"    username = \"tarantool\",\n"
"}\n"
"instance_dir = \"/tarantool_test\""

#: ../book/administration.rst:394
msgid ""
"Make the ``my_app`` application file, that is, :file:`/tarantool_test/my_app."
"lua`. Let the file contents be:"
msgstr ""
"Создадим файл :file:`/tarantool_test/my_app.lua` для приложения ``my_app``:"

#: ../book/administration.rst:397
msgid ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"
msgstr ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"

#: ../book/administration.rst:413
msgid "Tell :program:`tarantoolctl` to start the application ..."
msgstr "С помощью :program:`tarantoolctl` запустим наше приложение..."

#: ../book/administration.rst:415
msgid ""
"$ cd /tarantool_test\n"
"$ sudo tarantoolctl start my_app"
msgstr ""
"$ cd /tarantool_test\n"
"$ sudo tarantoolctl start my_app"

#: ../book/administration.rst:420
msgid ""
"... expect to see messages indicating that the instance has started. Then ..."
msgstr ""
"... и получим сообщения о том, что экземпляр нашего приложения запущен. Затем "
"скажем:"

#: ../book/administration.rst:422
msgid "$ ls -l /tarantool_test/my_app"
msgstr "$ ls -l /tarantool_test/my_app"

#: ../book/administration.rst:426
msgid ""
"... expect to see the :file:`.snap` file and the :file:`.xlog` file. Then ..."
msgstr "... и увидим :file:`.snap`-файл и :file:`.xlog`-файл. Затем скажем:"

#: ../book/administration.rst:428
msgid "$ sudo less /tarantool_test/log/my_app.log"
msgstr "$ sudo less /tarantool_test/log/my_app.log"

#: ../book/administration.rst:432
msgid ""
"... expect to see the contents of ``my_app``'s log, including error messages, if "
"any. Then ..."
msgstr ""
"... и увидим содержимое файла журнала для приложения ``my_app``, в т.ч. "
"сообщения об ошибках, если они были. Затем скажем:"

#: ../book/administration.rst:435
msgid ""
"$ cd /tarantool_test\n"
"$ # assume that 'tarantool' invokes the tarantool server\n"
"$ sudo tarantool\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""
"$ cd /tarantool_test\n"
"$ # допустим, что 'tarantool' запускает Tarantool-сервер\n"
"$ sudo tarantool\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#: ../book/administration.rst:445
msgid "... expect to see several tuples that ``my_app`` has created."
msgstr "... и увидим те несколько кортежей, которые создало приложение ``my_app``."

#: ../book/administration.rst:447
msgid ""
"Stop. The only clean way to stop ``my_app`` is with :program:`tarantoolctl`, "
"thus:"
msgstr ""
"Всё. Теперь остановим приложение ``my_app``. Единственный корректный способ — "
"это использовать :program:`tarantoolctl`:"

#: ../book/administration.rst:449
msgid "$ sudo tarantoolctl stop my_app"
msgstr "$ sudo tarantoolctl stop my_app"

#: ../book/administration.rst:453
msgid ""
"Clean up. Restore the original contents of :file:`/usr/local/etc/default/"
"tarantool`, and ..."
msgstr ""
"Почистим систему после тестирования. Приведем содержимое файла :file:`/usr/local/"
"etc/default/tarantool` к исходному виду и удалим нашу тестовую директорию:"

#: ../book/administration.rst:456
msgid ""
"$ cd /\n"
"$ sudo rm -R tarantool_test"
msgstr ""
"$ cd /\n"
"$ sudo rm -R tarantool_test"

#: ../book/administration.rst:465
#, fuzzy
msgid "An example for tarantoolctl connect"
msgstr "Подробный пример для tarantoolctl"

#: ../book/administration.rst:467
msgid "$ tarantoolctl connect username:password@127.0.0.1:3306"
msgstr "$ tarantoolctl connect username:password@127.0.0.1:3306"

#: ../book/administration.rst:473
#, fuzzy
msgid ""
"There are alternatives to :program:`tarantoolctl connect` -- you can use the :"
"ref:`console module <console-module>` or the :ref:`net.box module <net_box-"
"module>` from a Tarantool server. Also, you can write your client programs with "
"any of the Connectors. However, most of the examples in this manual illustrate "
"usage with either :program:`tarantoolctl connect` or with :ref:`using the "
"Tarantool server as a client <administration-using_tarantool_as_a_client>`."
msgstr ""
"Вместо :program:`tarantoolctl connect` вы можете использовать модули :ref:"
"`console <console-module>` или :ref:`net.box <net_box-module>` из библиотеки "
"Tarantool'а. Еще одна альтернатива — это написать клиентскую программу под любой "
"из существующих Tarantool-коннекторов. Но для большинства примеров в текущей "
"документации мы используем :program:`tarantoolctl connect` или :ref:`Tarantool-"
"сервер в качестве клиента <administration-using_tarantool_as_a_client>`."

#: ../book/administration.rst:485
msgid "Administrative ports"
msgstr "Служебные порты"

#: ../book/administration.rst:487
msgid ""
"\"Admin port\", \"admin console\", and \"text protocol\" all refer to the same "
"thing: a connection which is set up with :ref:`console.listen(...) <console-"
"listen>` for entry of requests by administrators."
msgstr ""
"Термины \"порт для администрирования\", \"консоль для администрирования\", "
"\"текстовый протокол\" относятся к установке соединения с помощью :ref:`console."
"listen(...) <console-listen>` для ввода запросов от администраторов."

#: ../book/administration.rst:492
msgid ""
"\"Binary port\", \"binary protocol\", and \"primary port\" all refer to a "
"different thing: a connection which is set up with :ref:`box.cfg{listen=...} "
"<cfg_basic-listen>` for entry of requests by anyone."
msgstr ""
"Термины \"бинарный порт\", \"бинарный протокол\", \"первичный порт\" относятся к "
"другому виду соединения — тому, что устанавливается с помощью параметра :ref:"
"`box.cfg{listen=...} <cfg_basic-listen>` и предназначено для ввода запросов от "
"любых пользователей."

#: ../book/administration.rst:497
msgid ""
"Ordinary connections to the Tarantool server should go via a binary port. But "
"admin ports are useful for special cases involving security."
msgstr ""
"Для обычных соединений с Tarantool-сервером должен использоваться бинарный "
"протокол. А порты для администрирования нужны для особых случаев, когда повышены "
"требования к безопасности."

#: ../book/administration.rst:500
msgid "When you connect to an admin port:"
msgstr "При установке соединение через порт для администрирования:"

#: ../book/administration.rst:502
msgid "No password is necessary"
msgstr "Пароль не требуется"

#: ../book/administration.rst:503
msgid "The user is automatically 'admin', a user with many privileges."
msgstr "Пользователь автоматически получает привилегии администратора."

#: ../book/administration.rst:505
msgid ""
"Therefore you must set up admin ports very cautiously. If it is a TCP port, it "
"should only be opened for a specific IP. Ideally it should not be a TCP port at "
"all, it should be a Unix domain socket, so that access to the server machine is "
"required. Thus a typical setup for an admin port is:"
msgstr ""
"Поэтому порты для администрирования следует настраивать очень осторожно. Если "
"это TCP-порт, то он должен быть открыть только для определенного IP-адреса. В "
"идеале мы рекомендуем вовсе не использовать TCP-порты. Вместо них лучше "
"настроить доменный Unix-сокет, который требует настройки прав доступа к "
"серверной машине. Тогда типичная настройка порта для администрирования будет "
"выглядеть следующим образом:"

#: ../book/administration.rst:511
msgid "console.listen('/var/lib/tarantool/socket_name.sock')"
msgstr "console.listen('/var/lib/tarantool/socket_name.sock')"

#: ../book/administration.rst:515
msgid "and a typical connection :ref:`URI <index-uri>` is:"
msgstr "а типичный :ref:`URI <index-uri>` для соединения будет таким:"

#: ../book/administration.rst:517
msgid "admin:any_string@/var/lib/tarantool/socket_name.sock"
msgstr "admin:any_string@/var/lib/tarantool/socket_name.sock"

#: ../book/administration.rst:521
msgid ""
"if the listener has the privilege to write on :file:`/var/lib/tarantool` and the "
"connector has the privilege to read on :file:`/var/lib/tarantool`. Alternatively "
"both setup and connection can be done with :ref:`tarantoolctl <administration-"
"tarantoolctl>`."
msgstr ""
"Это в том случае, если у сервера (listener'а) есть привилегии на запись в файл :"
"file:`/var/lib/tarantool`, а на стороне клиента (connector'а) есть привилегии на "
"чтение из того же файла. Аналогично можно установить соединение и задать "
"настройки с помощью :ref:`tarantoolctl <administration-tarantoolctl>`."

#: ../book/administration.rst:526
msgid ""
"If no administrator password exists which could be given out to users, and admin "
"ports are restricted or are sockets, then requests which require 'admin' "
"privileges can only occur locally, and are subject to Unix security and "
"monitoring."
msgstr ""
"Если не задан пароль администратора, который можно сообщить пользователям, а "
"порты для администрирования настроены с ограничением доступа по IP либо через "
"сокеты, то запросы, требующие привилегий администратора, можно делать только "
"локально, где вопросы безопасности и мониторинга регулируются с помощью средств "
"Unix-системы."

#: ../book/administration.rst:531
msgid ""
"For additional security, some requests are illegal. For example, :ref:`\"conn:"
"eval\" <net_box-eval>`  will result in the error message \"- error: console does "
"not support this request type\" because ``conn:eval`` requires the binary "
"protocol."
msgstr ""
"В целях дополнительной безопасности некоторые запросы на портах для "
"администрирования запрещены. Например, :ref:`conn:eval <net_box-eval>` вернет "
"сообщение об ошибке ``- error: console does not support this request type``, "
"поскольку запрос ``conn:eval`` должен осуществляться в рамках бинарного "
"протокола."

#: ../book/administration.rst:536
msgid ""
"If security via admin ports is not necessary, it is still possible to be an "
"admin user by :ref:`using the tarantool server as a client <administration-"
"using_tarantool_as_a_client>`, or by connecting to a binary port with a valid "
"password."
msgstr ""
"Если вопросы безопасности на портах для администрирования неактуальны, то стать "
"пользователем с правами администратора можно, :ref:`используя Tarantool-сервер в "
"качестве клиента <administration-using_tarantool_as_a_client>` или указав "
"администраторский пароль при установке соединения по бинарному протоколу."

#: ../book/administration.rst:541
msgid ""
"To find out whether a TCP port is an admin port, use :program:`telnet`. For "
"example:"
msgstr ""
"Выяснить, является ли некий TCP-порт портом для администрирования, можно с "
"помощью :program:`telnet`. Например:"

#: ../book/administration.rst:544
msgid ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.7.1-70-gbc479ad (Lua console)\n"
"type 'help' for interactive help"
msgstr ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.7.1-70-gbc479ad (Lua console)\n"
"type 'help' for interactive help"

#: ../book/administration.rst:553
msgid ""
"In this example the response does not include the word \"binary\" and does "
"include the words \"Lua console\". Therefore it is clear that this is a "
"successful connection to an admin port, and admin requests can now be entered on "
"this terminal."
msgstr ""
"В этом примере в ответе от сервера нет слова \"binary\" и есть слова \"Lua "
"console\". Это значит, что мы установили соединение на порту для "
"администрирования и можем вводить администраторские запросы на этом терминале."

#: ../book/administration.rst:560
msgid "Administrative requests"
msgstr "Служебные запросы"

#: ../book/admin.rst:1
msgid ""
"To learn which functions are considered to be administrative, type ``help()``. A "
"reference description also follows below:"
msgstr ""

#: ../book/admin.rst:8
msgid ""
"Take a snapshot of all data and store it in :ref:`snap_dir <cfg_basic-snap_dir>`:"
"samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool first enters the "
"delayed garbage collection mode for all data. In this mode, tuples which were "
"allocated before the snapshot has started are not freed until the snapshot has "
"finished. To preserve consistency of the primary key, used to iterate over "
"tuples, a copy-on-write technique is employed. If the master process changes "
"part of a primary key, the corresponding process page is split, and the snapshot "
"process obtains an old copy of the page. In effect, the snapshot process uses "
"multi-version concurrency control in order to avoid copying changes which are "
"superseded while it is running."
msgstr ""

#: ../book/admin.rst:19
#, python-format
msgid ""
"Since a snapshot is written sequentially, one can expect a very high write "
"performance (averaging to 80MB/second on modern disks), which means an average "
"database instance gets saved in a matter of minutes. Note: as long as there are "
"any changes to the parent index memory through concurrent updates, there are "
"going to be page splits, and therefore one needs to have some extra free memory "
"to run this command. 10% of :ref:`slab_alloc_arena <cfg_storage-"
"slab_alloc_arena>` is, on average, sufficient. This statement waits until a "
"snapshot is taken and returns operation result."
msgstr ""

#: ../book/admin.rst:28
msgid ""
"Change Notice: prior to Tarantool version 1.6.6, the snapshot process caused a "
"fork, which could cause occasional latency spikes. Starting with Tarantool "
"version 1.6.6, the snapshot process creates a consistent read view and writes "
"this view to the snapshot file from a separate thread."
msgstr ""

#: ../book/admin.rst:33
msgid ""
"Although box.snapshot() does not cause a fork, there is a separate fiber which "
"may produce snapshots at regular intervals -- see the discussion of the :ref:"
"`snapshot daemon <book_cfg_snapshot_daemon>`."
msgstr ""

#: ../book/admin.rst:37 ../book/box/authentication.rst:152
#: ../book/box/authentication.rst:275 ../book/box/box_index.rst:70
#: ../book/box/box_index.rst:443 ../book/box/box_index.rst:579
#: ../book/box/box_index.rst:608 ../book/box/box_index.rst:637
#: ../book/box/box_index.rst:666 ../book/box/box_index.rst:694
#: ../book/box/box_index.rst:765 ../book/box/box_index.rst:787
#: ../book/box/box_index.rst:808 ../book/box/box_introspection.rst:14
#: ../book/box/box_introspection.rst:57 ../book/box/box_introspection.rst:114
#: ../book/box/box_schema.rst:159 ../book/box/box_schema.rst:189
#: ../book/box/box_schema.rst:218 ../book/box/box_schema.rst:234
#: ../book/box/box_schema.rst:252 ../book/box/box_schema.rst:269
#: ../book/box/box_schema.rst:288 ../book/box/box_schema.rst:303
#: ../book/box/box_schema.rst:316 ../book/box/box_schema.rst:340
#: ../book/box/box_schema.rst:368 ../book/box/box_schema.rst:383
#: ../book/box/box_schema.rst:406 ../book/box/box_schema.rst:425
#: ../book/box/box_schema.rst:438 ../book/box/box_space.rst:284
#: ../book/box/box_space.rst:314 ../book/box/box_space.rst:392
#: ../book/box/box_space.rst:413 ../book/box/box_space.rst:432
#: ../book/box/box_space.rst:467 ../book/box/box_space.rst:535
#: ../book/box/box_space.rst:638 ../book/box/box_space.rst:661
#: ../book/box/box_space.rst:689 ../book/box/box_space.rst:727
#: ../book/box/box_space.rst:746 ../book/box/box_space.rst:769
#: ../book/box/box_space.rst:786 ../book/box/box_space.rst:818
#: ../book/box/box_space.rst:851 ../book/box/box_space.rst:875
#: ../book/box/box_space.rst:911 ../book/box/box_space.rst:953
#: ../book/box/box_space.rst:997 ../book/box/box_tuple.rst:59
#: ../book/box/triggers.rst:58 ../book/box/triggers.rst:85
#: ../book/box/triggers.rst:157 ../book/box/triggers.rst:188
#: ../book/box/triggers.rst:206
msgid "**Example:**"
msgstr ""

#: ../book/admin.rst:39
msgid ""
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""

#: ../book/admin.rst:54
msgid ""
"Taking a snapshot does not cause the server to start a new write-ahead log. Once "
"a snapshot is taken, old WALs can be deleted as long as all replicas are up to "
"date. But the WAL which was current at the time ``box.snapshot()`` started must "
"be kept for recovery, since it still contains log records written after the "
"start of ``box.snapshot()``."
msgstr ""

#: ../book/admin.rst:60
msgid ""
"An alternative way to save a snapshot is to send the server SIGUSR1 UNIX signal. "
"While this approach could be handy, it is not recommended for use in automation: "
"a signal provides no way to find out whether the snapshot was taken successfully "
"or not."
msgstr ""

#: ../book/admin.rst:67
msgid ""
"Fork and dump a core. Since Tarantool stores all tuples in memory, it can take "
"some time. Mainly useful for debugging."
msgstr ""

#: ../book/administration.rst:566
msgid "Server introspection"
msgstr "Просмотр состояния сервера"

#: ../book/box/box_introspection.rst:5
msgid "Submodule `box.cfg`"
msgstr ""

#: ../book/box/box_introspection.rst:9
msgid ""
"The ``box.cfg`` submodule is for administrators to specify all the server "
"configuration parameters (see \"Configuration reference\" for :ref:`a complete "
"description of all configuration parameters <box_cfg_params>`). Use ``box.cfg`` "
"without braces to get read-only access to those parameters."
msgstr ""

#: ../book/box/box_introspection.rst:16
msgid ""
"tarantool> box.cfg\n"
"---\n"
"- snapshot_count: 6\n"
"  too_long_threshold: 0.5\n"
"  slab_alloc_factor: 1.1\n"
"  slab_alloc_maximal: 1048576\n"
"  background: false\n"
"  <...>\n"
"..."
msgstr ""

#: ../book/box/box_introspection.rst:30
msgid "Submodule `box.info`"
msgstr ""

#: ../book/box/box_introspection.rst:34
msgid ""
"The ``box.info`` submodule provides access to information about server "
"variables. Some important ones:"
msgstr ""

#: ../book/box/box_introspection.rst:37
msgid ""
"**server.uuid** holds the unique identifier of the server. This value is also in "
"the :ref:`box.space._cluster <box_space-cluster>` system space."
msgstr ""

#: ../book/box/box_introspection.rst:39
msgid ""
"**pid** is the process ID of the server. This value is also shown by the :ref:"
"`tarantool <tarantool-build>` module."
msgstr ""

#: ../book/box/box_introspection.rst:41
msgid ""
"**version** is the Tarantool version. This value is also shown by :ref:"
"`tarantool --version <index-tarantool_version>`."
msgstr ""

#: ../book/box/box_introspection.rst:43
msgid "**uptime** is the number of seconds since the server started."
msgstr ""

#: ../book/box/box_introspection.rst:49
msgid ""
"Since ``box.info`` contents are dynamic, it's not possible to iterate over keys "
"with the Lua ``pairs()`` function. For this purpose, ``box.info()`` builds and "
"returns a Lua table with all keys and values provided in the submodule."
msgstr ""

#: ../book/box/box_introspection.rst:54
msgid "keys and values in the submodule."
msgstr ""

#: ../book/box/box_index.rst:68 ../book/box/box_introspection.rst:55
#: ../book/box/box_schema.rst:77 ../book/box/box_space.rst:744
msgid "table"
msgstr ""

#: ../book/box/box_introspection.rst:59
msgid ""
"tarantool> box.info()\n"
"---\n"
"- server:\n"
"    lsn: 158\n"
"    ro: false\n"
"    uuid: a2684219-b2b1-4334-88ab-50b0722283fd\n"
"    id: 1\n"
"  version: 1.7.0-1216-g73f7154\n"
"  pid: 12932\n"
"  status: running\n"
"  vclock:\n"
"  - 158\n"
"  replication:\n"
"    status: off\n"
"  uptime: 908\n"
"...\n"
"tarantool> box.info.pid\n"
"---\n"
"- 12932\n"
"...\n"
"tarantool> box.info.status\n"
"---\n"
"- running\n"
"...\n"
"tarantool> box.info.uptime\n"
"---\n"
"- 1065\n"
"...\n"
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-66-g9093daa\n"
"..."
msgstr ""

#: ../book/box/box_introspection.rst:96
msgid "Submodule `box.slab`"
msgstr ""

#: ../book/box/box_introspection.rst:100
msgid ""
"The ``box.slab`` submodule provides access to slab allocator statistics. The "
"slab allocator is the main allocator used to store tuples. This can be used to "
"monitor the total memory use and memory fragmentation."
msgstr ""

#: ../book/box/box_introspection.rst:104
#, python-format
msgid ""
"The display of slabs is broken down by the slab size -- 64-byte, 136-byte, and "
"so on. The example omits the slabs which are empty. The example display is "
"saying that: there are 16 items stored in the 64-byte slab (and 16*64=102 so "
"bytes_used = 1024); there is 1 item stored in the 136-byte slab (and 136*1=136 "
"so bytes_used = 136); the arena_used value is the total of all the bytes_used "
"values (1024+136 = 1160); the arena_size value is the arena_used value plus the "
"total of all the bytes_free values (1160+4193200+4194088 = 8388448). The "
"arena_size and arena_used values are the amount of the % of :ref:"
"`slab_alloc_arena <cfg_storage-slab_alloc_arena>` that is already distributed to "
"the slab allocator."
msgstr ""

#: ../book/box/box_introspection.rst:116
msgid ""
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 4194304\n"
"...\n"
"tarantool> box.slab.info().arena_size\n"
"---\n"
"- 104857600\n"
"...\n"
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16248\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15736\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"    <...>\n"
"...\n"
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 15736\n"
"  mem_used: 560\n"
"  item_count: 14\n"
"  item_size: 40\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""

#: ../book/box/box_introspection.rst:156
msgid "Submodule `box.stat`"
msgstr ""

#: ../book/box/box_introspection.rst:158
msgid ""
"The ``box.stat`` submodule provides access to request and network statistics. "
"Show the average number of requests per second, and the total number of requests "
"since startup, broken down by request type and network events statistics."
msgstr ""

#: ../book/box/box_introspection.rst:162
msgid ""
"tarantool> type(box.stat), type(box.stat.net) -- virtual tables\n"
"---\n"
"- table\n"
"- table\n"
"...\n"
"tarantool> box.stat, box.stat.net\n"
"---\n"
"- net: []\n"
"- []\n"
"...\n"
"tarantool> box.stat()\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- a selected item of the table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net()\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVENTS:\n"
"    total: 2\n"
"    rps: 0\n"
"  LOCKS:\n"
"    total: 6\n"
"    rps: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"..."
msgstr ""

#: ../book/administration.rst:572
msgid "Replication"
msgstr "Репликация"

#: ../book/replication.rst:3
msgid ""
"Replication allows multiple Tarantool servers to work on copies of the same "
"databases. The databases are kept in synch because each server can communicate "
"its changes to all the other servers. Servers which share the same databases are "
"a \"cluster\". Each server in a cluster also has a numeric identifier which is "
"unique within the cluster, known as the \"server id\"."
msgstr ""
"Механизм репликации позволяет сразу многим Tarantool-серверам работать с копиями "
"одних и тех же баз данных. При этом все базы остаются в синхронизированном "
"состоянии благодаря тому, что каждый сервер может сообщать другим серверам о "
"совершенных им изменениях. Сервера, которые работают над одними и теми же "
"базами, представляют собой \"кластер\". У каждого сервера в кластере есть "
"числовой идентификатор (server id), уникальный в рамках кластера."

#: ../book/replication.rst:9
msgid ""
"To set up replication, it's necessary to set up the master servers which make "
"the original data-change requests, set up the replica servers which copy data-"
"change requests from masters, and establish procedures for recovery from a "
"degraded state."
msgstr ""
"Чтобы настроить репликацию, необходимо настроить главные сервера (master), "
"которые первыми обрабатывают запросы на изменение данных, затем настроить "
"сервера-реплики (replica), которые копируют к себе запросы на изменение данных с "
"главных серверов, и прописать процедуры для восстановления после сбоя."

#: ../book/replication.rst:16
msgid "Replication architecture"
msgstr "Архитектура механизма репликации"

#: ../book/replication.rst:18
msgid ""
"A replica gets all updates from the master by continuously fetching and applying "
"its write-ahead log (WAL). Each record in the WAL represents a single Tarantool "
"data-change request such as INSERT or UPDATE or DELETE, and is assigned a "
"monotonically growing log sequence number (LSN). In essence, Tarantool "
"replication is row-based: each data change command is fully deterministic and "
"operates on a single tuple."
msgstr ""
"Чтобы знать о всех изменениях на стороне главного сервера, каждая реплика "
"непрерывно опрашивает главный сервер на предмет обновлений в его WAL-файле "
"(write ahead log) и применяет эти обновления на своей стороне. Каждая запись в "
"WAL-файле представляет собой один запрос на изменение данных (например, INSERT, "
"UPDATE или DELETE) и присвоенный данной записи номер (LSN = log sequence "
"number). Номера присваиваются в порядке возрастания. По сути, репликация в "
"Tarantool'е является построчной: все команды на изменение данных полностью "
"детерминированы, и каждая такая команда относится только к одному кортежу."

#: ../book/replication.rst:25
msgid ""
"A stored program invocation is not written to the write-ahead log. Instead, log "
"events for actual data-change requests, performed by the Lua code, are written "
"to the log. This ensures that possible non-determinism of Lua does not cause "
"replication to go out of sync."
msgstr ""
"Вызовы хранимых Lua-процедур фиксируются не в WAL-файле, а в журнале событий "
"(event log). Таким образом гарантируется, что не детерминированное поведение "
"логики на Lua не приведет к рассинхронизации реплицированных данных."

#: ../book/replication.rst:32
#, fuzzy
msgid "Setting up a master"
msgstr "Настройка главного сервера"

#: ../book/replication.rst:34
msgid ""
"To prepare the master for connections from the replica, it's only necessary to "
"include \":ref:`listen <cfg_basic-listen>`\" in the initial ``box.cfg`` request, "
"for example ``box.cfg{listen=3301}``. A master with enabled \"listen\" URI can "
"accept connections from as many replicas as necessary on that URI. Each replica "
"has its own :ref:`replication state <index-monitoring_replica_actions>`."
msgstr ""
"Чтобы настроить возможность установки соединения для реплик, на стороне главного "
"сервера требуется лишь указать значение для параметра \":ref:`listen <cfg_basic-"
"listen>`\" в init-запросе ``box.cfg``. Например, ``box.cfg{listen=3301}``. Когда "
"URI для прослушивания задан, главный сервер готов принимать запросы на "
"соединение от любого количества реплик. Каждая реплика при этом находится в "
"некотором :ref:`статусе репликации <index-monitoring_replica_actions>`."

#: ../book/replication.rst:42
msgid "Setting up a replica"
msgstr "Настройка сервера-реплики"

#: ../book/replication.rst:44
msgid ""
"A server requires a valid snapshot (.snap) file. A snapshot file is created for "
"a server the first time that ``box.cfg`` occurs for it. If this first ``box."
"cfg`` request occurs without a \"replication source\" clause, then the server is "
"a master and starts its own new cluster with a new unique UUID. If this first "
"``box.cfg`` request occurs with a \"replication source\" clause, then the server "
"is a replica and its snapshot file, along with the cluster information, is "
"constructed from the write-ahead logs of the master. Therefore, to start "
"replication, specify :ref:`replication_source <cfg_replication-"
"replication_source>` in a ``box.cfg`` request. When a replica contacts a master "
"for the first time, it becomes part of a cluster. On subsequent occasions, it "
"should always contact a master in the same cluster."
msgstr ""
"Каждому Tarantool-серверу необходим корректный файл со статическим снимком "
"данных (.snap-файл). Файл-снимок создается на сервере при первом запросе ``box."
"cfg``. Если при первом таком запросе на сервере не определен источник репликации "
"(replication source), то сервер стартует в режиме главного сервера и создает для "
"себя новый кластер с новым уникальными UUID. Если же источник репликации при "
"первом ``box.cfg``-запросе определен, то сервер стартует в режиме реплики, а "
"файл-снимок и информация о кластере берутся из WAL-файлов на главном сервере. "
"Поэтому при настройке репликации нужно указать параметр :ref:`replication_source "
"<cfg_replication-replication_source>` в запросе ``box.cfg``. При первом "
"соединении с главным сервером сервер-реплика включается в состав кластера. В "
"дальнейшем такая реплика общается только с главным сервером из данного кластера."

#: ../book/replication.rst:56
msgid ""
"Once connected to the master, the replica requests all changes that happened "
"after the latest local LSN. It is therefore necessary to keep WAL files on the "
"master host as long as there are replicas that haven't applied them yet. A "
"replica can be \"re-seeded\" by deleting all its files (the snapshot .snap file "
"and the WAL .xlog files), then starting replication again - the replica will "
"then catch up with the master by retrieving all the master's tuples. Again, this "
"procedure works only if the master's WAL files are present."
msgstr ""
"После установки соединения с главным сервером реплика запрашивает у него все "
"изменения, чьи LSN-номера в WAL-файле больше номера последнего локального "
"изменения на реплике. Поэтому WAL-файлы на главном сервере нужно хранить до тех "
"пор, пока все реплики не применят изменения из этих WAL-файлов на своей стороне. "
"Состояние реплики можно \"обнулить\", удалив все файлы репликации (.snap-файл со "
"снимком и .xlog-файлы с записями WAL) и запустив сервер снова. Реплика при этом "
"возьмет все кортежи с главного сервера и придет в синхронизированное состояние. "
"Обратите внимание, что такая процедура \"обнуления\" сработает, только если на "
"главном сервере будут доступны все нужные WAL-файлы."

#: ../book/replication.rst:66
msgid ""
"Replication parameters are \"dynamic\", which allows the replica to become a "
"master and vice versa with the help of the :ref:`box.cfg <box_introspection-"
"box_cfg>` statement."
msgstr ""
"Параметры репликации можно менять на лету, что позволяет назначать реплику на "
"роль главного сервера и наоборот. Для этого используется запрос :ref:`box.cfg "
"<box_introspection-box_cfg>`."

#: ../book/replication.rst:72
msgid ""
"The replica does not inherit the master's configuration parameters, such as the "
"ones that cause the :ref:`snapshot daemon <book_cfg_snapshot_daemon>` to run on "
"the master. To get the same behavior, one would have to set the relevant "
"parameters explicitly so that they are the same on both master and replica."
msgstr ""
"Реплика не берет настройки конфигурации с главного сервера, например настройки "
"запуска :ref:`фоновой программы для работы со снимками "
"<book_cfg_snapshot_daemon>` на главном сервере. Чтобы получить те же настройки "
"на реплике, нужно задать их явным образом."

#: ../book/replication.rst:80
msgid ""
"Replication requires privileges. Privileges for accessing spaces could be "
"granted directly to the user who will start the replica. However, it is more "
"usual to grant privileges for accessing spaces to a :ref:`role <authentication-"
"rep_role>`, and then grant the role to the user who will start the replica."
msgstr ""
"Репликация требует настройки привилегий. Привилегии для доступа к пространствам "
"можно задать напрямую для пользователя, под чьим именем запущен сервер-реплика. "
"Но обычно привилегии на доступ к пространствам задаются с помощью :ref:`роли "
"<authentication-rep_role>`, которая затем присваивается пользователю, под чьим "
"именем запущен сервер-реплика."

#: ../book/replication.rst:88
msgid "Recovering from a degraded state"
msgstr "Восстановление после сбоя"

#: ../book/replication.rst:90
msgid ""
"\"Degraded state\" is a situation when the master becomes unavailable - due to "
"hardware or network failure, or due to a programming bug. There is no automatic "
"way for a replica to detect that the master is gone forever, since sources of "
"failure and replication environments vary significantly. So the detection of "
"degraded state requires a human inspection."
msgstr ""
"\"Сбой\" — это ситуация, когда главный сервер становится недоступен вследствие "
"проблем с оборудованием, сетевых неполадок или программной ошибки. У реплики нет "
"способа автоматически обнаружить, что связь с главным сервером утеряна насовсем, "
"поскольку причины сбоя и окружение, в котором развернута репликация, могут быть "
"очень разными. Поэтому обнаруживать сбой должен человек."

#: ../book/replication.rst:96
msgid ""
"However, once a master failure is detected, the recovery is simple: declare that "
"the replica is now the new master, by saying :codenormal:`box.cfg{... listen=`:"
"codeitalic:`URI <index-uri>`:codenormal:`}`. Then, if there are updates on the "
"old master that were not propagated before the old master went down, they would "
"have to be re-applied manually."
msgstr ""
"Но когда сбой уже обнаружен, процедура восстановления проста. Сначала нужно "
"назначить одну из реплик на роль нового главного сервера, задав параметр :"
"codenormal:`box.cfg{... listen=`:codeitalic:`URI <index-uri>`:codenormal:`}`. "
"Затем, если на прежнем главном сервере остались изменения, которые не успели "
"примениться на выбранной реплике перед сбоем, нужно применить эти изменения "
"вручную."

#: ../book/replication.rst:104
#, fuzzy
msgid "Quick startup of a new simple two-server cluster"
msgstr "Инструкции по быстрому запуску простого кластера из двух серверов с нуля"

#: ../book/replication.rst:106
msgid "Step 1. Start the first server thus:"
msgstr "Шаг 1. Запустите первый сервер со следующими настройками:"

#: ../book/replication.rst:985
msgid ""
"box.cfg{listen = *uri#1*}\n"
"-- replace with more restrictive request\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')\n"
"box.snapshot()"
msgstr ""
"box.cfg{listen = *uri#1*}\n"
"-- в этом запросе можно задать больше ограничений\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')\n"
"box.snapshot()"

#: ../book/replication.rst:116
msgid "... Now a new cluster exists."
msgstr "... Итак, создался новый кластер."

#: ../book/replication.rst:118
msgid ""
"Step 2. Check where the second server's files will go by looking at its "
"directories (:ref:`snap_dir <cfg_basic-snap_dir>` for snapshot files, :ref:"
"`wal_dir <cfg_basic-wal_dir>` for .xlog files). They must be empty - when the "
"second server joins for the first time, it has to be working with a clean state "
"so that the initial copy of the first server's databases can happen without "
"conflicts."
msgstr ""
"Шаг 2. На втором сервере проверьте пути, по которым будут храниться файлы "
"репликации. Эти пути задаются в параметрах :ref:`snap_dir <cfg_basic-snap_dir>` "
"(для .snap-файлов) и :ref:`wal_dir <cfg_basic-wal_dir>` (для .xlog-файлов). В "
"указанных директориях должно быть пусто, чтобы не случилось конфликта с теми "
"начальными данными, что придут с первого сервера, когда второй сервер "
"присоединится к кластеру."

#: ../book/replication.rst:124
msgid "Step 3. Start the second server thus:"
msgstr "Step 3. Запустите второй сервер со следующими настройками:"

#: ../book/replication.rst:1003
msgid ""
"box.cfg{\n"
"  listen = *uri#2*,\n"
"  replication_source = *uri#1*\n"
"}"
msgstr ""
"box.cfg{\n"
"  listen = *uri#2*,\n"
"  replication_source = *uri#1*\n"
"}"

#: ../book/replication.rst:134
msgid ""
"... where ``uri#1`` = the :ref:`URI <index-uri>` that the first server is "
"listening on."
msgstr ""
"... где ``uri#1`` = :ref:`URI <index-uri>`, на котором включено прослушивание у "
"первого сервера."

#: ../book/replication.rst:136
msgid "That's all."
msgstr "Вот и всё."

#: ../book/replication.rst:138
msgid ""
"In this configuration, the first server is the \"master\" and the second server "
"is the \"replica\". Henceforth every change that happens on the master will be "
"visible on the replica. A simple two-server cluster with the master on one "
"computer and the replica on a different computer is very common and provides two "
"benefits: FAILOVER (because if the master goes down then the replica can take "
"over), or LOAD BALANCING (because clients can connect to either the master or "
"the replica for select requests). Sometimes the replica may be configured with "
"the additional parameter :ref:`read_only = true <cfg_basic-read_only>`."
msgstr ""
"В описанной выше конфигурации первый сервер выполняет роль \"главного\", а "
"второй служит \"репликой\". Далее все изменения, происходящие на стороне "
"главного сервера, будут доступны с реплики. Простой кластер из двух серверов, "
"где главный сервер запущен на одном компьютере, а сервер-реплика — на другом, "
"встречается очень часто и обладает двумя важными преимуществами: FAILOVER (т.е. "
"отказоустойчивость, поскольку в случае отключения главного сервера его место "
"может занять сервер-реплика) и LOAD BALANCING (т.е. балансировка нагрузки, "
"поскольку клиенты могут обращаться с SELECT-запросами как к главному серверу, "
"так и к реплике). При необходимости в настройках реплики можно задать параметр :"
"ref:`read_only = true <cfg_basic-read_only>`."

#: ../book/replication.rst:151
msgid "Monitoring a replica's actions"
msgstr "Мониторинг действий реплики"

#: ../book/replication.rst:153
msgid ""
"In :ref:`box.info <box_introspection-box_info>` there is a ``box.info."
"replication.status`` field: \"off\", \"stopped\", \"connecting\", \"auth\", "
"\"follow\", or \"disconnected\". |br| If a replica's status is \"follow\", then "
"there will be two more fields: |br| ``box.info.replication.idle`` = the number "
"of seconds the replica has been idle, |br| ``box.info.replication.lag`` = the "
"number of seconds the replica is behind the master."
msgstr ""
"В пакете :ref:`box.info <box_introspection-box_info>` есть поле :code:`box.info."
"replication.status`, которое отражает статус репликации для данной реплики: \"off"
"\", \"stopped\", \"connecting\", \"auth\", \"follow\" или \"disconnected\". |br| "
"Если реплика имеет статус \"follow\", то можно получить уточняющую информацию из "
"еще двух полей: |br| :code:`box.info.replication.idle` = время (в секундах), "
"которое реплика провела в состоянии бездействия, |br| :code:`box.info."
"replication.lag` = время (в секундах), на которое реплика отстает от главного "
"сервера."

#: ../book/replication.rst:159
msgid ""
"In the :ref:`log <log>` there is a record of replication activity. If a primary "
"server is started with:"
msgstr ""
"В :ref:`журнале <log>` ведется запись о действиях, связанных с репликацией. Если "
"главный сервер запущен со следующими настройками:"

#: ../book/replication.rst:1039
msgid ""
"box.cfg{\n"
"  <...>,\n"
"  logger = *log file name*,\n"
"  <...>\n"
"}"
msgstr ""
"box.cfg{\n"
"  <...>,\n"
"  logger = *имя_файла_для_ведения_журнала*,\n"
"  <...>\n"
"}"

#: ../book/replication.rst:171
msgid ""
"then there will be lines in the log file, containing the word \"relay\", when a "
"replica connects or disconnects."
msgstr ""
"то на каждую установку/потерю соединения реплики с главным сервером в журнале "
"будут появляться строчки со словом \"relay\"."

#: ../book/replication.rst:178
msgid "Preventing duplicate actions"
msgstr "Предотвращение дублирующихся действий"

#: ../book/replication.rst:180
msgid ""
"Suppose that the replica tries to do something that the master has already done. "
"For example: |br| ``box.schema.space.create('X')`` |br| This would cause an "
"error, \"Space X exists\". For this particular situation, the code could be "
"changed to: |br| ``box.schema.space.create('X', {if_not_exists=true})`` |br| But "
"there is a more general solution: the :samp:`box.once({key}, {function})` "
"method. If ``box.once()`` has been called before with the same :samp:`{key}` "
"value, then :samp:`{function}` is ignored; otherwise :samp:`{function}` is "
"executed. Therefore, actions which should only occur once during the life of a "
"replicated session should be placed in a function which is executed via ``box."
"once()``. For example:"
msgstr ""
"Предположим, что реплика пытается сделать нечто, что уже было сделано на главном "
"сервере. Например: |br| :code:`box.schema.space.create('X')` |br| Это приведет к "
"ошибке \"Space X exists\" (\"Пространство X уже существует\"). В данном частном "
"случае можно скорректировать инструкцию следующим образом: |br| :code:`box."
"schema.space.create('X', {if_not_exists=true})` |br| Но существует и более общее "
"решение: использовать метод :samp:`box.once({key}, {function})`. Если :code:`box."
"once()` был вызван ранее с тем же значением параметра :samp:`{key}`, то функция :"
"samp:`{function}` игнорируется; в противном случае функция :samp:`{function}` "
"будет выполнена. Поэтому действия, которые должны совершаться только один раз за "
"время текущей сессии репликации, нужно помещать в функцию и вызывать ее с "
"помощью метода :code:`box.once()`. Например:"

#: ../book/replication.rst:195
msgid ""
"function f()\n"
"  box.schema.space.create('X')\n"
"end\n"
"box.once('space_creator', f)"
msgstr ""
"function f()\n"
"  box.schema.space.create('X')\n"
"end\n"
"box.once('space_creator', f)"

#: ../book/replication.rst:204
msgid "Master-master replication"
msgstr "Репликация по схеме master-master"

#: ../book/replication.rst:206
msgid ""
"In the simple master-replica configuration, the master's changes are seen by the "
"replica, but not vice versa, because the master was specified as the sole "
"replication source. In the master-master configuration, also sometimes called "
"multi-master configuration, it's possible to go both ways. Starting with the "
"simple configuration, the first server has to say:"
msgstr ""
"В случае настройки репликации по схеме master-replica изменения на главном "
"сервере доступны для просмотра с реплики, но не наоборот, потому как главный "
"сервер в такой схеме указан в качестве единственного источника репликации. В "
"случае схемы master-master (иногда ее также называет multi-master) просмотр "
"изменений возможен в любом направлении. В простом случае (master-master с двумя "
"серверами) на первом сервере нужно задать следующие настройки:"

#: ../book/replication.rst:1090
msgid "box.cfg{ replication_source = *uri#2* }"
msgstr "box.cfg{ replication_source = *uri#2* }"

#: ../book/replication.rst:218
msgid ""
"This request can be performed at any time -- :ref:`replication_source "
"<cfg_replication-replication_source>` is a dynamic parameter."
msgstr ""
"Этот запрос можно выполнить в любой момент, т.к. параметр :ref:"
"`replication_source <cfg_replication-replication_source>` можно задавать на ходу."

#: ../book/replication.rst:221
msgid ""
"In this configuration, both servers are \"masters\" and both servers are "
"\"replicas\". Henceforth every change that happens on either server will be "
"visible on the other. The failover benefit is still present, and the load-"
"balancing benefit is enhanced (because clients can connect to either server for "
"data-change requests as well as select requests)."
msgstr ""
"В данном примере оба сервера являются одновременно и \"главными\", и \"репликами"
"\". Поэтому каждое изменение, которое случается на одном сервере, становится "
"доступно для просмотра с другого сервера. Отказоустойчивость в такой "
"конфигурации сохраняется, а возможности по балансировке нагрузки становятся еще "
"шире (теперь клиенты могут обращаться к обоим серверам со всеми типами запросов "
"— как на чтение данных, так и на изменение)."

#: ../book/replication.rst:227
msgid ""
"If two operations for the same tuple take place \"concurrently\" (which can "
"involve a long interval because replication is asynchronous), and one of the "
"operations is ``delete`` or ``replace``, there is a possibility that servers "
"will end up with different contents."
msgstr ""
"Если две операции над одним и тем же кортежем производятся \"параллельно\" (а "
"это может потребовать много времени, поскольку репликация — это асинхронный "
"процесс), причем одна из операций — это ``delete``, а вторая — ``replace``, то "
"существует вероятность, что данные на серверах станут различаться."

#: ../book/replication.rst:234
msgid "All the \"What If?\" questions"
msgstr "Ответы на вопросы \"Что если?\""

#: ../book/replication.rst:236
msgid ""
"Q: What if there are more than two servers with master-master? |br| A: On each "
"server, specify the :ref:`replication_source <cfg_replication-"
"replication_source>` for all the others. For example, server #3 would have a "
"request: |br| :codenormal:`box.cfg{` |br| |nbsp| |nbsp| |nbsp| :codenormal:"
"`replication_source = {`:codeitalic:`uri#1, uri#2`:codenormal:`}` |br| :"
"codenormal:`}`"
msgstr ""
"Вопрос: Что если в кластере вида master-master более двух серверов? |br| Ответ: "
"На каждом сервере нужно задать параметр :ref:`replication_source "
"<cfg_replication-replication_source>` и указать в нем все остальные сервера. "
"Например, для сервера #3 настройки будут следующими: |br| :codenormal:`box.cfg{` "
"|br| |nbsp| |nbsp| |nbsp| :codenormal:`replication_source = {`:codeitalic:"
"`uri#1, uri#2`:codenormal:`}` |br| :codenormal:`}`"

#: ../book/replication.rst:243
msgid ""
"Q: What if a server should be taken out of the cluster? |br| A: For a replica, "
"run ``box.cfg{}`` again specifying a blank replication source: |br| ``box."
"cfg{replication_source=''}``"
msgstr ""
"Вопрос: Что если какой-то сервер нужно убрать из кластера? |br| Ответ: Для "
"реплики — выполните запрос ``box.cfg{}``, указав пустой источник репликации: |"
"br| ``box.cfg{replication_source=''}``"

#: ../book/replication.rst:247
msgid ""
"Q: What if a server leaves the cluster? |br| A: The other servers carry on. If "
"the wayward server rejoins, it will receive all the updates that the other "
"servers made while it was away."
msgstr ""
"Вопрос: Что если какой-то сервер вдруг выбывает из кластера? |br| Ответ: "
"Остальные сервера продолжают работать. Если выбывший сервер снова возвращается в "
"кластер, то он получит информацию о всех изменениях, которые произошли на "
"остальных серверах за время его отсутствия."

#: ../book/replication.rst:251
msgid ""
"Q: What if two servers both change the same tuple? |br| A: The last changer "
"wins. For example, suppose that server#1 changes the tuple, then server#2 "
"changes the tuple. In that case server#2's change overrides whatever server#1 "
"did. In order to keep track of who came last, Tarantool implements a `vector "
"clock <https://en.wikipedia.org/wiki/Vector_clock>`_."
msgstr ""
"Вопрос: Что если два сервера совершают изменения, связанные с одним и тем же "
"кортежем? |br| Ответ: Применятся последние из совершенных изменений. Для примера "
"предположим, что сервер #1 меняет некоторый кортеж, а затем сервер #2 меняет тот "
"же кортеж. В данном случае изменения сервера #2 затрут изменения сервера #1. "
"Чтобы отслеживать, кто был последним, в Tarantool'е используются `векторные часы "
"<https://en.wikipedia.org/wiki/Vector_clock>`_."

#: ../book/replication.rst:257
msgid ""
"Q: What if two servers both insert the same tuple? |br| A: If a master tries to "
"insert a tuple which a replica has inserted already, this is an example of a "
"severe error. Replication stops. It will have to be restarted manually."
msgstr ""
"Вопрос: Что если оба сервера выполняют вставку одного и того же кортежа? |br| "
"Ответ: Если главный сервер попытается вставить кортеж, который уже был вставлен "
"на реплике, то это будет пример серьезной ошибки. Репликация остановится, и ее "
"придется перезапускать в ручную."

#: ../book/replication.rst:262
msgid ""
"Q: What if a master disappears and the replica must take over? |br| A: A message "
"will appear on the replica stating that the connection is lost. The replica must "
"now become independent, which can be done by saying ``box."
"cfg{replication_source=''}``."
msgstr ""
"Вопрос: Что если главный сервер становится недоступен и пользователям приходится "
"переключаться реплику? |br| Ответ: Реплика получает сообщение, что связь "
"потеряна. Теперь реплика должна начать работать независимо. Для этого ей нужно "
"задать пустой источник репликации, выполнив на стороне реплики запрос ``box."
"cfg{replication_source=''}``."

#: ../book/replication.rst:267
msgid ""
"Q: What if it's necessary to know what cluster a server is in? |br| A: The "
"identification of the cluster is a UUID which is generated when the first master "
"starts for the first time. This UUID is stored in a tuple of the :ref:`box.space."
"_schema <box_space-schema>` system space. So to see it, say: ``box.space._schema:"
"select{'cluster'}``"
msgstr ""
"Вопрос: Что если нужно посмотреть, к какому кластеру принадлежит данный сервер? |"
"br| Ответ: Идентификатором кластера является UUID, который генерируется при "
"первом запуске главного сервера. Данный UUID хранится в системном пространстве :"
"ref:`box.space._schema <box_space-schema>`. Чтобы посмотреть UUID кластера, "
"введите запрос ``box.space._schema:select{'cluster'}``"

#: ../book/replication.rst:273
msgid ""
"Q: What if it's necessary to know what other servers belong in the cluster? |br| "
"A: The universal identification of a server is a UUID in ``box.info.server."
"uuid``. The ordinal identification of a server within a cluster is a number in "
"``box.info.server.id``. To see all the servers in the cluster, say: ``box.space."
"_cluster:select{}``. This will return a table with all {server.id, server.uuid} "
"tuples for every server that has ever joined the cluster."
msgstr ""
"Вопрос: Что если нужно посмотреть, какие сервера входят в кластер? |br| Ответ: У "
"каждого сервера есть универсальный идентификатор — это его UUID в поле ``box."
"info.server.uuid``. Также у сервера есть его порядковый идентификатор в кластере "
"— это номер в поле ``box.info.server.id``. Чтобы увидеть номера всех серверов в "
"кластере, введите запрос: ``box.space._cluster:select{}``. Данный запрос "
"возвращает таблицу со всеми кортежами вида {server.id, server.uuid} для всех "
"серверов, что когда-либо входили в данный кластер."

#: ../book/replication.rst:281
msgid ""
"Q: What if one of the server's files is corrupted or deleted? |br| A: Stop the "
"server, destroy all the database files (the ones with extension \"snap\" or "
"\"xlog\" or \".inprogress\"), restart the server, and catch up with the master "
"by contacting it again (just say ``box.cfg{...replication_source=...}``)."
msgstr ""
"Вопрос: Что если какой-то из файлов репликации на реплике поврежден или удален? |"
"br| Ответ: Нужно остановить сервер, удалить все файлы, относящиеся к базе данных "
"(это файлы с расширениями \"snap\", \"xlog\" и \".inprogress\"), снова запустить "
"сервер и ввести запрос ``box.cfg{...replication_source=...}``, чтобы "
"восстановить соединение с главным сервером и загрузить данные с него."

#: ../book/replication.rst:287
msgid ""
"Q: What if replication causes security concerns? |br| A: Prevent unauthorized "
"replication sources by associating a password with every user that has access "
"privileges for the relevant spaces, and every user that has a replication :ref:"
"`role <authentication-rep_role>`. That way, the :ref:`URI <index-uri>` for the :"
"ref:`replication_source <cfg_replication-replication_source>` parameter will "
"always have to have the long form |br| ``replication_source='username:"
"password@host:port'``"
msgstr ""
"Вопрос: Что если при репликации возникают вопросы, связанные с безопасностью? |"
"br| Ответ: Чтобы предотвратить появление несанкционированных источников "
"репликации, нужно задать пароль для каждого пользователя, у которого есть "
"привилегии доступа к соответствующим пространствам, а также для каждого "
"пользователя, у которого настроена :ref:`репликационная роль <authentication-"
"rep_role>`. Заметьте, что :ref:`URI <index-uri>` для параметра :ref:"
"`replication_source <cfg_replication-replication_source>` теперь нужно всегда "
"указывать в полном виде: |br| ``replication_source='username:password@host:"
"port'``"

#: ../book/replication.rst:295
msgid ""
"Q: What if advanced users want to understand better how it all works? |br| A: "
"See the description of server startup with replication in the :ref:`Internals "
"<b_internals-replication>` appendix."
msgstr ""
"Вопрос: Что если продвинутые пользователи хотят глубже разобраться с тем, как "
"работает репликация? |br| Ответ: См. информацию о запуске сервера с репликацией "
"в Приложении B. :ref:`Детали реализации <b_internals-replication>`."

#: ../book/replication.rst:301
msgid "Hands-on replication tutorial"
msgstr "Практическое руководство по репликации"

#: ../book/replication.rst:303
msgid ""
"After following the steps here, an administrator will have experience creating a "
"cluster and adding a replica."
msgstr ""
"Ниже приводятся пошаговые инструкции, которые помогут вам получить практический "
"опыт администрирования кластера, а именно опыт создания кластера и добавления "
"реплики."

#: ../book/replication.rst:306
msgid ""
"Start two shells. Put them side by side on the screen. (This manual has a tabbed "
"display showing \"Terminal #1\". Click the \"Terminal #2\" tab to switch to the "
"display of the other shell.)"
msgstr ""
"Запустите два терминала, каждый в своем окне, и расположите их рядом на экране. "
"(Далее в примерах оба терминала показаны в виде закладок. Щелкните на заголовок "
"закладки — \"Terminal #1\" или \"Terminal #2\", — чтобы увидеть вывод на "
"соответствующем терминале.)"

#: ../book/replication.rst:332 ../book/replication.rst:339
#: ../book/replication/1_2.rst:1
msgid "$"
msgstr "$"

#: ../book/replication.rst:343
msgid "On the first shell, which we'll call Terminal #1, execute these commands:"
msgstr "В первом терминале (Terminal #1) выполните следующие команды:"

#: ../book/replication.rst:345
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_1/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"tarantool> box.schema.user.grant('replicator','execute','role','replication')\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"
msgstr ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_1/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"tarantool> box.schema.user.grant('replicator','execute','role','replication')\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"

#: ../book/replication.rst:357
msgid ""
"The result is that a new cluster is set up, and the server's UUID is displayed. "
"Now the screen looks like this: (except that UUID values are always different):"
msgstr ""
"В результате были заданы настройки нового кластера, а на экране был выведен UUID "
"текущего сервера. Теперь вывод на экране выглядит следующим образом (за тем "
"исключением, что UUID у вас будут другие):"

#: ../book/replication/1_1.rst:1
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"$ ~/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('replicator','execute','role','replication')\n"
"---\n"
"...\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"..."
msgstr ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"$ ~/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('replicator','execute','role','replication')\n"
"---\n"
"...\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"..."

#: ../book/replication.rst:389
msgid "On the second shell, which we'll call Terminal #2, execute these commands:"
msgstr "Во втором терминале (Terminal #2) выполните следующие команды:"

#: ../book/replication.rst:391
msgid ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ~/tarantool_test_node_2/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"
msgstr ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ~/tarantool_test_node_2/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"

#: ../book/replication.rst:404
msgid ""
"The result is that a replica is set up. Messages appear on Terminal #1 "
"confirming that the replica has connected and that the WAL contents have been "
"shipped to the replica. Messages appear on Terminal #2 showing that replication "
"is starting. Also on Terminal#2 the _cluster UUID values are displayed, and one "
"of them is the same as the _cluster UUID value that was displayed on Terminal "
"#1, because both servers are in the same cluster."
msgstr ""
"В результате были заданы настройки сервера-реплики. На экране первого терминала "
"(Terminal #1) появились сообщения с подтверждениями, что реплика установила "
"соединение с главным сервером и что содержимое WAL-файла было отправлено на "
"реплику. На экране второго терминала (Terminal #2) появились сообщения о том, "
"что репликация начинается, а также там были выведены UUID из системного "
"пространства _cluster (один из них совпадает с UUID в первом терминале, "
"поскольку оба сервера входят в общий кластер)."

#: ../book/replication/2_1.rst:1
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"...\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'"
msgstr ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"...\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'"

#: ../book/replication/2_2.rst:1 ../book/replication/3_2.rst:1
msgid ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"<...>\n"
"<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple "
"arena...\n"
"<...> [11243] main/101/interactive C> starting replication from localhost:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
"<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot from "
"127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> done\n"
"<...> [11243] snapshot/101/main I> creating `./00000000000000000000.snap."
"inprogress'\n"
"<...> [11243] snapshot/101/main I> saving snapshot `./00000000000000000000.snap."
"inprogress'\n"
"<...> [11243] snapshot/101/main I> done\n"
"<...> [11243] iproto I> binary: started\n"
"<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
"<...> [11243] wal/101/main I> creating `./00000000000000000000.xlog.inprogress'\n"
"<...> [11243] main/101/interactive I> ready to accept requests\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"..."
msgstr ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"<...>\n"
"<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple "
"arena...\n"
"<...> [11243] main/101/interactive C> starting replication from localhost:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
"<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot from "
"127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> done\n"
"<...> [11243] snapshot/101/main I> creating `./00000000000000000000.snap."
"inprogress'\n"
"<...> [11243] snapshot/101/main I> saving snapshot `./00000000000000000000.snap."
"inprogress'\n"
"<...> [11243] snapshot/101/main I> done\n"
"<...> [11243] iproto I> binary: started\n"
"<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
"<...> [11243] wal/101/main I> creating `./00000000000000000000.xlog.inprogress'\n"
"<...> [11243] main/101/interactive I> ready to accept requests\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"..."

#: ../book/replication.rst:440
msgid "On Terminal #1, execute these requests:"
msgstr "В первом терминале (Terminal #1) выполните следующие запросы:"

#: ../book/replication.rst:442
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> i = s:create_index('primary', {})\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> i = s:create_index('primary', {})\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}"

#: ../book/replication.rst:448 ../book/replication.rst:615
msgid "Now the screen looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../book/replication/3_1.rst:1 ../book/replication/4_1.rst:1
msgid ""
"<... ...>\n"
"tarantool>\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'\n"
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('primary', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool>\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'\n"
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('primary', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"..."

#: ../book/replication.rst:479
msgid ""
"The creation and insertion were successful on Terminal #1. Nothing has happened "
"on Terminal #2."
msgstr ""
"В первом терминале успешно отработали операции CREATE и INSERT. Но во втором "
"терминале ничего не произошло."

#: ../book/replication.rst:482
msgid "On Terminal #2, execute these requests:"
msgstr "Во втором терминале (Terminal #2) выполните следующие запросы:"

#: ../book/replication.rst:484
msgid ""
"tarantool> s = box.space.tester\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}"
msgstr ""
"tarantool> s = box.space.tester\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}"

#: ../book/replication.rst:490
msgid ""
"Now the screen looks like this (remember to click on the \"Terminal #2\" tab "
"when looking at Terminal #2 results):"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../book/replication/4_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"...\n"
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"...\n"
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"..."

#: ../book/replication.rst:521
msgid ""
"The selection and insertion were successful on Terminal #2. Nothing has happened "
"on Terminal #1."
msgstr ""
"Во втором терминале успешно отработали операции SELECT и INSERT. Но в первом "
"терминале ничего не произошло."

#: ../book/replication.rst:524
msgid "On Terminal #1, execute these Tarantool requests and shell commands:"
msgstr "В первом терминале (Terminal #1) выполните следующие запросы и команды:"

#: ../book/replication.rst:526
msgid ""
"$ os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"$ ls -l ~/tarantool_test_node_2"
msgstr ""
"$ os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"$ ls -l ~/tarantool_test_node_2"

#: ../book/replication.rst:532
msgid ""
"Now Tarantool #1 is stopped. Messages appear on Terminal #2 announcing that "
"fact. The ``ls -l`` commands show that both servers have made snapshots, which "
"have similar sizes because they both contain the same tuples."
msgstr ""
"Теперь Tarantool-сервер в первом терминале остановлен. В окне второго терминала "
"появились сообщения об этом событии. С помощью команд ``ls -l`` мы убедились, "
"что на обоих серверах создались файлы-снимки с одинаковыми размерами, поскольку "
"там содержатся одни и те же кортежи."

#: ../book/replication/5_1.rst:1 ../book/replication/6_1.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$"

#: ../book/replication/5_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"
msgstr ""
"<... ...>\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"

#: ../book/replication.rst:565
msgid "On Terminal #2, ignore the error messages, and execute these requests:"
msgstr ""
"Во втором терминале (Terminal #2) проигнорируйте сообщения об ошибках и "
"выполните следующие запросы:"

#: ../book/replication.rst:568
msgid ""
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"tarantool> box.space.tester:insert{3, 'Another'}"
msgstr ""
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"tarantool> box.space.tester:insert{3, 'Another'}"

#: ../book/replication.rst:573
msgid "Now the screen looks like this (ignoring the error messages):"
msgstr ""
"Теперь вывод на экране выглядит следующим образом (сообщения об ошибках мы не "
"приводим):"

#: ../book/replication/6_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [11243] main/105/applier/localhost:3301 I> can't read row\n"
"<...> [11243] main/105/applier/localhost:3301 coio.cc:352 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 6, aka 127.0.0.1:58734, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [11243] main/105/applier/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [11243] main/105/applier/localhost:3301 I> can't read row\n"
"<...> [11243] main/105/applier/localhost:3301 coio.cc:352 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 6, aka 127.0.0.1:58734, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [11243] main/105/applier/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"..."

#: ../book/replication.rst:605
msgid ""
"Terminal #2 has done a select and an insert, even though Terminal #1 is down."
msgstr ""
"Запросы SELECT и INSERT во втором терминале отработали несмотря на то, что "
"сервер в первом терминале остановлен."

#: ../book/replication.rst:607
msgid "On Terminal #1 execute these commands:"
msgstr "В первом терминале (Terminal #1) выполните следующие запросы:"

#: ../book/replication.rst:609
msgid ""
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#: ../book/replication/7_1.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"..."

#: ../book/replication/7_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated"

#: ../book/replication.rst:646
msgid ""
"The master has reconnected to the cluster, and has NOT found what the replica "
"wrote while the master was away. That is not a surprise -- the replica has not "
"been asked to act as a replication source."
msgstr ""
"Главный сервер снова установил соединение с кластером и НЕ обнаружил изменения, "
"сделанные репликой за время его недоступности. Это и не удивительно: мы же не "
"просили реплику выступать в качестве источника репликации."

#: ../book/replication.rst:650
msgid "On Terminal #1, say:"
msgstr "В первом терминале (Terminal #1) введите:"

#: ../book/replication.rst:652
msgid ""
"tarantool> box.cfg{\n"
"         >   replication_source = 'replicator:password@localhost:3302'\n"
"         > }\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""
"tarantool> box.cfg{\n"
"         >   replication_source = 'replicator:password@localhost:3302'\n"
"         > }\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#: ../book/replication.rst:659
msgid "The screen now looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../book/replication/8_1.rst:1
msgid ""
"<... ...>\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> box.cfg{\n"
"         >   replication_source='replicator:password@localhost:3302'\n"
"         > }\n"
"[28987] main/101/interactive C> starting replication from localhost:3302\n"
"---\n"
"...\n"
"[22612] main/101/interactive C> starting replication from localhost:3302\n"
"[22612] main/101/interactive I> set 'replication_source' configuration\n"
"        option to \"replicator:password@localhost:3302\"\n"
"[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at 127.0.0.1:3302\n"
"[22612] main/104/applier/localhost:3302 I> authenticated\n"
"[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'\n"
"[22612] relay/127.0.0.1:33510/102/main I> done `./00000000000000000000.xlog'\n"
"[22612] relay/127.0.0.1:33510/102/main I> recover from `./00000000000000000008."
"xlog'\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"  - [3, 'Another']\n"
"..."
msgstr ""
"<... ...>\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> box.cfg{\n"
"         >   replication_source='replicator:password@localhost:3302'\n"
"         > }\n"
"[28987] main/101/interactive C> starting replication from localhost:3302\n"
"---\n"
"...\n"
"[22612] main/101/interactive C> starting replication from localhost:3302\n"
"[22612] main/101/interactive I> set 'replication_source' configuration\n"
"        option to \"replicator:password@localhost:3302\"\n"
"[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at 127.0.0.1:3302\n"
"[22612] main/104/applier/localhost:3302 I> authenticated\n"
"[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'\n"
"[22612] relay/127.0.0.1:33510/102/main I> done `./00000000000000000000.xlog'\n"
"[22612] relay/127.0.0.1:33510/102/main I> recover from `./00000000000000000008."
"xlog'\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"  - [3, 'Another']\n"
"..."

#: ../book/replication/8_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated\n"
"tarantool>\n"
"<...> [11243] relay/127.0.0.1:36150/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11243] relay/127.0.0.1:36150/101/main recovery.cc:211 W> file\n"
"     `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11243] relay/127.0.0.1:36150/102/main I> recover from "
"`./00000000000000000000.xlog'"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated\n"
"tarantool>\n"
"<...> [11243] relay/127.0.0.1:36150/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11243] relay/127.0.0.1:36150/101/main recovery.cc:211 W> file\n"
"     `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11243] relay/127.0.0.1:36150/102/main I> recover from "
"`./00000000000000000000.xlog'"

#: ../book/replication.rst:704
msgid ""
"This shows that the two servers are once again in synch, and that each server "
"sees what the other server wrote."
msgstr ""
"Тут мы видим, что оба сервера снова синхронизовались и что каждый из них видит "
"те записи, которые сделал другой."

#: ../book/replication.rst:707
msgid ""
"To clean up, say \"``os.exit()``\" on both Terminal #1 and Terminal #2, and then "
"on either terminal say:"
msgstr ""
"Чтобы удалить все тестовые данные, выполните \"``os.exit()``\" на обоих "
"терминалах, а затем на каждом из них выполните следующие команды:"

#: ../book/replication.rst:710
msgid ""
"$ cd ~\n"
"$ rm -R ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_2"
msgstr ""
"$ cd ~\n"
"$ rm -R ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_2"

#: ../book/administration.rst:578
msgid "Backups"
msgstr "Резервное копирование"

#: ../book/administration.rst:580
msgid ""
"The exact procedure for backing up a database depends on: how up-to-date the "
"database must be, how frequently backups must be taken, whether it is okay to "
"disrupt other users, and whether the procedure should be optimized for size "
"(saving disk space) or for speed (saving time). So there is a spectrum of "
"possible policies, ranging from cold-and-simple to hot-and-difficult."
msgstr ""
"При выборе конкретной процедуры для резервного копирования базы данных нужно "
"учитывать следующие требования: насколько актуальной должна быть копия, можно ли "
"временно отключать других пользователей, а также нужна ли оптимизация размера "
"копии (чтобы копия занимала меньше места на диске) или скорости самой процедуры "
"(чтобы процедура занимала меньше времени). Выбирать можно из нескольких "
"вариантов в диапазоне от \"простого и холодного\" до \"трудного и горячего\"."

#: ../book/administration.rst:591
#, fuzzy
msgid "Cold backup"
msgstr "**\"Холодное\" резервирование**"

#: ../book/administration.rst:593
msgid ""
"In essence: The last snapshot file is a backup of the entire database; and the "
"WAL files that are made after the last snapshot are incremental backups. "
"Therefore taking a backup is a matter of copying the snapshot and WAL files."
msgstr ""
"Суть процедуры: последний созданный Tarantool'ом файл-снимок является резервной "
"копией всей базы; а WAL-файлы, созданные следом, являются инкрементными копиями. "
"Поэтому вся процедура резервирования сводится к копированию последнего файла-"
"снимка и последующих WAL-файлов."

#: ../book/administration.rst:598
msgid ""
"Prevent all users from writing to the database. This can be done by shutting "
"down the server, or by saying ``box.cfg{read_only=true}`` and then ensuring that "
"all earlier writes are complete (:program:`fsync` can be used for this purpose)."
msgstr ""
"Временно запретите всем пользователям делать записи в базе. Для этого можно "
"остановить Tarantool-сервер, либо ввести запрос ``box.cfg{read_only=true}`` и "
"убедиться, что все обращения на запись завершились (для этого можно "
"использовать :program:`fsync`)."

#: ../book/administration.rst:602
msgid "If this is a backup of the whole database, say :samp:`box.snapshot()`."
msgstr ""
"Если вы хотите создать резеврную копию для всей базы целиком, введите запрос :"
"samp:`box.snapshot()`."

#: ../book/administration.rst:604
msgid ""
"Use :program:`tar` to make a (possibly compressed) copy of the latest :file:`."
"snap` and :file:`.xlog` files on the :ref:`snap_dir <cfg_basic-snap_dir>` and :"
"ref:`wal_dir <cfg_basic-wal_dir>` directories."
msgstr ""
"С помощью :program:`tar` создайте сжатую (насколько это можно) копию последнего :"
"file:`.snap`-файла и последующих :file:`.xlog`-файлов из директорий :ref:"
"`snap_dir <cfg_basic-snap_dir>` и :ref:`wal_dir <cfg_basic-wal_dir>`."

#: ../book/administration.rst:608
msgid "If there is a security policy, encrypt the tar file."
msgstr ""
"Если того требуют правила безопасности, зашифруйте получившийся :file:`tar`-файл."

#: ../book/administration.rst:609
msgid "Copy the tar file to a safe place."
msgstr "Скопируйте :file:`tar`-файл в надежное место."

#: ../book/administration.rst:611
msgid ""
"... Later, restoring the database is a matter of taking the tar file and putting "
"its contents back in the ``snap_dir`` and ``wal_dir`` directories."
msgstr ""
"... В дальнейшем вы сможете восстановить базу данных, просто взяв этот :file:"
"`tar`-файл и разархивировав его содержимое в директории ``snap_dir`` и "
"``wal_dir``."

#: ../book/administration.rst:617
#, fuzzy
msgid "Continuous remote backup"
msgstr "**Постоянное удаленное резервирование**"

#: ../book/administration.rst:619
msgid ""
"In essence: :ref:`replication <index-box_replication>` is useful for backup as "
"well as for load balancing. Therefore taking a backup is a matter of ensuring "
"that any given replica is up to date, and doing a cold backup on it. Since all "
"the other replicas continue to operate, this is not a cold backup from the end "
"user's point of view. This could be done on a regular basis, with a cron job or "
"with a Tarantool fiber."
msgstr ""
"Суть процедуры: для резервирования (а также для балансирования нагрузки) можно "
"использовать :ref:`репликацию <index-box_replication>`. Процедура резервирования "
"в рамках репликационного кластера сводится к тому, чтобы держать все реплики в "
"актуальном состоянии и периодически делать с них \"холодные\" копии. Поскольку "
"во время снятия копии с какой-либо одной реплики все остальные реплики "
"продолжают синхронизироваться с главным сервером, то эта процедура несколько "
"отличается от описанной выше процедуры \"холодного\" резервирования. Регулярное "
"резервирование в кластере можно настроить с помощью планировщика :program:`cron` "
"или Tarantool-файбера."

#: ../book/administration.rst:629
#, fuzzy
msgid "Hot backup"
msgstr "**\"Горячее\" резервирование**"

#: ../book/administration.rst:631
msgid ""
"In essence: The logged changes done since the last cold backup must be secured, "
"while the system is running."
msgstr ""
"Суть процедуры: по ходу работы системы нужно сохранять записи об изменениях, "
"сделанных со времени последнего \"холодного\" резервирования."

#: ../book/administration.rst:635
msgid ""
"For this purpose you need a \"file copy\" utility that will do the copying "
"remotely and continuously, copying only the parts of a file that are changing. "
"One such utility is `rsync <https://en.wikipedia.org/wiki/rsync>`_."
msgstr ""
"Для этого вам понадобится специальная утилита для копирования частей файлов "
"(например, `rsync <https://en.wikipedia.org/wiki/rsync>`_), которая позволит "
"удаленно и на постоянной основе копировать только изменившиеся части файлов-"
"снимков и WAL-файлов, а не все эти файлы целиком."

#: ../book/administration.rst:640
msgid ""
"Alternatively, you need an ordinary file copy utility, but there should be "
"frequent production of new snapshot files or new WAL files as changes occur, so "
"that only the new files need to be copied."
msgstr ""
"Вы можете взять и обычную утилиту (для копирования файлов целиком), но тогда вам "
"придется создавать файлы-снимки и WAL-файлы на каждое изменение, чтобы нужно "
"было копировать только новые файлы."

#: ../book/administration.rst:644
msgid "Note re storage engine: vinyl databases require additional steps."
msgstr ""
"Примечание про движок: при организации резервирования для баз данных на движке "
"vinyl понадобятся дополнительные действия."

#: ../book/administration.rst:648
msgid "Updates/upgrades"
msgstr "Обновление сервера и базы данных"

#: ../book/administration.rst:652
msgid "Updating Tarantool in production"
msgstr "Обновление Tarantool'а в условиях эксплуатации"

#: ../book/administration.rst:654
msgid ""
"First, put your application's business logic in a Tarantool-Lua module that "
"exports its functions for CALL."
msgstr ""
"Во-первых, вынесите всю бизнес-логику своего приложения в отдельный Tarantool-"
"модуль на языке Lua так, чтобы все нужные функции были доступны для вызова извне "
"(CALL)."

#: ../book/administration.rst:657
msgid "For example, :file:`/usr/share/tarantool/myapp.lua`:"
msgstr "Вот пример такого модуля, файл :file:`/usr/share/tarantool/myapp.lua`:"

#: ../book/administration.rst:659
#, fuzzy
msgid ""
"local function start()\n"
"  -- Initial version\n"
"  box.once(\"myapp:.1.0\", function()\n"
"  box.schema.space.create(\"somedata\")\n"
"  box.space.somedata:create_index(\"primary\")\n"
"  ...\n"
"\n"
"  -- migration code from 1.0 to 1.1\n"
"  box.once(\"myapp:.v1.1\", function()\n"
"  box.space.somedata.index.primary:alter(...)\n"
"  ...\n"
"\n"
"  -- migration code from 1.1 to 1.2\n"
"  box.once(\"myapp:.v1.2\", function()\n"
"  box.space.somedata.space:alter(...)\n"
"  box.space.somedata:insert(...)\n"
"  ...\n"
"end\n"
"\n"
"-- start some background fibers if you need\n"
"\n"
"local function stop()\n"
"  -- stop all background fibers and cleanup resources\n"
"end\n"
"\n"
"local function api_for_call(xxx)\n"
"  -- do some business\n"
"end\n"
"\n"
"return {\n"
"  start = start;\n"
"  stop = stop;\n"
"  api_for_call = api_for_call;\n"
"}"
msgstr ""
"local function start()\n"
"-- Первоначальная версия\n"
"box.once(\"myapp:.1.0\", function()\n"
"box.schema.space.create(\"somedata\")\n"
"box.space.somedata:create_index(\"primary\")\n"
"...\n"
"end\n"
"\n"
"-- Код для миграции с 1.0 на 1.1\n"
"box.once(\"myapp:.v1.1\", function()\n"
"box.space.somedata.index.primary:alter(...)\n"
"...\n"
"end\n"
"\n"
"-- Код для миграции с 1.1 на 1.2\n"
"box.once(\"myapp:.v1.2\", function()\n"
"box.space.somedata.space:alter(...)\n"
"box.space.somedata:insert(...)\n"
"...\n"
"end\n"
"\n"
"-- Если нужно, запустить файберы в фоновом режиме\n"
"\n"
"local function stop()\n"
"-- Остановить все фоновые файберы и освободить ресурсы\n"
"end\n"
"\n"
"local function api_for_call(xxx)\n"
"-- Сделать что-то полезное\n"
"end\n"
"\n"
"return {\n"
"start = start;\n"
"stop = stop;\n"
"api_for_call = api_for_call;\n"
"}"

#: ../book/administration.rst:696
msgid ""
"This file is maintained by the application's developers. On its side, Tarantool "
"Team provides templates for you to `assemble deb/rpm packages <https://github."
"com/tarantool/modulekit>`_ and utilities to quickly `assemble packages for "
"specific platforms <https://github.com/tarantool/build>`_. If needed, you can "
"split applications into standalone files and/or modules."
msgstr ""
"Поддержка этого файла лежит на стороне разработчиков приложения. А команда "
"разработки Tarantool'а со своей стороны предлагает шаблоны, для того чтобы вы "
"могли `создать у себя deb/rpm-сборку <https://github.com/tarantool/modulekit>`_, "
"а также утилиты для быстрого `создания сборок под разные платформы <https://"
"github.com/tarantool/build>`_. Если понадобится, вы можете разбить приложения на "
"отдельные файлы и/или модули."

#: ../book/administration.rst:703
msgid ""
"Second, put an initialization script to the :file:`/etc/tarantool/instances."
"available` directory."
msgstr ""
"Во вторых, положите скрипт инициализации в директорию :file:`/etc/tarantool/"
"instances.available`."

#: ../book/administration.rst:706
msgid "For example, :file:`/etc/tarantool/instances.available/myappcfg.lua`:"
msgstr ""
"Вот пример такого скрипта, файл :file:`/etc/tarantool/instances.available/"
"myappcfg.lua`:"

#: ../book/administration.rst:708
#, fuzzy
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"  listen = 3301;\n"
"}\n"
"\n"
"if myapp ~= nil then\n"
"  -- hot code reload using tarantoolctl or dofile()\n"
"\n"
"  -- unload old application\n"
"  myapp.stop()\n"
"  -- clear cache for loaded modules and dependencies\n"
"  package.loaded['myapp'] = nil\n"
"  package.loaded['somedep'] = nil; -- dependency of 'myapp'\n"
"end\n"
"\n"
"-- load a new version of app and all dependencies\n"
"myapp = require('myapp').start({some app options controlled by sysadmins})"
msgstr ""
"#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"listen = 3301;\n"
"}\n"
"\n"
"if myapp ~= nil then\n"
"-- \"Горячая\" загрузка кода с помощью tarantoolctl или dofile()\n"
"\n"
"-- Выгрузка старого приложения\n"
"myapp.stop()\n"
"-- Очистка кеша от загруженных модулей и зависимостей\n"
"package.loaded['myapp'] = nil\n"
"package.loaded['somedep'] = nil; -- dependency of 'myapp'\n"
"end\n"
"\n"
"-- Загрузка новой версии приложения и всех зависимостей\n"
"myapp = require('myapp').start({some app options controlled by sysadmins})"

#: ../book/administration.rst:730
msgid ""
"As a more detailed example, you can take the :file:`example.lua` script that "
"ships with Tarantool and defines all configuration options."
msgstr ""
"Более детальный пример (со всеми настройками) содержится в файле :file:`example."
"lua`, который входит в состав дистрибутива Tarantool'а."

#: ../book/administration.rst:733
msgid ""
"This initialization script is actually a configuration file and should be "
"maintained by system administrators, while developers only provide a template."
msgstr ""
"Этот скрипт инициализации по сути является конфигурационным файлом. Его "
"поддержкой должны заниматься системные администраторы, в то время как "
"разработчики только предоставляют им шаблон."

#: ../book/administration.rst:737
msgid ""
"Now update your app file in :file:`/usr/share/tarantool`. Replace your "
"application file (for example, :file:`/usr/share/tarantool/myapp.lua`) and "
"manually reload the :file:`myappcfg.lua` initialization script using :program:"
"`tarantoolctl`:"
msgstr ""
"Теперь обновите файл с вашим приложением в директории :file:`/usr/share/"
"tarantool`. Замените старую версию файла (например, :file:`/usr/share/tarantool/"
"myapp.lua`) и вручную загрузите скрипт инициализации :file:`myappcfg.lua` с "
"помощью утилиты :program:`tarantoolctl`:"

#: ../book/administration.rst:742
msgid "$ tarantoolctl eval /etc/tarantool/instance.enabled/myappcfg.lua"
msgstr "$ tarantoolctl eval /etc/tarantool/instance.enabled/myappcfg.lua"

#: ../book/administration.rst:746
msgid ""
"After that, you need to manually flush the cache of ``package.loaded`` modules."
msgstr "После этого вам нужно вручную очистить кеш модулей ``package.loaded``."

#: ../book/administration.rst:748
msgid ""
"For deb/rpm packages, you can add the ``tarantoolctl eval`` instruction directly "
"into Tarantool's specification in :file:`RPM.spec` and the :file:`/debian` "
"directory."
msgstr ""
"Чтобы создать deb/rpm-сборку, вы можете добавить инструкцию ``tarantoolctl "
"eval`` прямо в спецификацию Tarantool'а в файле :file:`RPM.spec` и в директории :"
"file:`/debian`."

#: ../book/administration.rst:752
msgid ""
"Finally, clients make a CALL to ``myapp.api_for_call`` and other API functions."
msgstr ""
"В итоге клиенты делают вызов (CALL) функции ``myapp.api_for_call`` и других "
"функций из API."

#: ../book/administration.rst:754
msgid ""
"In the case of ``tarantool-http``, there is no need to start the binary protocol "
"at all."
msgstr ""
"Если вы используете ``tarantool-http``, то запускать бинарный протокол не нужно."

#: ../book/administration.rst:759
msgid "Upgrading a Tarantool database"
msgstr ""

#: ../book/administration.rst:761
msgid ""
"This information applies for users who created databases with older versions of "
"the Tarantool server, and have now installed a newer version. The request to "
"make in this case is: :samp:`box.schema.upgrade()`."
msgstr ""
"Эта информация полезна в том случае, если у вас есть база данных, работающая на "
"какой-либо старой версии Tarantool'а, а теперь вы установили Tarantool новой "
"версии. В этом случае выполните запрос :samp:`box.schema.upgrade()`."

#: ../book/administration.rst:765
msgid ""
"For example, here is what happens when one runs :samp:`box.schema.upgrade()` "
"with a database that was created in early 2015. Only a small part of the output "
"is shown."
msgstr ""
"Например, вот что происходит, если выполнить запрос :samp:`box.schema.upgrade()` "
"для базы, созданной в начале 2015 года (для примера показана лишь малая часть "
"выводимых сообщений):"

#: ../book/administration.rst:769
msgid ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to [[0,"
"\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."
msgstr ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to [[0,"
"\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."

#: ../book/administration.rst:782
msgid "Server signal handling"
msgstr "Обработка сигналов от сервера"

#: ../book/administration.rst:784
msgid "The server processes these signals during the main thread event loop:"
msgstr "Во время основного цикла Tarantool-сервер обрабатывает следующие сигналы:"

#: ../book/administration.rst:787
msgid "SIGHUP"
msgstr "SIGHUP"

#: ../book/administration.rst:789
msgid ""
"may cause log file rotation, see :ref:`the example in section \"Logging\" "
"<cfg_logging-logging_example>`."
msgstr ""
"может привести к ротации лога, см. :ref:`пример в разделе \"Запись в журнал\" "
"<cfg_logging-logging_example>`."

#: ../book/administration.rst:791
msgid "SIGUSR1"
msgstr "SIGUSR1"

#: ../book/administration.rst:793
msgid ""
"may cause saving of a snapshot, see the description of :ref:`box.snapshot <admin-"
"snapshot>`."
msgstr ""
"может привести к сохранению снимка, см. описание функции :ref:`box.snapshot "
"<admin-snapshot>`."

#: ../book/administration.rst:795
msgid "SIGTERM"
msgstr "SIGTERM"

#: ../book/administration.rst:797
msgid "may cause graceful shutdown (information will be saved first)."
msgstr ""
"может привести к корректному завершению работы (с предварительным сохранением "
"всех данных)."

#: ../book/administration.rst:798
msgid "SIGINT"
msgstr "SIGINT"

#: ../book/administration.rst:800
msgid "(also known as keyboard interrupt) may cause graceful shutdown."
msgstr ""
"(или \"прерывание с клавиатуры\") может привести к корректному завершению работы "
"(с предварительным сохранением всех данных)."

#: ../book/administration.rst:801
msgid "SIGKILL"
msgstr "SIGKILL"

#: ../book/administration.rst:803
msgid "causes shutdown."
msgstr "приводит к аварийному завершению работы (с возможной потерей данных)."

#: ../book/administration.rst:805
msgid ""
"Other signals will result in behavior defined by the operating system. Signals "
"other than SIGKILL may be ignored, especially if the server is executing a long-"
"running procedure which prevents return to the main thread event loop."
msgstr ""
"Действие других сигналов определяется операционной системой. Все сигналы, кроме "
"SIGKILL, могут быть проигнорированы, особенно если Tarantool-сервер выполняет "
"длительную процедуру, которая позволяет вернуться к главному циклу."

#: ../book/administration.rst:813
msgid "Process title"
msgstr "Название процесса"

#: ../book/administration.rst:815
msgid ""
"Linux and FreeBSD operating systems allow a running process to modify its title, "
"which otherwise contains the program name. Tarantool uses this feature to help "
"meet the needs of system administration, such as figuring out what services are "
"running on a host, their status, and so on."
msgstr ""
"Операционные системы Linux и FreeBSD позволяют запущенному процессу менять его "
"название (title), в котором изначально содержится имя программы (name). "
"Tarantool использует эту возможность, чтобы упростить работу системного "
"администратора, например посмотреть, какие службы запущены на хосте, их статус и "
"т.д."

#: ../book/administration.rst:820
msgid "A Tarantool server's process title has these components:"
msgstr "Название процесса Tarantool-сервера состоит из следующих частей:"

#: ../book/administration.rst:822
msgid ""
":extsamp:`{**{program_name}**} [{**{initialization_file_name}**}] "
"{**{<role_name>}**} [{**{custom_proc_title}**}]`"
msgstr ""
":extsamp:`{**{имя_программы}**} [{**{имя_файла_инициализации}**}] {**{<имя_роли>}"
"**} [{**{название_процесса}**}]`"

#: ../book/administration.rst:824
msgid "**program_name** is typically \"tarantool\"."
msgstr "**имя_программы** — это, как правило, \"tarantool\"."

#: ../book/administration.rst:825
msgid ""
"**initialization_file_name** is the name of an :ref:`initialization file <index-"
"init_label>`, if one was specified."
msgstr ""
"**имя_файла_инициализации** — это имя  :ref:`файла инициализации на Lua <index-"
"init_label>`, если этот файл был указан при запуске."

#: ../book/administration.rst:827
msgid "**role_name** is:"
msgstr "**имя_роли** — это может быть один из следующих вариантов:"

#: ../book/administration.rst:829
msgid "\"running\" (ordinary node \"ready to accept requests\"),"
msgstr "\"running\" (узел находится в режиме \"готов к принятию запросов\"),"

#: ../book/administration.rst:830
msgid "\"loading\" (ordinary node recovering from old snap and wal files),"
msgstr ""
"\"loading\" (узел, который загружает данные из ранее сохраненного снимка и WAL-"
"файла),"

#: ../book/administration.rst:831
msgid "\"orphan\" (not in a cluster),"
msgstr "\"orphan\" (узел не входит в состав кластера),"

#: ../book/administration.rst:832
msgid "\"hot_standby\", or"
msgstr ""

#: ../book/administration.rst:833
msgid "\"dumper\" + process-id (saving a snapshot)."
msgstr "\"dumper\" + process-id (идет сохранение снимка)."

#: ../book/administration.rst:835
msgid ""
"**custom_proc_title** is taken from the :ref:`custom_proc_title <cfg_basic-"
"custom_proc_title>` configuration parameter, if one was specified."
msgstr ""
"**название_процесса** — это необязательное название Tarantool-процесса в "
"системе, которое берется из конфигурационного параметра :ref:`custom_proc_title "
"<cfg_basic-custom_proc_title>`, если он указан."

#: ../book/administration.rst:839
msgid "For example:"
msgstr "Например:"

#: ../book/administration.rst:841
msgid ""
"$ ps -AF | grep tarantool\n"
"1000     17337 16716  1 91362  6916   0 11:07 pts/5    00:00:13 tarantool script."
"lua <running>"
msgstr ""
"$ ps -AF | grep tarantool\n"
"1000     17337 16716  1 91362  6916   0 11:07 pts/5    00:00:13 tarantool script."
"lua <running>"

#: ../book/administration.rst:848
msgid "System-specific administration notes"
msgstr "Заметки по администрированию для разных платформ"

#: ../book/administration.rst:850
#, fuzzy
msgid ""
"This section will contain information about issues or features which exist on "
"some platforms but not others - for example, on certain versions of a particular "
"Linux distribution."
msgstr ""
"В этом разделе приводится информация по проблемам и особенностям, которые "
"относятся только к конкретным платформам. Например, к определенным версиям Linux-"
"систем."

#: ../book/administration.rst:856
msgid "Debian GNU/Linux and Ubuntu"
msgstr "Debian GNU/Linux and Ubuntu"

#: ../book/administration.rst:858
msgid "Setting up an instance:"
msgstr "Настройка конкретного экземпляра Tarantool-сервера:"

#: ../book/administration.rst:860
msgid ""
"$ ln -s /etc/tarantool/instances.available/*instance-name.cfg* /etc/tarantool/"
"instances.enabled/"
msgstr ""
"$ ln -s /etc/tarantool/instances.available/*instance-name.cfg* /etc/tarantool/"
"instances.enabled/"

#: ../book/administration.rst:864
msgid "Starting all instances:"
msgstr "Запуск всех экземпляров:"

#: ../book/administration.rst:866
msgid "$ service tarantool start"
msgstr "$ service tarantool start"

#: ../book/administration.rst:870
msgid "Stopping all instances:"
msgstr "Остановка всех экземпляров:"

#: ../book/administration.rst:872
msgid "$ service tarantool stop"
msgstr "$ service tarantool stop"

#: ../book/administration.rst:876
msgid "Starting/stopping one instance:"
msgstr "Запуск/остановка конкретного экземпляра:"

#: ../book/administration.rst:878
msgid "$ service tarantool-instance-name start/stop"
msgstr "$ service tarantool-instance-name start/stop"

#: ../book/administration.rst:884
msgid "Fedora, RHEL, CentOS"
msgstr "Fedora, RHEL, CentOS"

#: ../book/administration.rst:886
msgid ""
"There are no known permanent issues. For transient issues, go to http://github."
"com/tarantool/tarantool/issues and enter \"RHEL\" or \"CentOS\" or \"Fedora\" or "
"\"Red Hat\" in the search box."
msgstr ""
"Известных воспроизводящихся дефектов для данных платформ нет. Если вы "
"столкнулись с плавающим дефектом, посмотрите описания проблем на странице http://"
"github.com/tarantool/tarantool/issues, введя в строке поиска слово \"RHEL\", "
"\"CentOS\", \"Fedora\" или \"Red Hat\"."

#: ../book/administration.rst:892
msgid "FreeBSD"
msgstr "FreeBSD"

#: ../book/administration.rst:894
msgid ""
"There are no known permanent issues. For transient issues, go to http://github."
"com/tarantool/tarantool/issues and enter \"FreeBSD\" in the search box."
msgstr ""
"Известных воспроизводящихся дефектов для данной платформы нет. Если вы "
"столкнулись с плавающим дефектом, посмотрите описания проблем на странице http://"
"github.com/tarantool/tarantool/issues, введя в строке поиска слово \"FreeBSD\"."

#: ../book/administration.rst:900
msgid "Mac OS X"
msgstr "Mac OS X"

#: ../book/administration.rst:902
msgid ""
"There are no known permanent issues. For transient issues, go to http://github."
"com/tarantool/tarantool/issues and enter \"OS X\" in the search box."
msgstr ""
"Известных воспроизводящихся дефектов для данных платформ нет. Если вы "
"столкнулись с плавающим дефектом, посмотрите описания проблем на странице http://"
"github.com/tarantool/tarantool/issues, введя в строке поиска слово \"OS X\"."

#: ../book/administration.rst:908
msgid "Notes for systemd users"
msgstr "Заметки для пользователей systemd"

#: ../book/administration.rst:910
msgid ""
"Tarantool fully supports :program:`systemd` for managing instances and "
"supervising database daemons."
msgstr ""
"Tarantool полностью поддерживает работу с :program:`systemd` как со средством "
"для управления экземплярами и контроля за фоновыми программами базы данных."

#: ../book/administration.rst:915
msgid "Instance management"
msgstr "Управление экземплярами"

#: ../book/administration.rst:917
msgid ""
"Tarantool was designed to have multiple running instances of Tarantool on the "
"same machine. Use :samp:`systemctl {start|stop|restart|status} tarantool@${MYAPP}"
"` to manage your databases and Lua applications."
msgstr ""
"В архитектуре Tarantool'а заложена возможность запуска сразу многих экземпляров "
"Tarantool-сервера на одной машине. С помощью :samp:`systemctl {start|stop|"
"restart|status} tarantool@${MYAPP}` можно управлять базами данных и Lua-"
"приложениями."

#: ../book/administration.rst:924
msgid "Creating instances"
msgstr "Создание экземпляров"

#: ../book/administration.rst:926
msgid ""
"Simply put your Lua configuration to :file:`/etc/tarantool/instances.available/"
"${MYAPP}.lua`:"
msgstr ""
"Задайте все настройки в виде Lua-скрипта и поместите их в файл :file:`/etc/"
"tarantool/instances.available/${MYAPP}.lua`:"

#: ../book/administration.rst:929
msgid ""
"box.cfg{listen = 3313}\n"
"require('myappcode').start()"
msgstr ""
"box.cfg{listen = 3313}\n"
"require('myappcode').start()"

#: ../book/administration.rst:934
msgid "(this minimal example is sufficient)."
msgstr "(это пример минимально достаточной конфигурации)."

#: ../book/administration.rst:936
msgid ""
"Another starting point could be the :file:`example.lua` script that ships with "
"Tarantool and defines all options."
msgstr ""
"Также вы можете посмотреть пример Lua-скрипт в файле :file:`example.lua`, "
"который входит в состав дистрибутива Tarantool'а и содержит значения всех опций."

#: ../book/administration.rst:941
msgid "Starting instances"
msgstr "Запуск экземпляров"

#: ../book/administration.rst:943
msgid ""
"Use :samp:`systemctl start tarantool@${MYAPP}` to start ``${MYAPP}`` instance:"
msgstr ""
"Для запуска экземпляра ``${MYAPP}`` выполните команду :samp:`systemctl start "
"tarantool@${MYAPP}`:"

#: ../book/administration.rst:945
msgid ""
"$ systemctl start tarantool@example\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 tarantool "
"example.lua <running>"
msgstr ""
"$ systemctl start tarantool@example\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 tarantool "
"example.lua <running>"

#: ../book/administration.rst:951
msgid "(console examples here and further on are for Fedora)."
msgstr "(здесь и далее мы приводим примеры консольного вывода для Fedora)."

#: ../book/administration.rst:953
msgid ""
"Use :samp:`systemctl enable tarantool@${MYAPP}` to enable ``${MYAPP}`` instance "
"for auto-load during system startup."
msgstr ""
"Для автоматической загрузки экземпляра ``${MYAPP}`` во время запуска всей "
"системы используйте команду :samp:`systemctl enable tarantool@${MYAPP}`."

#: ../book/administration.rst:958
msgid "Monitoring instances"
msgstr "Мониторинг экземпляров"

#: ../book/administration.rst:960
msgid ""
"Use :samp:`systemctl status tarantool@${MYAPP}` to check information about ``"
"${MYAPP}`` instance:"
msgstr ""
"Для проверки информации об экземпляре ``${MYAPP}`` выполните команду :samp:"
"`systemctl status tarantool@${MYAPP}`:"

#: ../book/administration.rst:963
msgid ""
"$ systemctl status tarantool@example\n"
"tarantool@example.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor preset: "
"disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, status=0/"
"SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@example.service\n"
"+ 5350 tarantool example.lua <running>"
msgstr ""
"$ systemctl status tarantool@example\n"
"tarantool@example.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor preset: "
"disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, status=0/"
"SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@example.service\n"
"+ 5350 tarantool example.lua <running>"

#: ../book/administration.rst:976
msgid "Use :samp:`journalctl -u tarantool@${MYAPP}` to check the boot log:"
msgstr ""
"Для проверки журнала загрузки выполните команду :samp:`journalctl -u tarantool@"
"${MYAPP}`:"

#: ../book/administration.rst:978
msgid ""
"$ journalctl -u tarantool@example -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:17:47 "
"MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool Database "
"Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool Database "
"Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: "
"Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: "
"Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool Database "
"Server"
msgstr ""
"$ journalctl -u tarantool@example -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:17:47 "
"MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool Database "
"Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool Database "
"Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: "
"Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: "
"Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool Database "
"Server"

#: ../book/administration.rst:990
msgid "Attaching to instances"
msgstr "Подсоединение к экземплярам"

#: ../book/administration.rst:992
msgid ""
"You can attach to a running Tarantool instance and evaluate some Lua code using "
"the :program:`tarantoolctl` utility:"
msgstr ""
"Вы можете подсоединиться к запущенному экземпляру Tarantool-сервера и выполнить "
"некий Lua-скрипт с помощью утилиты :program:`tarantoolctl`:"

#: ../book/administration.rst:995
msgid ""
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/example.control>"
msgstr ""
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/example.control>"

#: ../book/administration.rst:1009
msgid "Checking logs"
msgstr "Проверка журнала"

#: ../book/administration.rst:1011
msgid "Tarantool logs important events to :file:`/var/log/tarantool/${MYAPP}.log`."
msgstr ""
"Tarantool ведет записи о важных событиях в файле :file:`/var/log/tarantool/"
"${MYAPP}.log`."

#: ../book/administration.rst:1013
msgid "Let's write something to the log file:"
msgstr "Давайте запишем что-нибудь в файл журнала:"

#: ../book/administration.rst:1015
msgid ""
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> require('log').info(\"Hello for README."
"systemd readers\")\n"
"---\n"
"..."
msgstr ""
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> require('log').info(\"Hello for README."
"systemd readers\")\n"
"---\n"
"..."

#: ../book/administration.rst:1025
msgid "Then check the logs:"
msgstr "Затем проверим содержимое журнала:"

#: ../book/administration.rst:1027
msgid ""
"$ tail /var/log/tarantool/example.log\n"
"2016-01-21 21:09:45.982 [5914] iproto I> binary: started\n"
"2016-01-21 21:09:45.982 [5914] iproto I> binary: bound to 0.0.0.0:3301\n"
"2016-01-21 21:09:45.983 [5914] main/101/tarantoolctl I> ready to accept "
"requests\n"
"2016-01-21 21:09:45.983 [5914] main/101/example I> Run console at /var/run/"
"tarantool/example.control\n"
"2016-01-21 21:09:45.984 [5914] main/101/example I> tcp_server: remove dead UNIX "
"socket: /var/run/tarantool/example.control\n"
"2016-01-21 21:09:45.984 [5914] main/104/console/unix/:/var/run/tarant I> "
"started\n"
"2016-01-21 21:09:45.985 [5914] main C> entering the event loop\n"
"2016-01-21 21:14:43.320 [5914] main/105/console/unix/: I> client unix/: "
"connected\n"
"2016-01-21 21:15:07.115 [5914] main/105/console/unix/: I> Hello for README."
"systemd readers\n"
"2016-01-21 21:15:09.250 [5914] main/105/console/unix/: I> client unix/: "
"disconnected"
msgstr ""
"$ tail /var/log/tarantool/example.log\n"
"2016-01-21 21:09:45.982 [5914] iproto I> binary: started\n"
"2016-01-21 21:09:45.982 [5914] iproto I> binary: bound to 0.0.0.0:3301\n"
"2016-01-21 21:09:45.983 [5914] main/101/tarantoolctl I> ready to accept "
"requests\n"
"2016-01-21 21:09:45.983 [5914] main/101/example I> Run console at /var/run/"
"tarantool/example.control\n"
"2016-01-21 21:09:45.984 [5914] main/101/example I> tcp_server: remove dead UNIX "
"socket: /var/run/tarantool/example.control\n"
"2016-01-21 21:09:45.984 [5914] main/104/console/unix/:/var/run/tarant I> "
"started\n"
"2016-01-21 21:09:45.985 [5914] main C> entering the event loop\n"
"2016-01-21 21:14:43.320 [5914] main/105/console/unix/: I> client unix/: "
"connected\n"
"2016-01-21 21:15:07.115 [5914] main/105/console/unix/: I> Hello for README."
"systemd readers\n"
"2016-01-21 21:15:09.250 [5914] main/105/console/unix/: I> client unix/: "
"disconnected"

#: ../book/administration.rst:1041
msgid ""
"Log rotation is enabled by default if you have :program:`logrotate` installed. "
"Please configure :file:`/etc/logrotate.d/tarantool` to change the default "
"behavior."
msgstr ""
"Для ротации журнала нужно установить программу :program:`logrotate`. Настройки "
"для ротации можно задать в файле :file:`/etc/logrotate.d/tarantool`."

#: ../book/administration.rst:1047
msgid "Stopping instances"
msgstr "Остановка экземпляров"

#: ../book/administration.rst:1049
msgid ""
"Use :samp:`systemctl stop tarantool@${MYAPP}` to see information about the "
"running ``${MYAPP}`` instance."
msgstr ""
"Для просмотра информации о запущенном экземпляре ``${MYAPP}`` выполните команду :"
"samp:`systemctl stop tarantool@${MYAPP}`."

#: ../book/administration.rst:1052
msgid "$ systemctl stop tarantool@example"
msgstr "$ systemctl stop tarantool@example"

#: ../book/administration.rst:1058
msgid "Daemon supervision"
msgstr "Контроль за фоновыми программами"

#: ../book/administration.rst:1060
msgid ""
"All instances are automatically restarted by :program:`systemd` in case of "
"failure."
msgstr ""
"Если какой-либо экземпляр Tarantool-сервера выходит из строя, :program:`systemd` "
"автоматически перезапускает его."

#: ../book/administration.rst:1062
msgid "Let's try to destroy an instance:"
msgstr "Давайте попробуем вывести из строя один экземпляр:"

#: ../book/administration.rst:1064
msgid ""
"$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host closed "
"connection"
msgstr ""
"$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host closed "
"connection"

#: ../book/administration.rst:1075
msgid ""
"Now let's make sure that :program:`systemd` has revived our Tarantool instance:"
msgstr "А теперь убедимся, что :program:`systemd` перезапустила его:"

#: ../book/administration.rst:1077
msgid ""
"$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5914 (tarantool)"
msgstr ""
"$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5914 (tarantool)"

#: ../book/administration.rst:1082
msgid "Finally, let's check the boot logs:"
msgstr "И под конец проверим содержимое журнала загрузки:"

#: ../book/administration.rst:1084
msgid ""
"$ journalctl -u tarantool@example -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:09:45 "
"MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: "
"Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: "
"Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: "
"Service hold-off time over, scheduling restart.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool Database "
"Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool Database "
"Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: "
"Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: "
"Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool Database "
"Server."
msgstr ""
"$ journalctl -u tarantool@example -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:09:45 "
"MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: "
"Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: "
"Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: "
"Service hold-off time over, scheduling restart.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool Database "
"Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool Database "
"Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: "
"Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: "
"Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool Database "
"Server."

#: ../book/administration.rst:1099
msgid "Customizing the service file"
msgstr "Правка настроек сервисного файла"

#: ../book/administration.rst:1101
msgid ""
"Please don't modify the :file:`tarantool@.service` file in-place, because it "
"will be overwritten during package upgrades. It is recommended to copy this file "
"to :file:`/etc/systemd/system` and then modify the required settings. "
"Alternatively, you can create a directory named :file:`unit.d/` within :file:`/"
"etc/systemd/system` and put there a drop-in file :file:`name.conf` that only "
"changes the required settings. Please see ``systemd.unit(5)`` manual page for "
"additional information."
msgstr ""
"Пожалуйста, не редактируйте файл :file:`tarantool@.service` по месту, поскольку "
"все ваши изменения будут перезаписаны при последующих обновлениях Tarantool'а. "
"Мы рекомендуем скопировать этот файл в :file:`/etc/systemd/system` и править "
"настройки уже в копии. Либо вы можете создать поддиректорию с именем :file:`unit."
"d/` в директории :file:`/etc/systemd/system` и положить туда drop-in файл с "
"именем :file:`name.conf`, в котором будут указаны только те настройки, которые "
"нужно поменять. См. подробности в ``systemd.unit(5)``."

#: ../book/administration.rst:1110
msgid "Debugging"
msgstr "Отладка"

#: ../book/administration.rst:1112
msgid ""
":program:`coredumpctl` automatically saves core dumps and stack traces in case "
"of a crash. Here is how it works:"
msgstr ""
"При аварийном завершении Tarantool-сервера, :program:`coredumpctl` автоматически "
"сохраняет дампы памяти (core dumps) и трассировку стека (stack traces). Вот как "
"работает этот механизм:"

#: ../book/administration.rst:1115
msgid ""
"$ # !!! please never do this on the production system !!!\n"
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> require('ffi').cast('char *', 0)[0] = "
"48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host closed "
"connection"
msgstr ""
"$ # !!! ВНИМАНИЕ: никогда не делайте этого\n"
"  # в условиях промышленной эксплуатации !!!\n"
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> require('ffi').cast('char *', 0)[0] = "
"48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host closed "
"connection"

#: ../book/administration.rst:1125
msgid ""
":samp:`coredumpctl list /usr/bin/tarantool` displays the latest crashes of the "
"Tarantool daemon:"
msgstr ""
"Введем :samp:`coredumpctl list /usr/bin/tarantool`, чтобы получить отчет о "
"последних аварийных завершениях Tarantool-демона:"

#: ../book/administration.rst:1128
msgid ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"
msgstr ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"

#: ../book/administration.rst:1135
msgid ""
":samp:`coredumpctl info <pid>` shows the stack trace and other useful "
"information:"
msgstr ""
"Чтобы получить трассировку стека и прочую полезную информацию, введем :samp:"
"`coredumpctl info <pid>`:"

#: ../book/administration.rst:1137
msgid ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool example.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-tarantool.slice/tarantool@example.service\n"
"         Unit: tarantool@example.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex (tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c "
"_ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."
msgstr ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool example.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-tarantool.slice/tarantool@example.service\n"
"         Unit: tarantool@example.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex (tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c "
"_ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."

#: ../book/administration.rst:1172
msgid ""
":samp:`coredumpctl -o filename.core info <pid>` saves the core dump into a file."
msgstr ""
"Теперь введем :samp:`coredumpctl -o filename.core info <pid>`, чтобы сохранить "
"дамп памяти в отдельный файл."

#: ../book/administration.rst:1174
msgid ":samp:`coredumpctl gdb <pid>` starts :program:`gdb` on the core dump."
msgstr ""
"Далее с помощью команды :samp:`coredumpctl gdb <pid>` запустим отладчик :program:"
"`gdb` и подадим сохраненный дамп памяти ему на вход."

#: ../book/administration.rst:1176
msgid ""
"It is highly recommended to install the ``tarantool-debuginfo`` package to "
"improve :program:`gdb` experience. Example:"
msgstr ""
"Мы очень рекомендуем установить пакет ``tarantool-debuginfo``, чтобы сделать "
"отладку средствами :program:`gdb` более эффективной. Например:"

#: ../book/administration.rst:1179
msgid "$ dnf debuginfo-install tarantool"
msgstr "$ dnf debuginfo-install tarantool"

#: ../book/administration.rst:1186
msgid ""
":program:`gdb` also provides information about the ``debuginfo`` packages you "
"need to install:"
msgstr ""
"С помощью :program:`gdb` вы можете узнать, какие еще ``debuginfo``-пакеты нужно "
"установить:"

#: ../book/administration.rst:1188
msgid ""
"$ # gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"
msgstr ""
"$ # gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"

#: ../book/administration.rst:1199
msgid ""
"Symbol names are present in stack traces even if you don't have the ``tarantool-"
"debuginfo`` package installed."
msgstr ""
"В трассировке стека используются символические имена, даже если у вас не "
"установлен пакет ``tarantool-debuginfo``."

#: ../book/administration.rst:1202
msgid ""
"For additional information, please refer to the documentation provided with your "
"Linux distribution."
msgstr "Дополнительно см. документацию по вашей Linux-системе."

#: ../book/administration.rst:1207
msgid "Precautions"
msgstr "Особые указания"

#: ../book/administration.rst:1209
msgid ""
"Please don't use ``tarantoolctl {start,stop,restart}`` to control instances "
"started by :program:`systemd`. It is still possible to use :program:"
"`tarantoolctl` to start and stop instances from your local directories (e.g. :"
"file:`${HOME}`) without obtaining ``ROOT`` access."
msgstr ""
"Пожалуйста, не используйте ``tarantoolctl {start,stop,restart}`` для управления "
"экземплярами, которые были запущены с помощью :program:`systemd`. Но вы можете "
"использовать :program:`tarantoolctl` для запуска/остановки экземпляров в ваших "
"локальных директориях (например, :file:`${HOME}`), что не требует "
"пользовательских прав уровня ``ROOT``."

#: ../book/administration.rst:1214
msgid ""
":program:`tarantoolctl` is configured to work properly with :program:`systemd`. "
"Please don't modify system-wide settings of :program:`tarantoolctl`, such as "
"paths, directory permissions and usernames. Otherwise, you have a chance to "
"shoot yourself in the foot."
msgstr ""
"Утилита :program:`tarantoolctl` уже настроена так, чтобы корректно работать с :"
"program:`systemd`. Пожалуйста, не меняйте общесистемные настройки для :program:"
"`tarantoolctl`, такие как пути, настройки прав для директорий и имена "
"пользователей, т.к. это может привести к неожиданным проблемам."

#: ../book/administration.rst:1219
msgid ""
":program:`systemd` scripts are maintained by the Tarantool Team (http://"
"tarantool.org). Please file tickets directly to the upstream's bug tracker "
"(https://github.com/tarantool/tarantool/issues/) rather than to your Linux "
"distribution."
msgstr ""
"Поддержкой скриптов для :program:`systemd` занимается команда разработки "
"Tarantool'а (http://tarantool.org). Если у вас возникли проблемы при работе "
"Tarantool'а с :program:`systemd`, то мы просим сообщать об этом нашей команде "
"(https://github.com/tarantool/tarantool/issues/), а не разработчикам вашего "
"Linux-дистрибутива."

#: ../book/app_server.rst:30
msgid "Application server"
msgstr "Сервер приложений"

#: ../book/app_server.rst:36
msgid "About modules/rocks"
msgstr "Про модули/rocks"

#: ../book/app_server.rst:38
msgid ""
"Alongside with using Tarantool as a database manager, you can also use it as an "
"application server. This means that you can write your own logic, install it as "
"a module in Tarantool — and see Tarantool perform your logic. So, a module is an "
"optional library which enhances Tarantool functionality."
msgstr ""

#: ../book/app_server.rst:43
msgid ""
"Tarantool's native language for writing modules is Lua. Modules in Lua are also "
"called \"rocks\". If you are new to Lua, we recommend following this `Lua "
"modules tutorial <http://lua-users.org/wiki/ModulesTutorial>`_ before reading "
"this section."
msgstr ""

#: ../book/app_server.rst:51
msgid "Installing an existing module"
msgstr "Установка существующего модуля"

#: ../book/app_server.rst:53
msgid ""
"Modules that come from Tarantool developers and community contributors are "
"available at `rocks.tarantool.org <http://rocks.tarantool.org>`_. Some of them "
"-- :ref:`expirationd <expirationd-module>`, :ref:`mysql <dbms_modules-mysql-"
"example>`, :ref:`postgresql <dbms_modules-postgresql-example>`, :ref:`shard "
"<shard-module>` -- are discussed elsewhere in this manual."
msgstr ""
"Модули, созданные командой Tarantool'а и членами сообщества разработчиков, "
"выложены на `rocks.tarantool.org <http://rocks.tarantool.org>`_. Про некоторые "
"из этих модулей — :ref:`expirationd <expirationd-module>`, :ref:`mysql "
"<dbms_modules-mysql-example>`, :ref:`postgresql <dbms_modules-postgresql-"
"example>`, :ref:`shard <shard-module>` -- подробнее говорится в других разделах "
"текущей документации."

#: ../book/app_server.rst:61
msgid ""
"**Step 1:** Install LuaRocks. A general description of installing LuaRocks on a "
"Unix system is given in the `LuaRocks Quick Start Guide <http://luarocks.org/"
"#quick-start>`_. For example, on Ubuntu you could say:"
msgstr ""
"**Шаг 1:** Установите LuaRocks. Общее описание того, как установить LuaRocks в "
"Unix-системе, приводится в `кратком руководстве по LuaRocks <http://luarocks.org/"
"#quick-start>`_. Например, установить LuaRocks в Ubuntu можно следующей командой:"

#: ../book/app_server.rst:66
msgid "$ sudo apt-get install luarocks"
msgstr "$ sudo apt-get install luarocks"

#: ../book/app_server.rst:70
msgid ""
"**Step 2:** Add the Tarantool repository to the list of rocks servers. This is "
"done by putting `rocks.tarantool.org <http://rocks.tarantool.org>`_ in the :file:"
"`.luarocks/config.lua` file:"
msgstr ""
"**Шаг 2:** Добавьте репозиторий Tarantool'а в список rocks-серверов. Для этого "
"добавьте `rocks.tarantool.org <http://rocks.tarantool.org>`_ в файл :file:`."
"luarocks/config.lua`:"

#: ../book/app_server.rst:74
msgid ""
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> ~/.luarocks/"
"config.lua"
msgstr ""
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> ~/.luarocks/"
"config.lua"

#: ../book/app_server.rst:79
msgid "Once these steps are complete, you can:"
msgstr "Теперь можно:"

#: ../book/app_server.rst:81
msgid "search the repositories with"
msgstr "искать существующие модули в общем репозитории"

#: ../book/app_server.rst:88
msgid "add new modules to the local repository with"
msgstr "добавлять новые модули в свой локальный репозиторий"

#: ../book/app_server.rst:95
msgid "load any module for Tarantool with"
msgstr "загружать любой модуль для Tarantool'а с помощью ``require``"

#: ../book/app_server.rst:102
msgid ""
"... and that is why examples in this manual often begin with ``require`` "
"requests."
msgstr ""
"(вот почему многие примеры в этой документации начинаются с вызова ``require``.)"

#: ../book/app_server.rst:104
msgid ""
"See `\"tarantool/rocks\" repository at GitHub <https://github.com/tarantool/"
"rocks>`_ for more examples and information about contributing."
msgstr ""
"Далее на странице `репозитория \"tarantool/rocks\" на GitHub <https://github.com/"
"tarantool/rocks>`_ вы можете посмотреть примеры модулей и инструкции по "
"добавлению собственных модулей в общий репозиторий."

#: ../book/app_server.rst:107
msgid ""
"For developers, we provide :ref:`instructions on creating their own Tarantool "
"modules in Lua, C/C++ and Lua+C <develop_modules>`."
msgstr ""

#: ../book/app_server.rst:114
msgid "Creating a new Lua module locally"
msgstr "Создание нового модуля на языке Lua"

#: ../book/app_server.rst:116
msgid ""
"As an example, let's create a new Lua file named :file:`mymodule.lua`, "
"containing a named function which will be exported. Then, in Tarantool: load, "
"examine, and call."
msgstr ""
"Для примера создадим новый Lua-файл с именем :file:`mymodule.lua`, в котором "
"опишем экспортируемую функцию с некоторым именем, а затем с помощью Tarantool'а "
"загрузим и просмотрим наш новый модуль и вызовем описанную в нем функцию."

#: ../book/app_server.rst:120
msgid "The Lua file should look like this:"
msgstr "Lua-файл в нашем примере будет таким:"

#: ../book/app_server.rst:122
msgid ""
"-- mymodule - a simple Tarantool module\n"
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"    print('Hello', input_string)\n"
"end\n"
"return exports"
msgstr ""
"-- mymodule - простейший Lua-модуль для Tarantool'а\n"
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"    print('Hello', input_string)\n"
"end\n"
"return exports"

#: ../book/app_server.rst:131 ../book/app_server.rst:210
msgid "The requests to load, examine and call look like this:"
msgstr ""
"Для загрузки и просмотра модуля, а также вызова описанной в нем функции, "
"выполним следующие команды:"

#: ../book/app_server.rst:136
msgid ""
"tarantool> **mymodule = require('mymodule')**\n"
"---\n"
"...\n"
"\n"
"tarantool> **mymodule**\n"
"---\n"
"- myfun: 'function: 0x405edf20'\n"
"...\n"
"\n"
"tarantool> **mymodule.myfun(os.getenv('USER'))**\n"
"Hello world\n"
"---\n"
"..."
msgstr ""
"tarantool> **mymodule = require('mymodule')**\n"
"---\n"
"...\n"
"\n"
"tarantool> **mymodule**\n"
"---\n"
"- myfun: 'function: 0x405edf20'\n"
"...\n"
"\n"
"tarantool> **mymodule.myfun(os.getenv('USER'))**\n"
"Hello world\n"
"---\n"
"..."

#: ../book/app_server.rst:154
msgid "Creating a new C/C++ module locally"
msgstr "Создание нового модуля на языке C/C++"

#: ../book/app_server.rst:156
msgid ""
"As an example, let's create a new C file named :file:`mycmodule.c`, containing a "
"named function which will be exported. Then, in Tarantool: load, examine, and "
"call."
msgstr ""
"Для примера создадим новый C-файл с именем :file:`mymodule.c`, в котором опишем "
"экспортируемую функцию с некоторым именем, а затем с помощью Tarantool'а "
"загрузим и просмотрим наш новый модуль и вызовем описанную в нем функцию."

#: ../book/app_server.rst:160
msgid "Prerequisite: install ``tarantool-dev`` first."
msgstr ""
"Обратите внимание, что для корректной работы требуется заранее установить модуль "
"``tarantool-dev``."

#: ../book/app_server.rst:162
msgid "The C file should look like this:"
msgstr "C-файл в нашем примере будет таким:"

#: ../book/app_server.rst:164
#, python-format
msgid ""
"/* mycmodule - a simple Tarantool module */\n"
"#include <lua.h>\n"
"#include <lauxlib.h>\n"
"#include <lualib.h>\n"
"#include <tarantool.h>\n"
"static int\n"
"myfun(lua_State *L)\n"
"{\n"
"    if (lua_gettop(L) < 1)\n"
"        return luaL_error(L, \"Usage: myfun(name)\");\n"
"\n"
"    /* Get first argument */\n"
"    const char *name = lua_tostring(L, 1);\n"
"\n"
"    /* Push one result to Lua stack */\n"
"    lua_pushfstring(L, \"Hello, %s\", name);\n"
"    return 1; /* the function returns one result */\n"
"}\n"
"\n"
"LUA_API int\n"
"luaopen_mycmodule(lua_State *L)\n"
"{\n"
"    static const struct luaL_reg reg[] = {\n"
"        { \"myfun\", myfun },\n"
"        { NULL, NULL }\n"
"    };\n"
"    luaL_register(L, \"mycmodule\", reg);\n"
"    return 1;\n"
"}"
msgstr ""
"/* mycmodule - простейший C-модуль для Tarantool'а */\n"
"#include <lua.h>\n"
"#include <lauxlib.h>\n"
"#include <lualib.h>\n"
"#include <tarantool.h>\n"
"static int\n"
"myfun(lua_State *L)\n"
"{\n"
"    if (lua_gettop(L) < 1)\n"
"        return luaL_error(L, \"Usage: myfun(name)\");\n"
"\n"
"    /* Get first argument */\n"
"    const char *name = lua_tostring(L, 1);\n"
"\n"
"    /* Push one result to Lua stack */\n"
"    lua_pushfstring(L, \"Hello, %s\", name);\n"
"    return 1; /* the function returns one result */\n"
"}\n"
"\n"
"LUA_API int\n"
"luaopen_mycmodule(lua_State *L)\n"
"{\n"
"    static const struct luaL_reg reg[] = {\n"
"        { \"myfun\", myfun },\n"
"        { NULL, NULL }\n"
"    };\n"
"    luaL_register(L, \"mycmodule\", reg);\n"
"    return 1;\n"
"}"

#: ../book/app_server.rst:196
msgid ""
"Use :program:`gcc` to compile the code for a shared library (without a \"lib\" "
"prefix), then use :program:`ls` to examine it:"
msgstr ""
"С помощью :program:`gcc` скомпилируем наш код в виде shared-библиотеки (без "
"префикса \"lib\"), а затем просмотрим ее содержимое с помощью :program:`ls`:"

#: ../book/app_server.rst:202
msgid ""
"$ **gcc mycmodule.c -shared -fPIC -I/usr/include/tarantool -o mycmodule.so**\n"
"$ **ls mycmodule.so -l**\n"
"-rwxr-xr-x 1 roman roman 7272 Jun  3 16:51 mycmodule.so"
msgstr ""
"$ **gcc mycmodule.c -shared -fPIC -I/usr/include/tarantool -o mycmodule.so**\n"
"$ **ls mycmodule.so -l**\n"
"-rwxr-xr-x 1 roman roman 7272 Jun  3 16:51 mycmodule.so"

#: ../book/app_server.rst:206
msgid ""
"Tarantool's developers recommend using Tarantool's `CMake scripts <https://"
"github.com/tarantool/modulekit>`_ which will handle some of the build steps "
"automatically."
msgstr ""
"Для автоматизации сборки рекомендуется использовать `CMake-скрипты для "
"Tarantool'а <https://github.com/tarantool/modulekit>`_."

#: ../book/app_server.rst:215
msgid ""
"tarantool> **myсmodule = require('myсmodule')**\n"
"---\n"
"...\n"
"tarantool> **myсmodule**\n"
"---\n"
"- myfun: 'function: 0x4100ec98'\n"
"...\n"
"tarantool> **mycmodule.myfun(os.getenv('USER'))**\n"
"---\n"
"- Hello, world\n"
"..."
msgstr ""
"tarantool> **myсmodule = require('myсmodule')**\n"
"---\n"
"...\n"
"tarantool> **myсmodule**\n"
"---\n"
"- myfun: 'function: 0x4100ec98'\n"
"...\n"
"tarantool> **mycmodule.myfun(os.getenv('USER'))**\n"
"---\n"
"- Hello, world\n"
"..."

#: ../book/app_server.rst:227
msgid ""
"You can also create modules with C++, provided that the code does not throw "
"exceptions."
msgstr ""
"Вы можете аналогичным образом создавать модули на C++ при условии, что в их коде "
"не будут выбрасываться исключения."

#: ../book/app_server.rst:232
msgid "Creating a mixed Lua/C module locally"
msgstr "Создание нового модуля на смеси языков Lua/C"

#: ../book/app_server.rst:234
msgid "Create a Lua module and name it as you like, say ``myfunmodule``."
msgstr "Создайте новый Lua-модуль и назовите его, например, ``myfunmodule``."

#: ../book/app_server.rst:236
msgid ""
"Create a C module (submodule) and name it ``myfunmodule.internal`` or something "
"like that."
msgstr ""
"Создайте (вложенный) модуль на C и назовите его, например, ``myfunmodule."
"internal``."

#: ../book/app_server.rst:239
msgid ""
"Load the C module from your Lua code using :samp:`require('myfunmodule."
"internal')` and then wrap or use it."
msgstr ""
"Загрузите новый C-модуль из Lua-кода с помощью :samp:`require('myfunmodule."
"internal')`, а затем сделайте для него обертку или вызывайте его функции "
"напрямую."

#: ../book/app_server.rst:242
msgid ""
"For a sample of a mixed Lua/C module, see `\"tarantool/http\" repository at "
"GitHub <https://github.com/tarantool/http>`_."
msgstr ""
"Примеры модулей на смеси языков Lua/C можно посмотреть в `репозитории "
"\"tarantool/http\" на GitHub <https://github.com/tarantool/http>`_."

#: ../book/app_server.rst:247
msgid "Tips for special situations"
msgstr "Примечания для особых случаев"

#: ../book/app_server.rst:249
msgid ""
"Lua caches all loaded modules in the ``package.loaded`` table. To reload a "
"module from disk, set its key to `nil`:"
msgstr ""
"В среде Lua все загруженные модули кешируются в таблице ``package.loaded``. "
"Чтобы перегрузить какой-либо модуль с диска, укажите для его ключа значение "
"`nil`:"

#: ../book/app_server.rst:257
msgid ""
"Use ``package.path`` to search for :file:`.lua` modules, and use ``package."
"cpath`` to search for C binary modules."
msgstr ""
"Для поиска :file:`.lua`-модулей используйте команду ``package.path``, а для "
"поиска бинарных модулей на C используйте команду ``package.cpath``."

#: ../book/app_server.rst:278
msgid ""
"Question-marks stand for the module name that was specified earlier when saying :"
"extsamp:`require('{*{modulename}*}')`."
msgstr ""
"Знаки вопроса стоят вместо имени модуля, которое было указано ранее при вызове :"
"extsamp:`require('{*{имя_модуля}*}')`."

#: ../book/app_server.rst:281
msgid ""
"To see the internal state from within a Lua module, use :samp:`state` and create "
"a local variable inside the scope of the file:"
msgstr ""
"Для просмотра внутреннего состояния прямо изнутри Lua-модуля используйте :samp:"
"`state` и соответствующую локальную переменную в рамках модуля:"

#: ../book/app_server.rst:284
msgid ""
"-- mymodule\n"
"local exports = {}\n"
"local state = {}\n"
"exports.myfun = function()\n"
"    state.x = 42 -- use state\n"
"end\n"
"return exports"
msgstr ""
"-- mymodule\n"
"local exports = {}\n"
"local state = {}\n"
"exports.myfun = function()\n"
"    state.x = 42 -- используем state\n"
"end\n"
"return exports"

#: ../book/app_server.rst:294
msgid ""
"Notice that Lua examples in this manual use *local* variables. Use *global* "
"variables with caution, since the module's users may be unaware of them."
msgstr ""
"Обратите внимание, что в текущей документации в примерах Lua-кода используются "
"*локальные* переменные. Будьте аккуратны, если в своих модулях вы будете "
"использовать *глобальные* переменные, поскольку пользователи ваших модулей могут "
"не знать об этих переменных."

#: ../book/app_server.rst:300
msgid "Cookbook recipes"
msgstr "Книга рецептов"

#: ../book/cookbook.rst:3
msgid ""
"Here are contributions of Lua programs for some frequent or tricky situations."
msgstr ""

#: ../book/cookbook.rst:5
msgid ""
"Any of the programs can be executed by copying the code into a .lua file, and "
"then entering :samp:`chmod +x ./{program-name}.lua` and :samp:`./{program-name}."
"lua` on the terminal. As is usual for Tarantool/Lua programs, the first line is "
"a \"hashbang\" |br| #!/usr/bin/env tarantool |br| This runs the Tarantool Lua "
"application server, which should be on the execution path."
msgstr ""

#: ../book/cookbook.rst:13
msgid "Use freely."
msgstr ""

#: ../book/cookbook.rst:17
msgid "**hello_world.lua**"
msgstr ""

#: ../book/cookbook.rst:19
msgid "The standard example of a simple program."
msgstr ""

#: ../book/cookbook.rst:21
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"print('Hello, World!')"
msgstr ""

#: ../book/cookbook.rst:29
msgid "**console_start.lua**"
msgstr ""

#: ../book/cookbook.rst:31
msgid ""
"Use :ref:`box.once() <box-once>` to initialize a database (creating spaces) if "
"this is the first time the server has been run. Then use :ref:`console.start() "
"<console-start>` to start interactive mode."
msgstr ""

#: ../book/cookbook.rst:35
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- Configure database\n"
"box.cfg {\n"
"    listen = 3313\n"
"}\n"
"\n"
"box.once(\"bootstrap\", function()\n"
"    box.schema.space.create('tweedledum')\n"
"    box.space.tweedledum:create_index('primary',\n"
"        { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)\n"
"\n"
"require('console').start()"
msgstr ""

#: ../book/cookbook.rst:54
msgid "**fio_read.lua**"
msgstr ""

#: ../book/cookbook.rst:56
msgid "Use the :ref:`fio module <fio-module>` to open, read, and close a file."
msgstr ""

#: ../book/cookbook.rst:58
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""

#: ../book/cookbook.rst:74
msgid "**fio_write.lua**"
msgstr ""

#: ../book/cookbook.rst:76
msgid "Use the :ref:`fio module <fio-module>` to open, write, and close a file."
msgstr ""

#: ../book/cookbook.rst:78
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_CREAT', 'O_WRONLY', 'O_APPEND'},\n"
"    tonumber('0666', 8))\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"f:write(\"Hello\\n\");\n"
"f:close()"
msgstr ""

#: ../book/cookbook.rst:94
msgid "**ffi_printf.lua**"
msgstr ""

#: ../book/cookbook.rst:96
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C built-"
"in function: printf(). (For help understanding ffi, see the `FFI tutorial "
"<http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../book/cookbook.rst:99
#, python-format
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    int printf(const char *format, ...);\n"
"]]\n"
"\n"
"ffi.C.printf(\"Hello, %s\\n\", os.getenv(\"USER\"));"
msgstr ""

#: ../book/cookbook.rst:112
msgid "**ffi_gettimeofday.lua**"
msgstr ""

#: ../book/cookbook.rst:114
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C "
"function: gettimeofday(). This delivers time with millisecond precision, unlike "
"the time function in Tarantool's :ref:`clock module <clock-module>`."
msgstr ""

#: ../book/cookbook.rst:118
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    typedef long time_t;\n"
"    typedef struct timeval {\n"
"    time_t tv_sec;\n"
"    time_t tv_usec;\n"
"} timeval;\n"
"    int gettimeofday(struct timeval *t, void *tzp);\n"
"]]\n"
"\n"
"local timeval_buf = ffi.new(\"timeval\")\n"
"local now = function()\n"
"    ffi.C.gettimeofday(timeval_buf, nil)\n"
"    return tonumber(timeval_buf.tv_sec * 1000 + (timeval_buf.tv_usec / 1000))\n"
"end"
msgstr ""

#: ../book/cookbook.rst:140
msgid "**ffi_zlib.lua**"
msgstr ""

#: ../book/cookbook.rst:142
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C "
"library function. (For help understanding ffi, see the `FFI tutorial <http://"
"luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../book/cookbook.rst:145
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"    unsigned long compressBound(unsigned long sourceLen);\n"
"    int compress2(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen, int level);\n"
"    int uncompress(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen);\n"
"]]\n"
"local zlib = ffi.load(ffi.os == \"Windows\" and \"zlib1\" or \"z\")\n"
"\n"
"-- Lua wrapper for compress2()\n"
"local function compress(txt)\n"
"    local n = zlib.compressBound(#txt)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.compress2(buf, buflen, txt, #txt, 9)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Lua wrapper for uncompress\n"
"local function uncompress(comp, n)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.uncompress(buf, buflen, comp, #comp)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Simple test code.\n"
"local txt = string.rep(\"abcd\", 1000)\n"
"print(\"Uncompressed size: \", #txt)\n"
"local c = compress(txt)\n"
"print(\"Compressed size: \", #c)\n"
"local txt2 = uncompress(c, #txt)\n"
"assert(txt2 == txt)"
msgstr ""

#: ../book/cookbook.rst:188
msgid "**ffi_meta.lua**"
msgstr ""

#: ../book/cookbook.rst:190
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to access a C "
"object via a metamethod (a method which is defined with a metatable)."
msgstr ""

#: ../book/cookbook.rst:194
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"typedef struct { double x, y; } point_t;\n"
"]]\n"
"\n"
"local point\n"
"local mt = {\n"
"  __add = function(a, b) return point(a.x+b.x, a.y+b.y) end,\n"
"  __len = function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,\n"
"  __index = {\n"
"    area = function(a) return a.x*a.x + a.y*a.y end,\n"
"  },\n"
"}\n"
"point = ffi.metatype(\"point_t\", mt)\n"
"\n"
"local a = point(3, 4)\n"
"print(a.x, a.y)  --> 3  4\n"
"print(#a)        --> 5\n"
"print(a:area())  --> 25\n"
"local b = a + point(0.5, 8)\n"
"print(#b)        --> 12.5"
msgstr ""

#: ../book/cookbook.rst:222
msgid "**print_arrays.lua**"
msgstr ""

#: ../book/cookbook.rst:224
msgid ""
"Create Lua tables, and print them. Notice that for the 'array' table the "
"iterator function is ipairs(), while for the 'map' table the iterator function "
"is pairs(). (`ipairs()` is faster than `pairs()`, but pairs() is recommended for "
"map-like tables or mixed tables.) The display will look like: \"1 Apple | 2 "
"Orange | 3 Grapefruit | 4 Banana | k3 v3 | k1 v1 | k2 v2\"."
msgstr ""

#: ../book/cookbook.rst:232
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"for k, v in ipairs(array) do print(k, v) end\n"
"\n"
"map = { k1 = 'v1', k2 = 'v2', k3 = 'v3' }\n"
"for k, v in pairs(map) do print(k, v) end"
msgstr ""

#: ../book/cookbook.rst:244
msgid "**count_array.lua**"
msgstr ""

#: ../book/cookbook.rst:246
msgid ""
"Use the '#' operator to get the number of items in an array-like Lua table. This "
"operation has O(log(N)) complexity."
msgstr ""

#: ../book/cookbook.rst:249
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 1, 2, 3}\n"
"print(#array)"
msgstr ""

#: ../book/cookbook.rst:258
msgid "**count_array_with_nils.lua**"
msgstr ""

#: ../book/cookbook.rst:260
msgid ""
"Missing elements in arrays, which Lua treats a \"nil\"s, cause the simple \"#\" "
"operator to deliver improper results. The \"print(#t)\" instruction will print "
"\"4\"; the \"print(counter)\" instruction will print \"3\"; the \"print(max)\" "
"instruction will print \"10\". Other table functions, such as table.sort(), will "
"also misbehave when \"nils\" are present."
msgstr ""

#: ../book/cookbook.rst:268
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local t = {}\n"
"t[1] = 1\n"
"t[4] = 4\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../book/cookbook.rst:286
msgid "**count_array_with_nulls.lua**"
msgstr ""

#: ../book/cookbook.rst:288
msgid ""
"Use explicit ``NULL`` values to avoid the problems caused by Lua's nil == "
"missing value behavior. Although :code:`json.NULL == nil` is :code:`true`, all "
"the print instructions in this program will print the correct value: 10."
msgstr ""

#: ../book/cookbook.rst:293
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local json = require('json')\n"
"local t = {}\n"
"t[1] = 1; t[2] = json.NULL; t[3]= json.NULL;\n"
"t[4] = 4; t[5] = json.NULL; t[6]= json.NULL;\n"
"t[6] = 4; t[7] = json.NULL; t[8]= json.NULL;\n"
"t[9] = json.NULL\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../book/cookbook.rst:314
msgid "**count_map.lua**"
msgstr ""

#: ../book/cookbook.rst:316
msgid "Get the number of elements in a map-like table."
msgstr ""

#: ../book/cookbook.rst:318
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local map = { a = 10, b = 15, c = 20 }\n"
"local size = 0\n"
"for _ in pairs(map) do size = size + 1; end\n"
"print(size)"
msgstr ""

#: ../book/cookbook.rst:329
msgid "**swap.lua**"
msgstr ""

#: ../book/cookbook.rst:331
msgid ""
"Use a Lua peculiarity to swap two variables without needing a third variable."
msgstr ""

#: ../book/cookbook.rst:333
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local x = 1\n"
"local y = 2\n"
"x, y = y, x\n"
"print(x, y)"
msgstr ""

#: ../book/cookbook.rst:344
msgid "**uri.lua**"
msgstr ""

#: ../book/cookbook.rst:346
msgid ""
"Use built-in function :code:`uri_parse` to see what is in a `URI <configuration-"
"uri>`:"
msgstr ""

#: ../book/cookbook.rst:348
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local uri = require('uri')\n"
"local r= uri.parse(\"scheme://login:password@host:service:/path1/path2/path3?"
"q1=v1&q2=v2#fragment\")\n"
"print('r.password=',r.password)\n"
"print('r.path=',r.path)\n"
"print('r.scheme',r.scheme)\n"
"print('r.login=',r.login)\n"
"print('r.query=',r.query)\n"
"print('r.service=',r.service)\n"
"print('r.fragment=',r.fragment)\n"
"print('r.host=',r.host)"
msgstr ""

#: ../book/cookbook.rst:365
msgid "**class.lua**"
msgstr ""

#: ../book/cookbook.rst:367
msgid ""
"Create a class, create a metatable for the class, create an instance of the "
"class. Another illustration is at `http://lua-users.org/wiki/"
"LuaClassesWithMetatable <http://lua-users.org/wiki/LuaClassesWithMetatable>`_."
msgstr ""

#: ../book/cookbook.rst:371
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- define class objects\n"
"local myclass_somemethod = function(self)\n"
"    print('test 1', self.data)\n"
"end\n"
"\n"
"local myclass_someothermethod = function(self)\n"
"    print('test 2', self.data)\n"
"end\n"
"\n"
"local myclass_tostring = function(self)\n"
"    return 'MyClass <'..self.data..'>'\n"
"end\n"
"\n"
"local myclass_mt = {\n"
"    __tostring = myclass_tostring;\n"
"    __index = {\n"
"        somemethod = myclass_somemethod;\n"
"        someothermethod = myclass_someothermethod;\n"
"    }\n"
"}\n"
"\n"
"-- create a new object of myclass\n"
"local object = setmetatable({ data = 'data'}, myclass_mt)\n"
"print(object:somemethod())\n"
"print(object.data)"
msgstr ""

#: ../book/cookbook.rst:403
msgid "**garbage.lua**"
msgstr ""

#: ../book/cookbook.rst:405
msgid ""
"Force Lua `garbage collection <https://www.lua.org/manual/5.1/manual."
"html#2.10>`_ with the `collectgarbage function <https://www.lua.org/manual/5.1/"
"manual.html#pdf-collectgarbage>`_."
msgstr ""

#: ../book/cookbook.rst:408
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"collectgarbage('collect')"
msgstr ""

#: ../book/cookbook.rst:416
msgid "**fiber_producer_and_consumer.lua**"
msgstr ""

#: ../book/cookbook.rst:418
msgid ""
"Start one fiber for producer and one fiber for consumer. Use :ref:`fiber."
"channel() <fiber_ipc-channel>` to exchange data and synchronize. One can tweak "
"the channel size (:code:`ch_size` in the program code) to control the number of "
"simultaneous tasks waiting for processing."
msgstr ""

#: ../book/cookbook.rst:423
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fiber = require('fiber')\n"
"local function consumer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = ch:get()\n"
"        if data == nil then\n"
"            break\n"
"        end\n"
"        print('consumed', i, data)\n"
"        fiber.sleep(math.random()) -- simulate some work\n"
"    end\n"
"end\n"
"\n"
"local function producer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = math.random()\n"
"        ch:put(data)\n"
"        print('produced', i, data)\n"
"    end\n"
"end\n"
"\n"
"local function start()\n"
"    local consumer_n = 5\n"
"    local producer_n = 3\n"
"\n"
"    -- Create a channel\n"
"    local ch_size = math.max(consumer_n, producer_n)\n"
"    local ch = fiber.channel(ch_size)\n"
"\n"
"    -- Start consumers\n"
"    for i=1, consumer_n,1 do\n"
"        fiber.create(consumer_loop, ch, i)\n"
"    end\n"
"\n"
"    -- Start producers\n"
"    for i=1, producer_n,1 do\n"
"        fiber.create(producer_loop, ch, i)\n"
"    end\n"
"end\n"
"\n"
"start()\n"
"print('started')"
msgstr ""

#: ../book/cookbook.rst:475
msgid "**socket_tcpconnect.lua**"
msgstr ""

#: ../book/cookbook.rst:477
msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to connect to a remote host "
"via TCP. Display the connection details and the result of a GET request."
msgstr ""

#: ../book/cookbook.rst:481
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').tcp_connect('google.com', 80)\n"
"print(s:peer().host)\n"
"print(s:peer().family)\n"
"print(s:peer().type)\n"
"print(s:peer().protocol)\n"
"print(s:peer().port)\n"
"print(s:write(\"GET / HTTP/1.0\\r\\n\\r\\n\"))\n"
"print(s:read('\\r\\n'))\n"
"print(s:read('\\r\\n'))"
msgstr ""

#: ../book/cookbook.rst:497
msgid "**socket_tcp_echo.lua**"
msgstr ""

#: ../book/cookbook.rst:499
msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to set up a simple TCP "
"server, by creating a function that handles requests and echos them, and passing "
"the function to :ref:`socket.tcp_server() <socket-tcp_server>`. This program has "
"been used to test with 100,000 clients, with each client getting a separate "
"fiber."
msgstr ""

#: ../book/cookbook.rst:507
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(s, peer)\n"
"    s:write(\"Welcome to test server, \" .. peer.host ..\"\\n\")\n"
"    while true do\n"
"        local line = s:read('\\n')\n"
"        if line == nil then\n"
"            break -- error or eof\n"
"        end\n"
"        if not s:write(\"pong: \"..line) then\n"
"            break -- error or eof\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local server, addr = require('socket').tcp_server('localhost', 3311, handler)"
msgstr ""

#: ../book/cookbook.rst:528
msgid "**getaddrinfo.lua**"
msgstr ""

#: ../book/cookbook.rst:530
msgid ""
"Use :ref:`socket.getaddrinfo() <socket-getaddrinfo>` to perform non-blocking DNS "
"resolution, getting both the AF_INET6 and AF_INET information for 'google.com'. "
"This technique is not always necessary for tcp connections because :ref:`socket."
"tcp_connect() <socket-tcp_connect>` performs `socket.getaddrinfo` under the "
"hood, before trying to connect to the first available address."
msgstr ""

#: ../book/cookbook.rst:538
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').getaddrinfo('google.com', 'http', { type = "
"'SOCK_STREAM' })\n"
"print('host=',s[1].host)\n"
"print('family=',s[1].family)\n"
"print('type=',s[1].type)\n"
"print('protocol=',s[1].protocol)\n"
"print('port=',s[1].port)\n"
"print('host=',s[2].host)\n"
"print('family=',s[2].family)\n"
"print('type=',s[2].type)\n"
"print('protocol=',s[2].protocol)\n"
"print('port=',s[2].port)"
msgstr ""

#: ../book/cookbook.rst:556
msgid "**socket_udp_echo.lua**"
msgstr ""

#: ../book/cookbook.rst:558
msgid ""
"Tarantool does not currently have a `udp_server` function, therefore "
"socket_udp_echo.lua is more complicated than socket_tcp_echo.lua. It can be "
"implemented with sockets and fibers."
msgstr ""

#: ../book/cookbook.rst:563
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local socket = require('socket')\n"
"local errno = require('errno')\n"
"local fiber = require('fiber')\n"
"\n"
"local function udp_server_loop(s, handler)\n"
"    fiber.name(\"udp_server\")\n"
"    while true do\n"
"        -- try to read a datagram first\n"
"        local msg, peer = s:recvfrom()\n"
"        if msg == \"\" then\n"
"            -- socket was closed via s:close()\n"
"            break\n"
"        elseif msg ~= nil then\n"
"            -- got a new datagram\n"
"            handler(s, peer, msg)\n"
"        else\n"
"            if s:errno() == errno.EAGAIN or s:errno() == errno.EINTR then\n"
"                -- socket is not ready\n"
"                s:readable() -- yield, epoll will wake us when new data arrives\n"
"            else\n"
"                -- socket error\n"
"                local msg = s:error()\n"
"                s:close() -- save resources and don't wait GC\n"
"                error(\"Socket error: \" .. msg)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function udp_server(host, port, handler)\n"
"    local s = socket('AF_INET', 'SOCK_DGRAM', 0)\n"
"    if not s then\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"    if not s:bind(host, port) then\n"
"        local e = s:errno() -- save errno\n"
"        s:close()\n"
"        errno(e) -- restore errno\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"\n"
"    fiber.create(udp_server_loop, s, handler) -- start a new background fiber\n"
"    return s\n"
"end"
msgstr ""

#: ../book/cookbook.rst:612
msgid ""
"A function for a client that connects to this server could look something like "
"this ..."
msgstr ""

#: ../book/cookbook.rst:615
msgid ""
"local function handler(s, peer, msg)\n"
"    -- You don't have to wait until socket is ready to send UDP\n"
"    -- s:writable()\n"
"    s:sendto(peer.host, peer.port, \"Pong: \" .. msg)\n"
"end\n"
"\n"
"local server = udp_server('127.0.0.1', 3548, handler)\n"
"if not server then\n"
"    error('Failed to bind: ' .. errno.strerror())\n"
"end\n"
"\n"
"print('Started')\n"
"\n"
"require('console').start()"
msgstr ""

#: ../book/cookbook.rst:634
msgid "**http_get.lua**"
msgstr ""

#: ../book/cookbook.rst:636
msgid ""
"Use the `http`_ `rock`_ (which must first be installed) to get data via HTTP."
msgstr ""

#: ../book/cookbook.rst:639
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local r = http_client.get('http://api.openweathermap.org/data/2.5/weather?"
"q=Oakland,us')\n"
"if r.status ~= 200 then\n"
"    print('Failed to get weather forecast ', r.reason)\n"
"    return\n"
"end\n"
"local data = json.decode(r.body)\n"
"print('Oakland wind speed: ', data.wind.speed)"
msgstr ""

#: ../book/cookbook.rst:655
msgid "**http_send.lua**"
msgstr ""

#: ../book/cookbook.rst:657
msgid ""
"Use the `http`_ `rock`_ (which must first be installed) to send data via HTTP."
msgstr ""

#: ../book/cookbook.rst:660
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local data = json.encode({ Key = 'Value'})\n"
"local headers = { Token = 'xxxx', ['X-Secret-Value'] = 42 }\n"
"local r = http_client.post('http://localhost:8081', data, { headers = headers})\n"
"if r.status == 200 then\n"
"    print 'Success'\n"
"end"
msgstr ""

#: ../book/cookbook.rst:675
msgid "**http_server.lua**"
msgstr ""

#: ../book/cookbook.rst:677
msgid ""
"Use the `http`_ `rock`_ (which must first be installed) to turn Tarantool into a "
"web server."
msgstr ""

#: ../book/cookbook.rst:680
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"    return self:render{ json = { ['Your-IP-Is'] = self.peer.host } }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- listen *:8080\n"
"server:route({ path = '/' }, handler)\n"
"server:start()\n"
"-- connect to localhost:8080 and see json"
msgstr ""

#: ../book/cookbook.rst:695
msgid "**http_generate_html.lua**"
msgstr ""

#: ../book/cookbook.rst:697
msgid ""
"Use the `http`_ `rock` (which must first be installed) to generate HTML pages "
"from templates. The `http`_ `rock`_ has a fairly simple template engine which "
"allows execution of regular Lua code inside text blocks (like PHP). Therefore "
"there is no need to learn new languages in order to write templates."
msgstr ""

#: ../book/cookbook.rst:703
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"local fruits = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"    return self:render{ fruits = fruits }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- nil means '*'\n"
"server:route({ path = '/', file = 'index.html.lua' }, handler)\n"
"server:start()"
msgstr ""

#: ../book/cookbook.rst:716
msgid ""
"An \"HTML\" file for this server, including Lua, could look like this (it would "
"produce \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana\")."
msgstr ""

#: ../book/cookbook.rst:719
#, python-format
msgid ""
"<html>\n"
"<body>\n"
"    <table border=\"1\">\n"
"        % for i,v in pairs(fruits) do\n"
"        <tr>\n"
"            <td><%= i %></td>\n"
"            <td><%= v %></td>\n"
"        </tr>\n"
"        % end\n"
"    </table>\n"
"</body>\n"
"</html>"
msgstr ""

#: ../book/box/box_index.rst:30
msgid "Submodule `box.index`"
msgstr "Вложенный модуль `box.index`"

#: ../book/box/box_index.rst:32
msgid ""
"The ``box.index`` submodule provides read-only access for index definitions and "
"index keys. Indexes are contained in :samp:`box.space.{space-name}.index` array "
"within each space object. They provide an API for ordered iteration over tuples. "
"This API is a direct binding to corresponding methods of index objects of type "
"``box.index`` in the storage engine."
msgstr ""

#: ../book/box/box_index.rst:44
msgid "True if the index is unique, false if the index is not unique."
msgstr ""

#: ../book/box/box_index.rst:46 ../book/box/box_index.rst:56
#: ../book/box/box_index.rst:64 ../book/box/box_index.rst:114
#: ../book/box/box_index.rst:431 ../book/box/box_index.rst:594
#: ../book/box/box_index.rst:623 ../book/box/box_index.rst:654
#: ../book/box/box_index.rst:682 ../book/box/box_index.rst:715
#: ../book/box/box_index.rst:734 ../book/box/box_index.rst:751
#: ../book/box/box_index.rst:778 ../book/box/box_index.rst:799
#: ../book/box/box_index.rst:822
msgid "Parameters:"
msgstr ""

#: ../book/box/box_index.rst:48 ../book/box/box_index.rst:58
#: ../book/box/box_index.rst:66 ../book/box/box_index.rst:780
#: ../book/box/box_index.rst:824
msgid ""
":samp:`{index_object}` = an :ref:`object reference <index-object_reference>`."
msgstr ""

#: ../book/box/box_index.rst:50 ../book/box/box_schema.rst:62
#: ../book/box/box_schema.rst:68 ../book/box/box_space.rst:174
#: ../book/box/box_space.rst:176 ../book/box/index.rst:165
msgid "boolean"
msgstr ""

#: ../book/box/box_index.rst:54
msgid "Index type, 'TREE' or 'HASH' or 'BITSET' or 'RTREE'."
msgstr ""

#: ../book/box/box_index.rst:62
msgid "An array describing index key fields."
msgstr ""

#: ../book/box/box_index.rst:72
msgid ""
"tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:90
msgid ""
"This method provides iteration support within an index. The :codeitalic:`bitset-"
"value` or :codeitalic:`search-value` parameter specifies what must match within "
"the index. The :codeitalic:`iterator-type` parameter specifies the rule for "
"matching and ordering. Different index types support different iterators. For "
"example, a TREE index maintains a strict order of keys and can return all tuples "
"in ascending or descending order, starting from the specified key. Other index "
"types, however, do not support ordering."
msgstr ""

#: ../book/box/box_index.rst:100
msgid ""
"To understand consistency of tuples returned by an iterator, it's essential to "
"know the principles of the Tarantool transaction processing subsystem. An "
"iterator in Tarantool does not own a consistent read view. Instead, each "
"procedure is granted exclusive access to all tuples and spaces until there is a "
"\"context switch\": which may happen due to :ref:`the-implicit-yield-rules "
"<atomic-the_implicit_yield_rules>`, or by an explicit call to :ref:`fiber.yield "
"<fiber-yield>`. When the execution flow returns to the yielded procedure, the "
"data set could have changed significantly. Iteration, resumed after a yield "
"point, does not preserve the read view, but continues with the new content of "
"the database. The tutorial :ref:`Indexed pattern search <c_lua_tutorial-"
"indexed_pattern_search>` shows one way that iterators and yields can be used "
"together."
msgstr ""

#: ../book/box/box_index.rst:116 ../book/box/box_index.rst:433
#: ../book/box/box_index.rst:596 ../book/box/box_index.rst:625
#: ../book/box/box_index.rst:656 ../book/box/box_index.rst:684
#: ../book/box/box_index.rst:717 ../book/box/box_index.rst:736
#: ../book/box/box_index.rst:753 ../book/box/box_index.rst:801
msgid ""
":samp:`{index_object}` = an :ref:`object reference <index-object_reference>`;"
msgstr ""

#: ../book/box/box_index.rst:117
msgid ":samp:`{bitset-value} | {search-value...}` = what to search for"
msgstr ""

#: ../book/box/box_index.rst:118
msgid ":samp:`{iterator-type}` = as defined in tables below."
msgstr ""

#: ../book/box/box_index.rst:120
msgid ""
"this method returns an iterator closure, i.e. a function which can be used to "
"get the next value on each invocation"
msgstr ""

#: ../book/box/box_index.rst:122 ../book/box/box_space.rst:873
msgid "function, tuple"
msgstr ""

#: ../book/box/box_index.rst:124
msgid ""
"Possible errors: Selected iteration type is not supported for the index type, or "
"search value is not supported for the iteration type."
msgstr ""

#: ../book/box/box_index.rst:127 ../book/box/box_index.rst:816
msgid "Complexity Factors: Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../book/box/box_index.rst:129
msgid ""
"A search-value can be a number (for example ``1234``), a string (for example "
"``'abcd'``), or a table of numbers and strings (for example ``{1234, 'abcd'}``). "
"Each part of a search-value will be compared to each part of an index key."
msgstr ""

#: ../book/box/box_index.rst:136
msgid "**Iterator types for TREE indexes**"
msgstr ""

#: ../book/box/box_index.rst:140
msgid ""
"Formally the logic for TREE index searches is: |br| comparison-operator is = or "
">= or > or <= or < depending on iterator-type"
msgstr ""

#: ../book/box/box_index.rst:153
msgid ""
"if all comparison-results are true, then search-value \"matches\" index key."
msgstr ""

#: ../book/box/box_index.rst:156
msgid ""
"Notice how, according to this logic, regardless what the index-key-part "
"contains, the comparison-result for equality is always true when a search-value-"
"part is ``nil`` or is missing. This behavior of searches with nil is subject to "
"change."
msgstr ""

#: ../book/box/authentication.rst:73 ../book/box/box_index.rst:166
#: ../book/box/box_index.rst:219 ../book/box/box_index.rst:253
#: ../book/box/box_index.rst:289 ../book/box/box_schema.rst:60
#: ../book/box/box_space.rst:166
msgid "Type"
msgstr ""

#: ../book/box/box_index.rst:166 ../book/box/box_index.rst:219
#: ../book/box/box_index.rst:253 ../book/box/box_index.rst:289
msgid "Arguments"
msgstr ""

#: ../book/box/authentication.rst:73 ../book/box/box_index.rst:166
#: ../book/box/box_index.rst:219 ../book/box/box_index.rst:253
#: ../book/box/box_index.rst:289
msgid "Description"
msgstr ""

#: ../book/box/box_index.rst:168 ../book/box/box_index.rst:226
#: ../book/box/box_index.rst:259 ../book/box/box_index.rst:294
msgid "box.index.EQ or 'EQ'"
msgstr ""

#: ../book/box/box_index.rst:168 ../book/box/box_index.rst:174
#: ../book/box/box_index.rst:179 ../book/box/box_index.rst:186
#: ../book/box/box_index.rst:193 ../book/box/box_index.rst:197
#: ../book/box/box_index.rst:203 ../book/box/box_index.rst:226
#: ../book/box/box_index.rst:232 ../book/box/box_index.rst:294
#: ../book/box/box_index.rst:302 ../book/box/box_index.rst:307
#: ../book/box/box_index.rst:312 ../book/box/box_index.rst:317
#: ../book/box/box_index.rst:327
msgid "search value"
msgstr ""

#: ../book/box/box_index.rst:168
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a search "
"value, it matches. Tuples are returned in ascending order by index key. This is "
"the default."
msgstr ""

#: ../book/box/box_index.rst:174
msgid "box.index.REQ or 'REQ'"
msgstr ""

#: ../book/box/box_index.rst:174
msgid ""
"Matching is the same as for ``box.index.EQ``. Tuples are returned in descending "
"order by index key."
msgstr ""

#: ../book/box/box_index.rst:179 ../book/box/box_index.rst:232
#: ../book/box/box_index.rst:302
msgid "box.index.GT or 'GT'"
msgstr ""

#: ../book/box/box_index.rst:179
msgid ""
"The comparison operator is '>' (greater than). If an index key is greater than a "
"search value, it matches. Tuples are returned in ascending order by index key."
msgstr ""

#: ../book/box/box_index.rst:186 ../book/box/box_index.rst:307
msgid "box.index.GE or 'GE'"
msgstr ""

#: ../book/box/box_index.rst:186
msgid ""
"The comparison operator is '>=' (greater than or equal to). If an index key is "
"greater than or equal to a search value, it matches. Tuples are returned in "
"ascending order by index key."
msgstr ""

#: ../book/box/box_index.rst:193 ../book/box/box_index.rst:255
#: ../book/box/box_index.rst:291
msgid "box.index.ALL or 'ALL'"
msgstr ""

#: ../book/box/box_index.rst:193
msgid "Same as box.index.GE."
msgstr ""

#: ../book/box/box_index.rst:197 ../book/box/box_index.rst:312
msgid "box.index.LT or 'LT'"
msgstr ""

#: ../book/box/box_index.rst:197
msgid ""
"The comparison operator is '<' (less than). If an index key is less than a "
"search value, it matches. Tuples are returned in descending order by index key."
msgstr ""

#: ../book/box/box_index.rst:203 ../book/box/box_index.rst:317
msgid "box.index.LE or 'LE'"
msgstr ""

#: ../book/box/box_index.rst:203
msgid ""
"The comparison operator is '<=' (less than or equal to). If an index key is less "
"than or equal to a search value, it matches. Tuples are returned in descending "
"order by index key."
msgstr ""

#: ../book/box/box_index.rst:212
msgid "**Iterator types for HASH indexes**"
msgstr ""

#: ../book/box/box_index.rst:221
msgid "box.index.ALL"
msgstr ""

#: ../book/box/box_index.rst:221 ../book/box/box_index.rst:255
#: ../book/box/box_index.rst:291
msgid "none"
msgstr ""

#: ../book/box/box_index.rst:221
msgid ""
"All index keys match. Tuples are returned in ascending order by hash of index "
"key, which will appear to be random."
msgstr ""

#: ../book/box/box_index.rst:226
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a search "
"value, it matches. The number of returned tuples will be 0 or 1. This is the "
"default."
msgstr ""

#: ../book/box/box_index.rst:232
msgid ""
"The comparison operator is '>' (greater than). If a hash of an index key is "
"greater than a hash of a search value, it matches. Tuples are returned in "
"ascending order by hash of index key, which will appear to be random. Provided "
"that the space is not being updated, one can retrieve all the tuples in a space, "
"N tuples at a time, by using {iterator='GT', limit=N} in each search, and using "
"the last returned value from the previous result as the start search value for "
"the next search."
msgstr ""

#: ../book/box/box_index.rst:246
msgid "**Iterator types for BITSET indexes**"
msgstr ""

#: ../book/box/box_index.rst:255
msgid "All index keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:259 ../book/box/box_index.rst:264
#: ../book/box/box_index.rst:269 ../book/box/box_index.rst:274
msgid "bitset value"
msgstr ""

#: ../book/box/box_index.rst:259
msgid ""
"If an index key is equal to a bitset value, it matches. Tuples are returned in "
"their order within the space. This is the default."
msgstr ""

#: ../book/box/box_index.rst:264
msgid "box.index.BITS_ALL_SET"
msgstr ""

#: ../book/box/box_index.rst:264
msgid ""
"If all of the bits which are 1 in the bitset value are 1 in the index key, it "
"matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:269
msgid "box.index.BITS_ANY_SET"
msgstr ""

#: ../book/box/box_index.rst:269
msgid ""
"If any of the bits which are 1 in the bitset value are 1 in the index key, it "
"matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:274
msgid "box.index.BITS_ALL_NOT_SET"
msgstr ""

#: ../book/box/box_index.rst:274
msgid ""
"If all of the bits which are 1 in the bitset value are 0 in the index key, it "
"matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:282
msgid "**Iterator types for RTREE indexes**"
msgstr ""

#: ../book/box/box_index.rst:291
msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:294
msgid ""
"If all points of the rectangle-or-box defined by the search value are the same "
"as the rectangle-or-box defined by the index key, it matches. Tuples are "
"returned in their order within the space. \"Rectangle-or-box\" means \"rectangle-"
"or-box as explained in section about :ref:`RTREE <box_index-rtree>`\". This is "
"the default."
msgstr ""

#: ../book/box/box_index.rst:302
msgid ""
"If all points of the rectangle-or-box defined by the search value are within the "
"rectangle-or-box defined by the index key, it matches. Tuples are returned in "
"their order within the space."
msgstr ""

#: ../book/box/box_index.rst:307
msgid ""
"If all points of the rectangle-or-box defined by the search value are within, or "
"at the side of, the rectangle-or-box defined by the index key, it matches. "
"Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:312
msgid ""
"If all points of the rectangle-or-box defined by the index key are within the "
"rectangle-or-box defined by the search key, it matches. Tuples are returned in "
"their order within the space."
msgstr ""

#: ../book/box/box_index.rst:317
msgid ""
"If all points of the rectangle-or-box defined by the index key are within, or at "
"the side of, the rectangle-or-box defined by the search key, it matches. Tuples "
"are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:322
msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr ""

#: ../book/box/box_index.rst:322
msgid "search values"
msgstr ""

#: ../book/box/box_index.rst:322
msgid ""
"If some points of the rectangle-or-box defined by the search value are within "
"the rectangle-or-box defined by the index key, it matches. Tuples are returned "
"in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:327
msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr ""

#: ../book/box/box_index.rst:327
msgid ""
"If some points of the rectangle-or-box defined by the defined by the key are "
"within, or at the side of, defined by the index key, it matches. Tuples are "
"returned in order: nearest neighbor first."
msgstr ""

#: ../book/box/box_index.rst:333
msgid "**First Example of index pairs():**"
msgstr ""

#: ../book/box/box_index.rst:335
msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr ""

#: ../book/box/box_index.rst:337
msgid ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:383
msgid "**Second Example of index pairs():**"
msgstr ""

#: ../book/box/box_index.rst:385
msgid ""
"This Lua code finds all the tuples whose primary key values begin with 'XY'. The "
"assumptions include that there is a one-part primary-key TREE index on the first "
"field, which must be a string. The iterator loop ensures that the search will "
"return tuples where the first value is greater than or equal to 'XY'. The "
"conditional statement within the loop ensures that the looping will stop when "
"the first two letters are not 'XY'."
msgstr ""

#: ../book/box/box_index.rst:393
msgid ""
"for tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../book/box/box_index.rst:401
msgid "**Third Example of index pairs():**"
msgstr ""

#: ../book/box/box_index.rst:403
msgid ""
"This Lua code finds all the tuples whose primary key values are greater than or "
"equal to 1000, and less than or equal to 1999 (this type of request is sometimes "
"called a \"range search\" or a \"between search\"). The assumptions include that "
"there is a one-part primary-key TREE index on the first field, which must be a "
"number. The iterator loop ensures that the search will return tuples where the "
"first value is greater than or equal to 1000. The conditional statement within "
"the loop ensures that the looping will stop when the first value is greater than "
"1999."
msgstr ""

#: ../book/box/box_index.rst:413
msgid ""
"for tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../book/box/box_index.rst:425
msgid ""
"This is an alternative to :ref:`box.space...select() <box_space-select>` which "
"goes via a particular index and can make use of additional parameters that "
"specify the iterator type, and the limit (that is, the maximum number of tuples "
"to return) and the offset (that is, which tuple to start with in the list)."
msgstr ""

#: ../book/box/box_index.rst:434
msgid ":samp:`search-key` = values to be matched against the index key;"
msgstr ""

#: ../book/box/box_index.rst:438
msgid ":samp:`option(s)` any or all of"
msgstr ""

#: ../book/box/box_index.rst:436
msgid ":samp:`iterator = {iterator-type}`,"
msgstr ""

#: ../book/box/box_index.rst:437
msgid ":samp:`limit = {maximum-number-of-tuples}`,"
msgstr ""

#: ../book/box/box_index.rst:438
msgid ":samp:`offset = {start-tuple-number}`."
msgstr ""

#: ../book/box/box_index.rst:440
msgid "the tuple or tuples that match the field values."
msgstr ""

#: ../book/box/box_index.rst:441 ../book/box/box_space.rst:308
msgid "array of tuples"
msgstr ""

#: ../book/box/box_index.rst:445
msgid ""
"-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""

#: ../book/box/box_index.rst:471
msgid "The result will be a table of tuple and will look like this:"
msgstr ""

#: ../book/box/box_index.rst:473
msgid ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:482
msgid ""
":samp:`index.{index-name}` is optional. If it is omitted, then the assumed index "
"is the first (primary-key) index. Therefore, for the example above, ``box.space."
"tester:select({1}, {iterator = 'GT'})`` would have returned the same two rows, "
"via the 'primary' index."
msgstr ""

#: ../book/box/box_index.rst:489
msgid ""
":samp:`iterator = {iterator-type}` is optional. If it is omitted, then "
"``iterator = 'EQ'`` is assumed."
msgstr ""

#: ../book/box/box_index.rst:494
msgid ""
":samp:`{field-value} [, {field-value ...}]` is optional. If it is omitted, then "
"every key in the index is considered to be a match, regardless of iterator type. "
"Therefore, for the example above, ``box.space.tester:select{}`` will select "
"every tuple in the tester space via the first (primary-key) index."
msgstr ""

#: ../book/box/box_index.rst:504
msgid ""
":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]``. can be "
"replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. That is, "
"``get`` can be used as a convenient shorthand to get the first tuple in the "
"tuple set that would be returned by ``select``. However, if there is more than "
"one tuple in the tuple set, then ``get`` returns an error."
msgstr ""

#: ../book/box/box_index.rst:512
msgid "**Example with BITSET index:**"
msgstr ""

#: ../book/box/box_index.rst:514
msgid ""
"The following script shows creation and search with a BITSET index. Notice: "
"BITSET cannot be unique, so first a primary-key index is created. Notice: bit "
"values are entered as hexadecimal literals for easier reading."
msgstr ""

#: ../book/box/box_index.rst:518
msgid ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:565
msgid ""
"Search for a tuple via the given index, as described :ref:`earlier <box_index-"
"note>`."
msgstr ""

#: ../book/box/box_index.rst:567 ../book/box/box_space.rst:299
#: ../book/box/box_space.rst:372
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :codeitalic:`key` (type = Lua table or scalar) = key to be "
"matched against the index key, which may be multi-part."
msgstr ""

#: ../book/box/box_index.rst:571
msgid "the tuple whose index-key fields are equal to the passed key values."
msgstr ""

#: ../book/box/box_index.rst:572 ../book/box/box_index.rst:602
#: ../book/box/box_index.rst:631 ../book/box/box_index.rst:660
#: ../book/box/box_index.rst:724 ../book/box/box_index.rst:741
#: ../book/box/box_space.rst:279 ../book/box/box_space.rst:377
#: ../book/box/box_space.rst:458 ../book/box/box_space.rst:516
#: ../book/box/box_space.rst:655 ../book/box/box_space.rst:844
#: ../book/box/box_tuple.rst:53 ../book/box/box_tuple.rst:197
#: ../book/box/box_tuple.rst:198 ../book/box/box_tuple.rst:289
#: ../book/box/index.rst:171
msgid "tuple"
msgstr ""

#: ../book/box/box_index.rst:574
msgid "Possible errors: No such index; wrong type; more than one tuple matches."
msgstr ""

#: ../book/box/box_index.rst:576
msgid ""
"Complexity Factors: Index size, Index type. See also :ref:`space_object:get() "
"<box_space-get>`."
msgstr ""

#: ../book/box/box_index.rst:581
msgid ""
"tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:592
msgid "Find the minimum value in the specified index."
msgstr ""

#: ../book/box/box_index.rst:597 ../book/box/box_index.rst:626
msgid ":samp:`key-value`."
msgstr ""

#: ../book/box/box_index.rst:599
msgid ""
"the tuple for the first key in the index. If optional ``key-value`` is supplied, "
"returns the first key which is greater than or equal to ``key-value``."
msgstr ""

#: ../book/box/box_index.rst:604 ../book/box/box_index.rst:633
msgid "Possible errors: index is not of type 'TREE'."
msgstr ""

#: ../book/box/box_index.rst:606 ../book/box/box_index.rst:635
#: ../book/box/box_index.rst:662
msgid "Complexity Factors: Index size, Index type."
msgstr ""

#: ../book/box/box_index.rst:610
msgid ""
"tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:621
msgid "Find the maximum value in the specified index."
msgstr ""

#: ../book/box/box_index.rst:628
msgid ""
"the tuple for the last key in the index. If optional ``key-value`` is supplied, "
"returns the last key which is less than or equal to ``key-value``."
msgstr ""

#: ../book/box/box_index.rst:639
msgid ""
"tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:650
msgid ""
"Find a random value in the specified index. This method is useful when it's "
"important to get insight into data distribution in an index without having to "
"iterate over the entire data set."
msgstr ""

#: ../book/box/box_index.rst:657
msgid ":samp:`random-value` (type = number) = an arbitrary non-negative integer."
msgstr ""

#: ../book/box/box_index.rst:659
msgid "the tuple for the random key in the index."
msgstr ""

#: ../book/box/box_index.rst:664
msgid "Note re storage engine: vinyl does not support ``random()``."
msgstr ""

#: ../book/box/box_index.rst:668
msgid ""
"tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:679
msgid ""
"Iterate over an index, counting the number of tuples which match the key-value."
msgstr ""

#: ../book/box/box_index.rst:685
msgid ""
":samp:`{key-value}` (type = Lua table or scalar) = the value which must match "
"the key(s) in the specified index. The type may be a list of field-values, or a "
"tuple containing only the field-values;  :codeitalic:`iterator` = comparison "
"method."
msgstr ""

#: ../book/box/box_index.rst:690
msgid "the number of matching index keys."
msgstr ""

#: ../book/box/box_index.rst:691 ../book/box/box_index.rst:827
#: ../book/box/box_schema.rst:64 ../book/box/box_schema.rst:66
#: ../book/box/box_session.rst:41 ../book/box/box_session.rst:46
#: ../book/box/box_session.rst:71 ../book/box/box_space.rst:172
#: ../book/box/box_tuple.rst:85 ../book/box/box_tuple.rst:110
#: ../book/box/box_tuple.rst:159 ../book/box/index.rst:161
msgid "number"
msgstr ""

#: ../book/box/box_index.rst:696
msgid ""
"tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = 'LE' })\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:709 ../book/box/box_space.rst:477
#: ../book/box/box_tuple.rst:274
msgid "Update a tuple."
msgstr ""

#: ../book/box/box_index.rst:711
msgid ""
"Same as :ref:`box.space...update() <box_space-update>`, but key is searched in "
"this index instead of primary key. This index ought to be unique."
msgstr ""

#: ../book/box/box_index.rst:718
msgid ""
":samp:`{key}` (type = Lua table or scalar) = key to be matched against the index "
"key;"
msgstr ""

#: ../book/box/box_index.rst:720
msgid ""
":samp:`{operator, field_no, value}` (type = Lua table) = update operations "
"(see: :ref:`box.space...update() <box_space-update>`)."
msgstr ""

#: ../book/box/box_index.rst:723 ../book/box/box_space.rst:515
msgid "the updated tuple."
msgstr ""

#: ../book/box/box_index.rst:728
msgid "Delete a tuple identified by a key."
msgstr ""

#: ../book/box/box_index.rst:730
msgid ""
"Same as :ref:`box.space...delete() <box_space-delete>`, but key is searched in "
"this index instead of in the primary-key index. This index ought to be unique."
msgstr ""

#: ../book/box/box_index.rst:737
msgid ""
":samp:`key` (type = Lua table or scalar) = key to be matched against the index "
"key."
msgstr ""

#: ../book/box/box_index.rst:740
msgid "the deleted tuple."
msgstr ""

#: ../book/box/box_index.rst:743
msgid ""
"Note re storage engine: vinyl will return nil, rather than the deleted tuple."
msgstr ""

#: ../book/box/box_index.rst:749
msgid "Alter an index."
msgstr ""

#: ../book/box/box_index.rst:754
msgid ""
":samp:`{options}` = options list, same as the options list for :ref:"
"`create_index <box_space-create_index>`."
msgstr ""

#: ../book/box/box_index.rst:757 ../book/box/box_index.rst:804
#: ../book/box/box_schema.rst:126 ../book/box/box_schema.rst:286
#: ../book/box/box_schema.rst:404 ../book/box/box_space.rst:406
#: ../book/box/box_space.rst:428 ../book/box/box_space.rst:808
#: ../book/box/index.rst:167 ../book/box/triggers.rst:153
#: ../book/box/triggers.rst:204
msgid "nil"
msgstr ""

#: ../book/box/box_index.rst:759
msgid ""
"Possible errors: Index does not exist, or the first index cannot be changed to "
"{unique = false}, or the alter function is only applicable for the memtx storage "
"engine."
msgstr ""

#: ../book/box/box_index.rst:763
msgid "Note re storage engine: vinyl does not support ``alter()``."
msgstr ""

#: ../book/box/box_index.rst:767
msgid ""
"tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:775
msgid ""
"Drop an index. Dropping a primary-key index has a side effect: all tuples are "
"deleted."
msgstr ""

#: ../book/box/box_index.rst:782
msgid "nil."
msgstr ""

#: ../book/box/box_index.rst:784
msgid ""
"Possible errors: Index does not exist, or a primary-key index cannot be dropped "
"while a secondary-key index exists."
msgstr ""

#: ../book/box/box_index.rst:789
msgid ""
"tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:797
msgid "Rename an index."
msgstr ""

#: ../book/box/box_index.rst:802
msgid ":samp:`{index-name}` (type = string) = new name for index."
msgstr ""

#: ../book/box/box_index.rst:806
msgid "Possible errors: index_object does not exist."
msgstr ""

#: ../book/box/box_index.rst:810
msgid ""
"tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:820
msgid "Return the total number of bytes taken by the index."
msgstr ""

#: ../book/box/box_index.rst:826 ../book/box/box_tuple.rst:109
msgid "number of bytes"
msgstr ""

#: ../book/box/box_index.rst:831
msgid "Example showing use of the box functions"
msgstr ""

#: ../book/box/box_index.rst:833
msgid ""
"This example will work with the sandbox configuration described in the preface. "
"That is, there is a space named tester with a numeric primary key. The example "
"function will:"
msgstr ""

#: ../book/box/box_index.rst:837
msgid "select a tuple whose key value is 1000;"
msgstr ""

#: ../book/box/box_index.rst:838
msgid "return an error if the tuple already exists and already has 3 fields;"
msgstr ""

#: ../book/box/box_index.rst:841
msgid "Insert or replace the tuple with:"
msgstr ""

#: ../book/box/box_index.rst:840
msgid "field[1] = 1000"
msgstr ""

#: ../book/box/box_index.rst:841
msgid "field[2] = a uuid"
msgstr ""

#: ../book/box/box_index.rst:842
msgid "field[3] = number of seconds since 1970-01-01;"
msgstr ""

#: ../book/box/box_index.rst:843
msgid "Get field[3] from what was replaced;"
msgstr ""

#: ../book/box/box_index.rst:844
msgid "Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;"
msgstr ""

#: ../book/box/box_index.rst:845
msgid "Return the formatted value."
msgstr ""

#: ../book/box/box_index.rst:847
msgid ""
"The function uses Tarantool box functions :ref:`box.space...select <box_space-"
"select>`, :ref:`box.space...replace <box_space-replace>`, :ref:`fiber.time "
"<fiber-time>`, :ref:`uuid.str <uuid-str>`. The function uses Lua functions `os."
"date()`_ and `string.sub()`_."
msgstr ""

#: ../book/box/box_index.rst:856
#, python-format
msgid ""
"function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"
msgstr ""

#: ../book/box/box_index.rst:881 ../book/box/box_tuple.rst:337
msgid "... And here is what happens when one invokes the function:"
msgstr ""

#: ../book/box/box_index.rst:883
msgid ""
"tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:900
msgid "Example showing a user-defined iterator"
msgstr ""

#: ../book/box/box_index.rst:902
msgid ""
"Here is an example that shows how to build one's own iterator. The "
"``paged_iter`` function is an \"iterator function\", which will only be "
"understood by programmers who have read the Lua manual section `Iterators and "
"Closures <https://www.lua.org/pil/7.1.html>`_. It does paginated retrievals, "
"that is, it returns 10 tuples at a time from a table named \"t\", whose primary "
"key was defined with :codenormal:`create_index('primary',{parts={1,'string'}})`."
msgstr ""

#: ../book/box/box_index.rst:912
msgid ""
"function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"
msgstr ""

#: ../book/box/box_index.rst:926
msgid ""
"Programmers who use ``paged_iter`` do not need to know why it works, they only "
"need to know that, if they call it within a loop, they will get 10 tuples at a "
"time until there are no more tuples. In this example the tuples are merely "
"printed, a page at a time. But it should be simple to change the functionality, "
"for example by yielding after each retrieval, or by breaking when the tuples "
"fail to match some additional criteria."
msgstr ""

#: ../book/box/box_index.rst:936
msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i=1,#page,1 do print(page[i]) end\n"
"end"
msgstr ""

#: ../book/box/box_index.rst:947
msgid "Submodule `box.index` with index type = RTREE for spatial searches"
msgstr ""

#: ../book/box/box_index.rst:949
msgid ""
"The :ref:`box.index <box_index>` submodule may be used for spatial searches if "
"the index type is RTREE. There are operations for searching *rectangles* "
"(geometric objects with 4 corners and 4 sides) and *boxes* (geometric objects "
"with more than 4 corners and more than 4 sides, sometimes called "
"hyperrectangles). This manual uses the term *rectangle-or-box* for the whole "
"class of objects that includes both rectangles and boxes. Only rectangles will "
"be illustrated."
msgstr ""

#: ../book/box/box_index.rst:956
msgid ""
"Rectangles are described according to their X-axis (horizontal axis) and Y-axis "
"(vertical axis) coordinates in a grid of arbitrary size. Here is a picture of "
"four rectangles on a grid with 11 horizontal points and 11 vertical points:"
msgstr ""

#: ../book/box/box_index.rst:962
msgid ""
"           X AXIS\n"
"           1   2   3   4   5   6   7   8   9   10  11\n"
"        1\n"
"        2  #-------+                                           <-Rectangle#1\n"
"Y AXIS  3  |       |\n"
"        4  +-------#\n"
"        5          #-----------------------+                   <-Rectangle#2\n"
"        6          |                       |\n"
"        7          |   #---+               |                   <-Rectangle#3\n"
"        8          |   |   |               |\n"
"        9          |   +---#               |\n"
"        10         +-----------------------#\n"
"        11                                     #               <-Rectangle#4"
msgstr ""

#: ../book/box/box_index.rst:976
msgid ""
"The rectangles are defined according to this scheme: {X-axis coordinate of top "
"left, Y-axis coordinate of top left, X-axis coordinate of bottom right, Y-axis "
"coordinate of bottom right} -- or more succinctly: {x1,y1,x2,y2}. So in the "
"picture ... Rectangle#1 starts at position 1 on the X axis and position 2 on the "
"Y axis, and ends at position 3 on the X axis and position 4 on the Y axis, so "
"its coordinates are {1,2,3,4}. Rectangle#2's coordinates are {3,5,9,10}. "
"Rectangle#3's coordinates are {4,7,5,9}. And finally Rectangle#4's coordinates "
"are {10,11,10,11}. Rectangle#4 is actually a \"point\" since it has zero width "
"and zero height, so it could have been described with only two digits: {10,11}."
msgstr ""

#: ../book/box/box_index.rst:986
msgid ""
"Some relationships between the rectangles are: \"Rectangle#1's nearest neighbor "
"is Rectangle#2\", and \"Rectangle#3 is entirely inside Rectangle#2\"."
msgstr ""

#: ../book/box/box_index.rst:989
msgid "Now let us create a space and add an RTREE index."
msgstr ""

#: ../book/box/box_index.rst:991
msgid ""
"tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../book/box/box_index.rst:1004
msgid ""
"Field#1 doesn't matter, we just make it because we need a primary-key index. "
"(RTREE indexes cannot be unique and therefore cannot be primary-key indexes.) "
"The second field must be an \"array\", which means its values must represent {x,"
"y} points or {x1,y1,x2,y2} rectangles. Now let us populate the table by "
"inserting two tuples, containing the coordinates of Rectangle#2 and Rectangle#4."
msgstr ""

#: ../book/box/box_index.rst:1010
msgid ""
"tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"
msgstr ""

#: ../book/box/box_index.rst:1015
msgid ""
"And now, following the description of `RTREE iterator types`_, we can search the "
"rectangles with these requests:"
msgstr ""

#: ../book/box/box_index.rst:1020
msgid ""
"tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:1036
msgid ""
"Request#1 returns 1 tuple because the point {10,11} is the same as the rectangle "
"{10,11,10,11} (\"Rectangle#4\" in the picture). Request#2 returns 1 tuple "
"because the rectangle {4,7,5,9}, which was \"Rectangle#3\" in the picture, is "
"entirely within{3,5,9,10} which was Rectangle#2. Request#3 returns 2 tuples, "
"because the NEIGHBOR iterator always returns all tuples, and the first returned "
"tuple will be {3,5,9,10} (\"Rectangle#2\" in the picture) because it is the "
"closest neighbor of {1,2,3,4} (\"Rectangle#1\" in the picture)."
msgstr ""

#: ../book/box/box_index.rst:1044
msgid ""
"Now let us create a space and index for cuboids, which are rectangle-or-boxes "
"that have 6 corners and 6 sides."
msgstr ""

#: ../book/box/box_index.rst:1047
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../book/box/box_index.rst:1058
msgid ""
"The additional field here is ``dimension=3``. The default dimension is 2, which "
"is why it didn't need to be specified for the examples of rectangle. The maximum "
"dimension is 20. Now for insertions and selections there will usually be 6 "
"coordinates. For example:"
msgstr ""

#: ../book/box/box_index.rst:1062
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"
msgstr ""

#: ../book/box/box_index.rst:1067
msgid ""
"Now let us create a space and index for Manhattan-style spatial objects, which "
"are rectangle-or-boxes that have a different way to calculate neighbors."
msgstr ""

#: ../book/box/box_index.rst:1070
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../book/box/box_index.rst:1081
msgid ""
"The additional field here is ``distance='manhattan'``. The default distance "
"calculator is 'euclid', which is the straightforward as-the-crow-flies method. "
"The optional distance calculator is 'manhattan', which can be a more appropriate "
"method if one is following the lines of a grid rather than traveling in a "
"straight line."
msgstr ""

#: ../book/box/box_index.rst:1086
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"
msgstr ""

#: ../book/box/box_index.rst:1092
msgid ""
"More examples of spatial searching are online in the file `R tree index quick "
"start and usage`_."
msgstr ""

#: ../book/box/box_schema.rst:30
msgid "Submodule `box.schema`"
msgstr "Вложенный модуль `box.schema`"

#: ../book/box/box_schema.rst:34
msgid ""
"The ``box.schema`` submodule has data-definition functions for spaces, users, "
"roles, and function tuples."
msgstr ""

#: ../book/box/box_schema.rst:41
msgid "Create a space."
msgstr ""

#: ../book/box/box_schema.rst:43
msgid ""
"name of space, which should not be a number and should not contain special "
"characters"
msgstr ""

#: ../book/box/box_schema.rst:45
msgid "see \"Options for box.schema.space.create\" chart, below"
msgstr ""

#: ../book/box/box_schema.rst:47
msgid "space object"
msgstr ""

#: ../book/box/box_schema.rst:48
msgid "userdata"
msgstr ""

#: ../book/box/box_schema.rst:52
msgid "**Options for box.schema.space.create**"
msgstr ""

#: ../book/box/authentication.rst:73 ../book/box/box_schema.rst:60
#: ../book/box/box_space.rst:49 ../book/box/box_space.rst:166
msgid "Name"
msgstr ""

#: ../book/box/box_schema.rst:60 ../book/box/box_space.rst:166
msgid "Effect"
msgstr ""

#: ../book/box/box_schema.rst:60 ../book/box/box_space.rst:166
msgid "Default"
msgstr ""

#: ../book/box/box_schema.rst:62
msgid "temporary"
msgstr ""

#: ../book/box/box_schema.rst:62
msgid "space is temporary"
msgstr ""

#: ../book/box/box_schema.rst:62 ../book/box/box_schema.rst:68
msgid "false"
msgstr ""

#: ../book/box/box_schema.rst:64 ../book/box/box_space.rst:172
msgid "id"
msgstr ""

#: ../book/box/box_schema.rst:64 ../book/box/box_space.rst:172
msgid "unique identifier"
msgstr ""

#: ../book/box/box_schema.rst:64
msgid "last space's id, +1"
msgstr ""

#: ../book/box/box_schema.rst:66
msgid "field_count"
msgstr ""

#: ../book/box/box_schema.rst:66
msgid "fixed field count"
msgstr ""

#: ../book/box/box_schema.rst:66
msgid "0 i.e. not fixed"
msgstr ""

#: ../book/box/box_schema.rst:68 ../book/box/box_space.rst:176
msgid "if_not_exists"
msgstr ""

#: ../book/box/box_schema.rst:68 ../book/box/box_space.rst:176
msgid "no error if duplicate name"
msgstr ""

#: ../book/box/box_schema.rst:71
msgid "engine"
msgstr ""

#: ../book/box/box_schema.rst:71
msgid "storage engine = :ref:`'memtx' or 'vinyl' <index-two_storage_engines>`"
msgstr ""

#: ../book/box/box_schema.rst:71 ../book/box/box_schema.rst:75
#: ../book/box/box_schema.rst:232 ../book/box/box_session.rst:61
#: ../book/box/index.rst:163
msgid "string"
msgstr ""

#: ../book/box/box_schema.rst:71
msgid "'memtx'"
msgstr ""

#: ../book/box/authentication.rst:75 ../book/box/authentication.rst:78
#: ../book/box/box_schema.rst:75
msgid "user"
msgstr ""

#: ../book/box/box_schema.rst:75
msgid "user name"
msgstr ""

#: ../book/box/box_schema.rst:75
msgid "current user's name"
msgstr ""

#: ../book/box/box_schema.rst:77
msgid "format"
msgstr ""

#: ../book/box/box_schema.rst:77
msgid "field names+types"
msgstr ""

#: ../book/box/box_schema.rst:77
msgid "(blank)"
msgstr ""

#: ../book/box/box_schema.rst:80
msgid ""
"There are five :ref:`syntax variations <index-object_reference>` for object "
"references targeting space objects, for example :samp:`box.schema.space."
"drop({space-id})` will drop a space. However, the common approach is to use "
"functions attached to the space objects, for example :ref:`space_object:drop() "
"<box_space-drop>`."
msgstr ""

#: ../book/box/box_schema.rst:86
msgid "Note re storage engine: vinyl does not support temporary spaces."
msgstr ""

#: ../book/box/box_schema.rst:88
#, fuzzy
msgid "**Example**"
msgstr "**Примеры:**"

#: ../book/box/box_schema.rst:90
msgid ""
"tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_schema.rst:108
msgid ""
"For an illustration with the ``format`` clause, see :ref:`box.space._space "
"<box_space-space>` example."
msgstr ""

#: ../book/box/box_schema.rst:111
msgid ""
"After a space is created, usually the next step is to :ref:`create an index "
"<box_space-create_index>` for it, and then it is available for insert, select, "
"and all the other :ref:`box.space <box_space>` functions."
msgstr ""

#: ../book/box/box_schema.rst:118
msgid ""
"Create a user. For explanation of how Tarantool maintains user data, see "
"section :ref:`Users and the _user space <authentication-users>`."
msgstr ""

#: ../book/box/box_schema.rst:122
msgid ""
"name of user, which should not be a number and should not contain special "
"characters"
msgstr ""

#: ../book/box/box_schema.rst:124
msgid "``if_not_exists``, ``password``"
msgstr ""

#: ../book/box/box_schema.rst:128 ../book/box/box_schema.rst:145
#: ../book/box/index.rst:667
msgid "**Examples:**"
msgstr "**Примеры:**"

#: ../book/box/box_schema.rst:130
msgid ""
"box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"
msgstr ""

#: ../book/box/box_schema.rst:138
msgid ""
"Drop a user. For explanation of how Tarantool maintains user data, see section :"
"ref:`Users and the _user space <authentication-users>`."
msgstr ""

#: ../book/box/box_schema.rst:142 ../book/box/box_schema.rst:156
#: ../book/box/box_schema.rst:173 ../book/box/box_schema.rst:204
msgid "the name of the user"
msgstr ""

#: ../book/box/box_schema.rst:143
msgid "``if_exists``"
msgstr ""

#: ../book/box/box_schema.rst:147
msgid ""
"box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"
msgstr ""

#: ../book/box/box_schema.rst:154
msgid "Return true if a user exists; return false if a user does not exist."
msgstr ""

#: ../book/box/box_schema.rst:157 ../book/box/box_schema.rst:314
#: ../book/box/box_schema.rst:436
msgid "bool"
msgstr ""

#: ../book/box/box_schema.rst:161
msgid "box.schema.user.exists('Lena')"
msgstr ""

#: ../book/box/box_schema.rst:171
msgid "Grant :ref:`privileges <authentication-privileges>` to a user."
msgstr ""

#: ../book/box/box_schema.rst:174
msgid "'read' or 'write' or 'execute' or a combination,"
msgstr ""

#: ../book/box/box_schema.rst:175
msgid "'space' or 'function'."
msgstr ""

#: ../book/box/box_schema.rst:176
msgid "name of object to grant permissions to"
msgstr ""

#: ../book/box/box_schema.rst:177
msgid "name of role to grant to user."
msgstr ""

#: ../book/box/box_schema.rst:178
msgid "``grantor``, ``if_not_exists``"
msgstr ""

#: ../book/box/box_schema.rst:180
msgid ""
"If :samp:`'function','{object-name}'` is specified, then a _func tuple with that "
"object-name must exist."
msgstr ""

#: ../book/box/box_schema.rst:183 ../book/box/box_schema.rst:212
#: ../book/box/box_schema.rst:334 ../book/box/box_schema.rst:362
msgid ""
"**Variation:** instead of ``object-type, object-name`` say 'universe' which "
"means 'all object-types and all objects'."
msgstr ""

#: ../book/box/box_schema.rst:186 ../book/box/box_schema.rst:215
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say ``role-"
"name`` (see section :ref:`Roles <authentication-roles>`)."
msgstr ""

#: ../book/box/box_schema.rst:191
msgid ""
"box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.grant('Lena', 'read,write', 'universe')\n"
"box.schema.user.grant('Lena', 'Accountant')\n"
"box.schema.user.grant('Lena', 'read,write,execute', 'universe')\n"
"box.schema.user.grant('X', 'read', 'universe', nil, {if_not_exists=true}))"
msgstr ""

#: ../book/box/box_schema.rst:202
msgid "Revoke :ref:`privileges <authentication-privileges>` from a user."
msgstr ""

#: ../book/box/box_schema.rst:205 ../book/box/box_schema.rst:327
#: ../book/box/box_schema.rst:355
msgid "'read' or 'write' or 'execute' or a combination"
msgstr ""

#: ../book/box/box_schema.rst:206 ../book/box/box_schema.rst:328
#: ../book/box/box_schema.rst:356
msgid "'space' or 'function'"
msgstr ""

#: ../book/box/box_schema.rst:207 ../book/box/box_schema.rst:329
#: ../book/box/box_schema.rst:357
msgid "the name of a function or space"
msgstr ""

#: ../book/box/box_schema.rst:209
msgid ""
"The user must exist, and the object must exist, but it is not an error if the "
"user does not have the privilege."
msgstr ""

#: ../book/box/box_schema.rst:220
msgid ""
"box.schema.user.revoke('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.revoke('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.revoke('Lena', 'read,write', 'universe')\n"
"box.schema.user.revoke('Lena', 'Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:229
msgid "Return a hash of a password."
msgstr ""

#: ../book/box/box_schema.rst:231 ../book/box/box_schema.rst:250
msgid "password"
msgstr ""

#: ../book/box/box_schema.rst:236
msgid "box.schema.user.password('ЛЕНА')"
msgstr ""

#: ../book/box/box_schema.rst:242
msgid ""
"Associate a password with the user who is currently logged in. or with another "
"user. Users who wish to change their own passwords should use box.schema.user."
"passwd(password). Administrators who wish to change passwords of other users "
"should use box.schema.user.passwd(user-name, password)."
msgstr ""

#: ../book/box/box_schema.rst:249
msgid "user-name"
msgstr ""

#: ../book/box/box_schema.rst:254
msgid ""
"box.schema.user.passwd('ЛЕНА')\n"
"box.schema.user.passwd('Lena', 'ЛЕНА')"
msgstr ""

#: ../book/box/box_schema.rst:261
msgid "Return a description of a user's privileges."
msgstr ""

#: ../book/box/box_schema.rst:263
msgid ""
"the name of the user. This is optional; if it is not supplied, then the "
"information will be for the user who is currently logged in."
msgstr ""

#: ../book/box/box_schema.rst:271
msgid ""
"box.schema.user.info()\n"
"box.schema.user.info('Lena')"
msgstr ""

#: ../book/box/box_schema.rst:278
msgid ""
"Create a role. For explanation of how Tarantool maintains role data, see "
"section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../book/box/box_schema.rst:282
msgid ""
"name of role, which should not be a number and should not contain special "
"characters"
msgstr ""

#: ../book/box/box_schema.rst:284
msgid "``if_not_exists``"
msgstr ""

#: ../book/box/box_schema.rst:290
msgid ""
"box.schema.role.create('Accountant')\n"
"box.schema.role.create('Accountant', {if_not_exists = false})"
msgstr ""

#: ../book/box/box_schema.rst:297
msgid ""
"Drop a role. For explanation of how Tarantool maintains role data, see section :"
"ref:`Roles <authentication-roles>`."
msgstr ""

#: ../book/box/box_schema.rst:301 ../book/box/box_schema.rst:313
#: ../book/box/box_schema.rst:326 ../book/box/box_schema.rst:354
msgid "the name of the role"
msgstr ""

#: ../book/box/box_schema.rst:305
msgid "box.schema.role.drop('Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:311
msgid "Return true if a role exists; return false if a role does not exist."
msgstr ""

#: ../book/box/box_schema.rst:318
msgid "box.schema.role.exists('Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:324
msgid "Grant :ref:`privileges <authentication-privileges>` to a role."
msgstr ""

#: ../book/box/box_schema.rst:330
msgid "{if_not_exists=true} or {if_not_exists=false}"
msgstr ""

#: ../book/box/box_schema.rst:332
msgid "The role must exist, and the object must exist."
msgstr ""

#: ../book/box/box_schema.rst:337
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say ``role-"
"name`` -- to grant a role to a role."
msgstr ""

#: ../book/box/box_schema.rst:342
msgid ""
"box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
"box.schema.role.grant('public', 'Accountant')\n"
"box.schema.role.grant('role1', 'role2', nil, nil, {if_not_exists=false})"
msgstr ""

#: ../book/box/box_schema.rst:352
msgid "Revoke :ref:`privileges <authentication-privileges>` from a role."
msgstr ""

#: ../book/box/box_schema.rst:359
msgid ""
"The role must exist, and the object must exist, but it is not an error if the "
"role does not have the privilege."
msgstr ""

#: ../book/box/box_schema.rst:365
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say ``role-"
"name``."
msgstr ""

#: ../book/box/box_schema.rst:370
msgid ""
"box.schema.role.revoke('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.revoke('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.revoke('Accountant', 'read,write', 'universe')\n"
"box.schema.role.revoke('public', 'Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:379
msgid "Return a description of a role's privileges."
msgstr ""

#: ../book/box/box_schema.rst:381
msgid "the name of the role."
msgstr ""

#: ../book/box/box_schema.rst:385
msgid "box.schema.role.info('Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:393
msgid ""
"Create a function tuple. This does not create the function itself -- that is "
"done with Lua -- but if it is necessary to grant privileges for a function, box."
"schema.func.create must be done first. For explanation of how Tarantool "
"maintains function data, see section :ref:`Functions and the _func space "
"<authentication-funcs>`."
msgstr ""

#: ../book/box/box_schema.rst:400
msgid ""
"name of function, which should not be a number and should not contain special "
"characters"
msgstr ""

#: ../book/box/box_schema.rst:402
msgid "``if_not_exists``, ``setuid``, ``language``."
msgstr ""

#: ../book/box/box_schema.rst:408
msgid ""
"box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"
msgstr ""

#: ../book/box/box_schema.rst:419
msgid ""
"Drop a function tuple. For explanation of how Tarantool maintains function data, "
"see section :ref:`Functions and the _func space <authentication-funcs>`."
msgstr ""

#: ../book/box/box_schema.rst:423 ../book/box/box_schema.rst:435
msgid "the name of the function"
msgstr ""

#: ../book/box/box_schema.rst:427
msgid "box.schema.func.drop('calculate')"
msgstr ""

#: ../book/box/box_schema.rst:433
msgid ""
"Return true if a function tuple exists; return false if a function tuple does "
"not exist."
msgstr ""

#: ../book/box/box_schema.rst:440
msgid "box.schema.func.exists('calculate')"
msgstr ""

#: ../book/box/box_session.rst:28
msgid "Submodule `box.session`"
msgstr "Вложенный модуль `box.session`"

#: ../book/box/box_session.rst:30
msgid ""
"The ``box.session`` submodule allows querying the session state, writing to a "
"session-specific temporary Lua table, or setting up triggers which will fire "
"when a session starts or ends. A *session* is an object associated with each "
"client connection."
msgstr ""

#: ../book/box/box_session.rst:39
msgid ""
"the unique identifier (ID) for the current session. The result can be 0 meaning "
"there is no session."
msgstr ""

#: ../book/box/box_session.rst:45
msgid "1 if the session exists, 0 if the session does not exist."
msgstr ""

#: ../book/box/box_session.rst:50
msgid ""
"This function works only if there is a peer, that is, if a connection has been "
"made to a separate server."
msgstr ""

#: ../book/box/box_session.rst:53
msgid ""
"The host address and port of the session peer, for example \"127.0.0.1:55457\". "
"If the session exists but there is no connection to a separate server, the "
"return is null. The command is executed on the server, so the \"local name\" is "
"the server's host and port, and the \"peer name\" is the client's host and port."
msgstr ""

#: ../book/box/box_session.rst:63
msgid "Possible errors: 'session.peer(): session does not exist'"
msgstr ""

#: ../book/box/box_session.rst:67
msgid ""
"the value of the :code:`sync` integer constant used in the `binary protocol "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/iproto_constants.h>`_."
msgstr ""

#: ../book/box/box_session.rst:77
msgid ""
"A Lua table that can hold arbitrary unordered session-specific names and values, "
"which will last until the session ends."
msgstr ""

#: ../book/box/atomic.rst:95 ../book/box/box_session.rst:82
#: ../book/box/box_tuple.rst:306 ../book/box/index.rst:159
#: ../book/box/triggers.rst:96 ../book/box/triggers.rst:214
msgid "Example"
msgstr "Пример"

#: ../book/box/box_session.rst:84
msgid ""
"tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the eggs\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."
msgstr ""

#: ../book/box/box_session.rst:109
msgid ""
"See the section :ref:`Triggers <triggers-box_triggers>` for instructions about "
"defining triggers for connect and disconnect events with ``box.session."
"on_connect()`` and ``box.session.on_disconnect()``. See the section :ref:`Access "
"control <authentication>` for instructions about ``box.session`` functions that "
"affect user identification and security."
msgstr ""

#: ../book/box/box_space.rst:30
msgid "Submodule `box.space`"
msgstr "Вложенный модуль `box.space`"

#: ../book/box/box_space.rst:32
msgid ""
"The ``box.space`` submodule has the data-manipulation functions ``select``, "
"``insert``, ``replace``, ``update``, ``upsert``, ``delete``, ``get``, ``put``. "
"It also has members, such as id, and whether or not a space is enabled. "
"Submodule source code is available in file `src/box/lua/schema.lua <https://"
"github.com/tarantool/tarantool/blob/1.7/src/box/lua/schema.lua>`_."
msgstr ""

#: ../book/box/box_space.rst:38
msgid ""
"A list of all ``box.space`` functions follows, then comes a list of all ``box."
"space`` members."
msgstr ""

#: ../book/box/box_space.rst:43
msgid "**The functions and members of box.space**"
msgstr ""

#: ../book/box/box_space.rst:49
msgid "Use"
msgstr ""

#: ../book/box/box_space.rst:51
msgid ":ref:`space_object:create_index() <box_space-create_index>`"
msgstr ""

#: ../book/box/box_space.rst:51
msgid "Create an index"
msgstr ""

#: ../book/box/box_space.rst:54
msgid ":ref:`space_object:insert() <box_space-insert>`"
msgstr ""

#: ../book/box/box_space.rst:54
msgid "Insert a tuple"
msgstr ""

#: ../book/box/box_space.rst:57
msgid ":ref:`space_object:select() <box_space-select>`"
msgstr ""

#: ../book/box/box_space.rst:57
msgid "Select one or more tuples"
msgstr ""

#: ../book/box/box_space.rst:60
msgid ":ref:`space_object:get() <box_space-get>`"
msgstr ""

#: ../book/box/box_space.rst:60
msgid "Select a tuple"
msgstr ""

#: ../book/box/box_space.rst:63
msgid ":ref:`space_object:drop() <box_space-drop>`"
msgstr ""

#: ../book/box/box_space.rst:63
msgid "Destroy a space"
msgstr ""

#: ../book/box/box_space.rst:66
msgid ":ref:`space_object:rename() <box_space-rename>`"
msgstr ""

#: ../book/box/box_space.rst:66
msgid "Rename a space"
msgstr ""

#: ../book/box/box_space.rst:69
msgid ":ref:`space_object:replace() <box_space-replace>`"
msgstr ""

#: ../book/box/box_space.rst:69 ../book/box/box_space.rst:72
msgid "Insert or replace a tuple"
msgstr ""

#: ../book/box/box_space.rst:72
msgid ":ref:`space_object:put() <box_space-replace>`"
msgstr ""

#: ../book/box/box_space.rst:75
msgid ":ref:`space_object:update() <box_space-update>`"
msgstr ""

#: ../book/box/box_space.rst:75 ../book/box/box_space.rst:78
msgid "Update a tuple"
msgstr ""

#: ../book/box/box_space.rst:78
msgid ":ref:`space_object:upsert() <box_space-upsert>`"
msgstr ""

#: ../book/box/box_space.rst:81
msgid ":ref:`space_object:delete() <box_space-delete>`"
msgstr ""

#: ../book/box/box_space.rst:81
msgid "Delete a tuple"
msgstr ""

#: ../book/box/box_space.rst:84
msgid ":ref:`space_object:count() <box_space-count>`"
msgstr ""

#: ../book/box/box_space.rst:84 ../book/box/box_space.rst:87
msgid "Get count of tuples"
msgstr ""

#: ../book/box/box_space.rst:87
msgid ":ref:`space_object:len() <box_space-len>`"
msgstr ""

#: ../book/box/box_space.rst:90
msgid ":ref:`space_object:truncate() <box_space-truncate>`"
msgstr ""

#: ../book/box/box_space.rst:90
msgid "Delete all tuples"
msgstr ""

#: ../book/box/box_space.rst:93
msgid ":ref:`space_object:auto_increment() <box_space-auto_increment>`"
msgstr ""

#: ../book/box/box_space.rst:93
msgid "Generate key + Insert a tuple"
msgstr ""

#: ../book/box/box_space.rst:96
msgid ":ref:`space_object:pairs() <box_space-pairs>`"
msgstr ""

#: ../book/box/box_space.rst:96
msgid "Prepare for iterating"
msgstr ""

#: ../book/box/box_space.rst:99
msgid ":ref:`space_object.id <box_space-id>`"
msgstr ""

#: ../book/box/box_space.rst:99
msgid ".Numeric identifier of space"
msgstr ""

#: ../book/box/box_space.rst:102
msgid ":ref:`space_object.enabled <box_space-enabled>`"
msgstr ""

#: ../book/box/box_space.rst:102
msgid ".Flag, true if space is enabled"
msgstr ""

#: ../book/box/box_space.rst:105
msgid ":ref:`space_object.field_count <box_space-field_count>`"
msgstr ""

#: ../book/box/box_space.rst:105
msgid ".Required number of fields"
msgstr ""

#: ../book/box/box_space.rst:108
msgid ":ref:`space_object.index <box_space-field_count>`"
msgstr ""

#: ../book/box/box_space.rst:108
msgid ".Container of space's indexes"
msgstr ""

#: ../book/box/box_space.rst:111
msgid ":ref:`box.space._schema <box_space-schema>`"
msgstr ""

#: ../book/box/box_space.rst:111
msgid ".(Metadata) List of schemas"
msgstr ""

#: ../book/box/box_space.rst:114
msgid ":ref:`box.space._space <box_space-space>`"
msgstr ""

#: ../book/box/box_space.rst:114
msgid ".(Metadata) List of spaces"
msgstr ""

#: ../book/box/box_space.rst:117
msgid ":ref:`box.space._index <box_space-index>`"
msgstr ""

#: ../book/box/box_space.rst:117
msgid ".(Metadata) List of indexes"
msgstr ""

#: ../book/box/box_space.rst:120
msgid ":ref:`box.space._user <box_space-user>`"
msgstr ""

#: ../book/box/box_space.rst:120
msgid ".(Metadata) List of users"
msgstr ""

#: ../book/box/box_space.rst:123
msgid ":ref:`box.space._priv <box_space-priv>`"
msgstr ""

#: ../book/box/box_space.rst:123
msgid ".(Metadata) List of privileges"
msgstr ""

#: ../book/box/box_space.rst:126
msgid ":ref:`box.space._cluster <box_space-cluster>`"
msgstr ""

#: ../book/box/box_space.rst:126
msgid ".(Metadata) List of clusters"
msgstr ""

#: ../book/box/box_space.rst:129
msgid ":ref:`box.space._func <box_space-func>`"
msgstr ""

#: ../book/box/box_space.rst:129
msgid ".(Metadata) List of function tuples"
msgstr ""

#: ../book/box/box_space.rst:143
msgid ""
"Create an index. It is mandatory to create an index for a tuple set before "
"trying to insert tuples into it, or select tuples from it. The first created "
"index, which will be used as the primary-key index, must be unique."
msgstr ""

#: ../book/box/box_space.rst:148
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :codeitalic:`index_name` (type = string) = name of index, "
"which should not be a number and should not contain special characters; :"
"codeitalic:`options`."
msgstr ""

#: ../book/box/box_space.rst:153
msgid "index object"
msgstr ""

#: ../book/box/box_space.rst:154
msgid "index_object"
msgstr ""

#: ../book/box/box_space.rst:158
msgid "Options for ``space_object:create_index``:"
msgstr ""

#: ../book/box/box_space.rst:168
msgid "type"
msgstr ""

#: ../book/box/box_space.rst:168
msgid "type of index"
msgstr ""

#: ../book/box/box_space.rst:168
msgid "string ('HASH' or 'TREE' or 'BITSET' or 'RTREE')"
msgstr ""

#: ../book/box/box_space.rst:168
msgid "'TREE'"
msgstr ""

#: ../book/box/box_space.rst:172
msgid "last index's id, +1"
msgstr ""

#: ../book/box/box_space.rst:174
msgid "unique"
msgstr ""

#: ../book/box/box_space.rst:174
msgid "index is unique"
msgstr ""

#: ../book/box/box_space.rst:174
msgid "``true``"
msgstr ""

#: ../book/box/box_space.rst:176
msgid "``false``"
msgstr ""

#: ../book/box/box_space.rst:179
msgid "parts"
msgstr ""

#: ../book/box/box_space.rst:179
msgid "field-numbers  + types"
msgstr ""

#: ../book/box/box_space.rst:179
msgid ""
"{field_no, 'unsigned' or 'string' or 'integer' or 'number' or 'array' or "
"'scalar'}"
msgstr ""

#: ../book/box/box_space.rst:179
msgid "``{1, 'unsigned'}``"
msgstr ""

#: ../book/box/box_space.rst:185
msgid ""
"Possible errors: too many parts. Index '...' already exists. Primary key must be "
"unique."
msgstr ""

#: ../book/box/box_space.rst:187
msgid ""
"Note re storage engine: vinyl supports only the TREE index type, and vinyl "
"secondary indexes must be created before tuples are inserted."
msgstr ""

#: ../book/box/box_space.rst:190
msgid ""
"tarantool> s = box.space.space55\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = {1, 'unsigned', 2, "
"'string'}})\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:201
msgid ""
"Details about index field types: |br| The six index field types (unsigned | "
"string | integer | number | array | scalar) differ depending on what values are "
"allowed, and what index types are allowed. |br| **unsigned**: unsigned integers "
"between 0 and 18446744073709551615, about 18 quintillion. May also be called "
"'uint' or 'num', but 'num' is deprecated. Legal in memtx TREE or HASH indexes, "
"and in vinyl TREE indexes. |br| **string**: any set of octets, up to the :ref:"
"`maximum length <limitations_bytes_in_index_key>`. May also be called 'str'. "
"Legal in memtx TREE or HASH or BITSET indexes, and in vinyl TREE indexes. |br| "
"**integer**: integers between -9223372036854775808 and 18446744073709551615. May "
"also be called 'int'. Legal in memtx TREE or HASH indexes, and in vinyl TREE "
"indexes. |br| **number**: integers between -9223372036854775808 and "
"18446744073709551615, single-precision floating point numbers, or double-"
"precision floating point numbers. Legal in memtx TREE or HASH indexes, and in "
"vinyl TREE indexes. |br| **array**: array of integers between "
"-9223372036854775808 and 9223372036854775807. Legal in memtx RTREE indexes. |br| "
"**scalar**: booleans (true or false), or integers between -9223372036854775808 "
"and 18446744073709551615, or single-precision floating point numbers, or double-"
"precison floating-point numbers, or strings. When there is a mix of types, the "
"key order is: booleans, then numbers, then strings. Legal in memtx TREE or HASH "
"indexes, and in vinyl TREE indexes."
msgstr ""

#: ../book/box/box_space.rst:225
msgid "**Index field types to use in create_index**"
msgstr ""

#: ../book/box/box_space.rst:234
msgid "Index field type"
msgstr "Тип поля для индексирования"

#: ../book/box/box_space.rst:234
msgid "What can be in it"
msgstr ""

#: ../book/box/box_space.rst:234
msgid "Where is it legal"
msgstr ""

#: ../book/box/box_space.rst:234
msgid "Examples"
msgstr "Примеры:"

#: ../book/box/box_space.rst:236
msgid "**unsigned**"
msgstr ""

#: ../book/box/box_space.rst:236
msgid "integers between 0 and 18446744073709551615"
msgstr ""

#: ../book/box/box_space.rst:236 ../book/box/box_space.rst:243
#: ../book/box/box_space.rst:247 ../book/box/box_space.rst:259
msgid "memtx TREE or HASH indexes, |br| vinyl TREE indexes"
msgstr ""

#: ../book/box/box_space.rst:236
msgid "123456 |br|"
msgstr "123456 |br|"

#: ../book/box/box_space.rst:240
msgid "**string**"
msgstr ""

#: ../book/box/box_space.rst:240
msgid "strings -- any set of octets"
msgstr ""

#: ../book/box/box_space.rst:240
msgid "memtx TREE or HASH indexes |br| vinyl TREE indexes"
msgstr ""

#: ../book/box/box_space.rst:240
msgid "'A B C' |br| '\\\\65 \\\\66 \\\\67'"
msgstr ""

#: ../book/box/box_space.rst:243
msgid "**integer**"
msgstr ""

#: ../book/box/box_space.rst:243
msgid "integers between -9223372036854775808 and 18446744073709551615"
msgstr ""

#: ../book/box/box_space.rst:243
msgid "-2^63 |br|"
msgstr ""

#: ../book/box/box_space.rst:247
msgid "**number**"
msgstr ""

#: ../book/box/box_space.rst:247
msgid ""
"integers between -9223372036854775808 and 18446744073709551615, single-precision "
"floating point numbers, double-precision floating point numbers"
msgstr ""

#: ../book/box/box_space.rst:247
msgid "1.234 |br| -44 |br| 1.447e+44"
msgstr ""

#: ../book/box/box_space.rst:255
msgid "**array**"
msgstr ""

#: ../book/box/box_space.rst:255
msgid "array of integers between -9223372036854775808 and 9223372036854775807"
msgstr ""

#: ../book/box/box_space.rst:255
msgid "memtx RTREE indexes"
msgstr ""

#: ../book/box/box_space.rst:255
msgid "{10, 11} |br| {3, 5, 9, 10}"
msgstr ""

#: ../book/box/box_space.rst:259
msgid "**scalar**"
msgstr "**scalar**"

#: ../book/box/box_space.rst:259
msgid ""
"booleans (true or false), integers between -9223372036854775808 and "
"18446744073709551615, single-precision floating point numbers, double-precision "
"floating point numbers, strings"
msgstr ""

#: ../book/box/box_space.rst:259
msgid "true |br| -1 |br| 1.234 |br| '' |br| '俄國'"
msgstr ""

#: ../book/box/box_space.rst:273
msgid "Insert a tuple into a space."
msgstr ""

#: ../book/box/box_space.rst:275 ../book/box/box_space.rst:454
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :codeitalic:`tuple` (type = Lua table or tuple) = tuple to "
"be inserted."
msgstr ""

#: ../book/box/box_space.rst:278
msgid "the inserted tuple"
msgstr ""

#: ../book/box/box_space.rst:281
msgid ""
"Possible errors: If a tuple with the same unique-key value already exists, "
"returns :errcode:`ER_TUPLE_FOUND`."
msgstr ""

#: ../book/box/box_space.rst:286
msgid ""
"tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:297
msgid "Search for a tuple or a set of tuples in the given space."
msgstr ""

#: ../book/box/box_space.rst:303
msgid ""
"the tuples whose primary-key fields are equal to the passed field-values. If the "
"number of passed field-values is less than the number of fields in the primary "
"key, then only the passed field-values are compared, so ``select{1,2}`` will "
"match a tuple whose primary key is ``{1,2,3}``."
msgstr ""

#: ../book/box/box_space.rst:310
msgid "Possible errors: No such space; wrong type."
msgstr ""

#: ../book/box/box_space.rst:312
msgid "**Complexity Factors:** Index size, Index type."
msgstr ""

#: ../book/box/box_space.rst:316
msgid ""
"tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = {1,'unsigned', 2, 'string'}})\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- must equal both primary-key fields\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- must equal only one primary-key field\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- must equal 0 fields, so returns all tuples\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:361
msgid ""
"For examples of complex ``select`` requests, where one can specify which index "
"to search and what condition to use (for example \"greater than\" instead of "
"\"equal to\") and how many tuples to return, see the later section :ref:"
"`index_object:select <box_index-select>`."
msgstr ""

#: ../book/box/box_space.rst:370
msgid "Search for a tuple in the given space."
msgstr ""

#: ../book/box/box_space.rst:376
msgid "the tuple whose index key matches :codeitalic:`key`, or null."
msgstr ""

#: ../book/box/box_space.rst:379 ../book/box/box_space.rst:408
msgid "Possible errors: If space_object does not exist."
msgstr ""

#: ../book/box/box_space.rst:381 ../book/box/box_space.rst:410
#: ../book/box/box_space.rst:464 ../book/box/box_space.rst:846
msgid ""
"**Complexity Factors:** Index size, Index type, Number of indexes accessed, WAL "
"settings."
msgstr ""

#: ../book/box/box_space.rst:384
msgid ""
"The ``box.space...select`` function returns a set of tuples as a Lua table; the "
"``box.space...get`` function returns at most a single tuple. And it is possible "
"to get the first tuple in a tuple set by appending ``[1]``. Therefore ``box."
"space.tester:get{1}`` has the same effect as ``box.space.tester:select{1}[1]``, "
"if exactly one tuple is found."
msgstr ""

#: ../book/box/box_space.rst:394
msgid "box.space.tester:get{1}"
msgstr ""

#: ../book/box/box_space.rst:402
msgid "Drop a space."
msgstr ""

#: ../book/box/box_space.rst:404 ../book/box/box_space.rst:687
#: ../book/box/box_space.rst:705 ../book/box/box_space.rst:725
#: ../book/box/box_space.rst:742 ../book/box/box_space.rst:782
#: ../book/box/box_space.rst:804 ../book/box/box_space.rst:870
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`."
msgstr ""

#: ../book/box/box_space.rst:415
msgid "box.space.space_that_does_not_exist:drop()"
msgstr ""

#: ../book/box/box_space.rst:423
msgid "Rename a space."
msgstr ""

#: ../book/box/box_space.rst:425
msgid ""
"Parameters::samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :codeitalic:`space-name` (type = string) = new name for "
"space."
msgstr ""

#: ../book/box/box_space.rst:430
msgid "Possible errors: space_object does not exist."
msgstr ""

#: ../book/box/box_space.rst:434
msgid ""
"tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:448
msgid ""
"Insert a tuple into a space. If a tuple with the same primary key already "
"exists, ``box.space...:replace()`` replaces the existing tuple with a new one. "
"The syntax variants ``box.space...:replace()`` and ``box.space...:put()`` have "
"the same effect; the latter is sometimes used to show that the effect is the "
"converse of ``box.space...:get()``."
msgstr ""

#: ../book/box/box_space.rst:457 ../book/box/box_space.rst:843
msgid "the inserted tuple."
msgstr ""

#: ../book/box/box_space.rst:460
msgid ""
"Possible errors: If a different tuple with the same unique-key value already "
"exists, returns :errcode:`ER_TUPLE_FOUND`. (This will only happen if there is a "
"unique secondary index.)"
msgstr ""

#: ../book/box/box_space.rst:469
msgid "box.space.tester:replace{5000, 'tuple number five thousand'}"
msgstr ""

#: ../book/box/box_space.rst:479
msgid ""
"The ``update`` function supports operations on fields — assignment, arithmetic "
"(if the field is numeric), cutting and pasting fragments of a field, deleting or "
"inserting a field. Multiple operations can be combined in a single update "
"request, and in this case they are performed atomically and sequentially. Each "
"operation requires specification of a field number. When multiple operations are "
"present, the field number for each operation is assumed to be relative to the "
"most recent state of the tuple, that is, as if all previous operations in a "
"multi-operation update have already been applied. In other words, it is always "
"safe to merge multiple ``update`` invocations into a single invocation, with no "
"change in semantics."
msgstr ""

#: ../book/box/box_space.rst:491
msgid "Possible operators are:"
msgstr ""

#: ../book/box/box_space.rst:493
msgid "``+`` for addition (values must be numeric)"
msgstr ""

#: ../book/box/box_space.rst:494
msgid "``-`` for subtraction (values must be numeric)"
msgstr ""

#: ../book/box/box_space.rst:495
msgid "``&`` for bitwise AND (values must be unsigned numeric)"
msgstr ""

#: ../book/box/box_space.rst:496
msgid "``|`` for bitwise OR (values must be unsigned numeric)"
msgstr ""

#: ../book/box/box_space.rst:497
msgid ""
"``^`` for bitwise :abbr:`XOR(exclusive OR)` (values must be unsigned numeric)"
msgstr ""

#: ../book/box/box_space.rst:498
msgid "``:`` for string splice"
msgstr ""

#: ../book/box/box_space.rst:499
msgid "``!`` for insertion"
msgstr ""

#: ../book/box/box_space.rst:500
msgid "``#`` for deletion"
msgstr ""

#: ../book/box/box_space.rst:501
msgid "``=`` for assignment"
msgstr ""

#: ../book/box/box_space.rst:503
msgid ""
"For ``!`` and ``=`` operations the field number can be ``-1``, meaning the last "
"field in the tuple."
msgstr ""

#: ../book/box/box_space.rst:506
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :codeitalic:`key` (type = Lua table or scalar) = primary-key "
"field values, must be passed as a Lua table if key is multi-part; :codeitalic:"
"`{operator, field_no, value}` (type = table): a group of arguments for each "
"operation, indicating what the operation is, what field the operation will apply "
"to, and what value will be applied. The field number can be negative, meaning "
"the position from the end of tuple (#tuple + negative field number + 1)."
msgstr ""

#: ../book/box/box_space.rst:518
msgid "Possible errors: it is illegal to modify a primary-key field."
msgstr ""

#: ../book/box/box_space.rst:520
msgid ""
"**Complexity Factors:** Index size, Index type, number of indexes accessed, WAL "
"settings."
msgstr ""

#: ../book/box/box_space.rst:523
msgid "Thus, in the instruction:"
msgstr ""

#: ../book/box/box_space.rst:525
msgid "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"
msgstr ""

#: ../book/box/box_space.rst:529
msgid ""
"the primary-key value is ``44``, the operators are ``'+'`` and ``'='`` meaning "
"*add a value to a field and then assign a value to a field*, the first affected "
"field is field ``1`` and the value which will be added to it is ``55``, the "
"second affected field is field ``3`` and the value which will be assigned to it "
"is ``'x'``."
msgstr ""

#: ../book/box/box_space.rst:537
msgid ""
"Assume that initially there is a space named ``tester`` with a primary-key index "
"whose type is ``unsigned``. There is one tuple, with ``field[1]`` = ``999`` and "
"``field[2]`` = ``'A'``."
msgstr ""

#: ../book/box/box_space.rst:541
msgid ""
"In the update: |br| ``box.space.tester:update(999, {{'=', 2, 'B'}})`` |br| The "
"first argument is ``tester``, that is, the affected space is ``tester``. The "
"second argument is ``999``, that is, the affected tuple is identified by primary "
"key value = 999. The third argument is ``=``, that is, there is one operation — "
"*assignment to a field*. The fourth argument is ``2``, that is, the affected "
"field is ``field[2]``. The fifth argument is ``'B'``, that is, ``field[2]`` "
"contents change to ``'B'``. Therefore, after this update, ``field[1]`` = ``999`` "
"and ``field[2]`` = ``'B'``."
msgstr ""

#: ../book/box/box_space.rst:552
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'B'}})`` |br| the "
"arguments are the same, except that the key is passed as a Lua table (inside "
"braces). This is unnecessary when the primary key has only one field, but would "
"be necessary if the primary key had more than one field. Therefore, after this "
"update, ``field[1]`` = ``999`` and ``field[2]`` = ``'B'`` (no change)."
msgstr ""

#: ../book/box/box_space.rst:559
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 3, 1}})`` |br| the "
"arguments are the same, except that the fourth argument is ``3``, that is, the "
"affected field is ``field[3]``. It is okay that, until now, ``field[3]`` has not "
"existed. It gets added. Therefore, after this update, ``field[1]`` = ``999``, "
"``field[2]`` = ``'B'``, ``field[3]`` = ``1``."
msgstr ""

#: ../book/box/box_space.rst:566
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'+', 3, 1}})`` |br| the "
"arguments are the same, except that the third argument is ``'+'``, that is, the "
"operation is addition rather than assignment. Since ``field[3]`` previously "
"contained ``1``, this means we're adding ``1`` to ``1``. Therefore, after this "
"update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``2``."
msgstr ""

#: ../book/box/box_space.rst:574
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'|', 3, 1}, {'=', 2, "
"'C'}})`` |br| the idea is to modify two fields at once. The formats are ``'|'`` "
"and ``=``, that is, there are two operations, OR and assignment. The fourth and "
"fifth arguments mean that ``field[3]`` gets OR'ed with ``1``. The seventh and "
"eighth arguments mean that ``field[2]`` gets assigned ``'C'``. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``'C'``, ``field[3]`` = "
"``3``."
msgstr ""

#: ../book/box/box_space.rst:583
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'#', 2, 1}, {'-', 2, "
"3}})`` |br| The idea is to delete ``field[2]``, then subtract ``3`` from "
"``field[3]``. But after the delete, there is a renumbering, so ``field[3]`` "
"becomes ``field[2]``` before we subtract ``3`` from it, and that's why the "
"seventh argument is ``2``, not ``3``. Therefore, after this update, ``field[1]`` "
"= ``999``, ``field[2]`` = ``0``."
msgstr ""

#: ../book/box/box_space.rst:591
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'XYZ'}})`` |br| "
"we're making a long string so that splice will work in the next example. "
"Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'XYZ'``."
msgstr ""

#: ../book/box/box_space.rst:596
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{':', 2, 2, 1, '!!'}})`` |"
"br| The third argument is ``':'``, that is, this is the example of splice. The "
"fourth argument is ``2`` because the change will occur in ``field[2]``. The "
"fifth argument is 2 because deletion will begin with the second byte. The sixth "
"argument is 1 because the number of bytes to delete is 1. The seventh argument "
"is ``'!!'``, because ``'!!'`` is to be added at this position. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."
msgstr ""

#: ../book/box/box_space.rst:609
msgid "Update or insert a tuple."
msgstr ""

#: ../book/box/box_space.rst:611
msgid ""
"If there is an existing tuple which matches the key fields of ``tuple_value``, "
"then the request has the same effect as :ref:`space_object:update() <box_space-"
"update>` and the ``{{operator, field_no, value}, ...}`` parameter is used. If "
"there is no existing tuple which matches the key fields of ``tuple_value``, then "
"the request has the same effect as :ref:`space_object:insert() <box_space-"
"insert>` and the ``{tuple_value}`` parameter is used. However, unlike ``insert`` "
"or ``update``, ``upsert`` will not read a tuple and perform error checks before "
"returning -- this is a design feature which enhances throughput but requires "
"more caution on the part of the user."
msgstr ""

#: ../book/box/box_space.rst:621
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :samp:`{tuple_value}` (type = Lua table or scalar) = field "
"values, must be passed as a Lua table; :codeitalic:`{operator, field_no, value}` "
"(type = Lua table) = a group of arguments for each operation, indicating what "
"the operation is, what field the operation will apply to, and what value will be "
"applied. The field number can be negative, meaning the position from the end of "
"the tuple (#tuple + negative field number + 1)."
msgstr ""

#: ../book/box/box_space.rst:630
msgid "null."
msgstr ""

#: ../book/box/box_space.rst:632
msgid ""
"Possible errors: it is illegal to modify a primary-key field. It is illegal to "
"use upsert with a space that has a unique secondary index."
msgstr ""

#: ../book/box/box_space.rst:635
msgid ""
"**Complexity factors:** Index size, Index type, number of indexes accessed, WAL "
"settings."
msgstr ""

#: ../book/box/box_space.rst:640
msgid "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"
msgstr ""

#: ../book/box/box_space.rst:648
msgid "Delete a tuple identified by a primary key."
msgstr ""

#: ../book/box/box_space.rst:650
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>` :codeitalic:`key` (type = Lua table or scalar) = key to be "
"matched against the index key, which may be multi-part."
msgstr ""

#: ../book/box/box_space.rst:654
msgid "the deleted tuple"
msgstr ""

#: ../book/box/box_space.rst:657
msgid "**Complexity Factors:** Index size, Index type"
msgstr ""

#: ../book/box/box_space.rst:659
msgid ""
"Note re storage engine: vinyl will return ``nil``, rather than the deleted tuple."
msgstr ""

#: ../book/box/box_space.rst:663
msgid ""
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected unsigned'\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:682
msgid ""
"Ordinal space number. Spaces can be referenced by either name or number. Thus, "
"if space ``tester`` has ``id = 800``, then ``box.space.tester:insert{0}`` and "
"``box.space[800]:insert{0}`` are equivalent requests."
msgstr ""

#: ../book/box/box_space.rst:691
msgid ""
"tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:702
msgid ""
"Whether or not this space is enabled. The value is ``false`` if the space has no "
"index."
msgstr ""

#: ../book/box/box_space.rst:711
msgid ""
"The required field count for all tuples in this space. The field_count can be "
"set initially with:"
msgstr ""

#: ../book/box/box_space.rst:717
msgid ""
"box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"
msgstr ""

#: ../book/box/box_space.rst:723
msgid "The default value is ``0``, which means there is no required field count."
msgstr ""

#: ../book/box/box_space.rst:729
msgid ""
"tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:738
msgid ""
"A container for all defined indexes. There is a Lua object of type :ref:`box."
"index <box_index>` with methods to search tuples and iterate over them in "
"predefined order."
msgstr ""

#: ../book/box/box_space.rst:748
msgid ""
"tarantool> #box.space.tester.index\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:763
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :codeitalic:`key` (type = Lua table or scalar) = key to be "
"matched against the primary index key, which may be multi-part; :codeitalic:"
"`iterator` = comparison method."
msgstr ""

#: ../book/box/box_space.rst:767
msgid "Number of tuples."
msgstr ""

#: ../book/box/box_space.rst:771
msgid ""
"tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:784
msgid "Number of tuples in the space."
msgstr ""

#: ../book/box/box_space.rst:788
msgid ""
"tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:795
msgid ""
"Note re storage engine: vinyl does not support ``len()``.  One possible "
"workaround is to say ``#select(...)``."
msgstr ""

#: ../book/box/box_space.rst:802
msgid "Deletes all tuples. ."
msgstr ""

#: ../book/box/box_space.rst:806
msgid "**Complexity Factors:** Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../book/box/box_space.rst:812
msgid ""
"Note that ``truncate`` must be called only by the user who created the space OR "
"under a `setuid` function created by that user. Read more about `setuid` "
"functions :ref:`here <authentication-funcs>`"
msgstr ""

#: ../book/box/box_space.rst:816
msgid "Note re storage engine: vinyl does not support ``truncate()``."
msgstr ""

#: ../book/box/box_space.rst:820
msgid ""
"tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:834
msgid ""
"Insert a new tuple using an auto-increment primary key. The space specified by "
"space_object must have an ``unsigned`` or ``integer`` or ``numeric`` primary key "
"index of type ``TREE``. The primary-key field will be incremented before the "
"insert."
msgstr ""

#: ../book/box/box_space.rst:838
msgid "Note re storage engine: vinyl does not support ``auto_increment()``."
msgstr ""

#: ../book/box/box_space.rst:840
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :codeitalic:`field-value(s)` (type = Lua table or scalar) = "
"tuple's fields, other than the primary-key field."
msgstr ""

#: ../book/box/box_space.rst:849
msgid ""
"Possible errors: index has wrong type or primary-key indexed field is not a "
"number."
msgstr ""

#: ../book/box/box_space.rst:853
msgid ""
"tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:868
msgid "A helper function to prepare for iterating over all tuples in a space."
msgstr ""

#: ../book/box/box_space.rst:872
msgid ""
"function which can be used in a for/end loop. Within the loop, a value is "
"returned for each iteration."
msgstr ""

#: ../book/box/box_space.rst:877
msgid ""
"tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- index 'X' has default parts {1, 'unsigned'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:908
msgid ""
"``_schema`` is a system tuple set. Its single tuple contains these fields: "
"``'version', major-version-number, minor-version-number``."
msgstr ""

#: ../book/box/box_space.rst:913
msgid ""
"The following function will display all fields in all tuples of ``_schema``:"
msgstr ""

#: ../book/box/box_space.rst:915
msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._schema:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      line = line .. v[i] .. ' '\n"
"      i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../book/box/box_space.rst:932 ../book/box/box_space.rst:976
#: ../book/box/box_space.rst:1071
msgid "Here is what ``example()`` returns in a typical installation:"
msgstr ""

#: ../book/box/box_space.rst:934
msgid ""
"tarantool> example()\n"
"---\n"
"- - 'cluster 1ec4e1f8-8f1b-4304-bb22-6c47ce0cf9c6 '\n"
"  - 'max_id 520 '\n"
"  - 'version 1 7 0 '\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:947
msgid ""
"``_space`` is a system tuple set. Its tuples contain these fields: ``id``, "
"``owner`` (= id of user who owns the space), ``name``, ``engine``, "
"``field_count``, ``flags`` (e.g. temporary), ``format``. These fields are "
"established by :ref:`space.create() <box_schema-space_create>`."
msgstr ""

#: ../book/box/box_space.rst:955
msgid ""
"The following function will display all simple fields in all tuples of "
"``_space``."
msgstr ""

#: ../book/box/box_space.rst:957
msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../book/box/box_space.rst:978
msgid ""
"tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin vinyl 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:999
msgid ""
"The following requests will create a space using ``box.schema.space.create`` "
"with a ``format`` clause. Then it retrieves the _space tuple for the new space. "
"This illustrates the typical use of the ``format`` clause, it shows the "
"recommended names and data types for the fields."
msgstr ""

#: ../book/box/box_space.rst:1005
msgid ""
"tarantool> box.schema.space.create('TM', {\n"
"         >   id = 12345,\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field_1\"},\n"
"         >     [2] = {[\"type\"] = \"unsigned\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 12345\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(12345)\n"
"---\n"
"- - [12345, 1, 'TM', 'memtx', 0, {}, [{'name': 'field_1'}, {'type': "
"'unsigned'}]]\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:1034
msgid ""
"``_index`` is a system tuple set. Its tuples contain these fields: ``id`` (= id "
"of space), ``iid`` (= index number within space), ``name``, ``type``, ``opts`` "
"(e.g. unique option), [``tuple-field-no``, ``tuple-field-type`` ...]."
msgstr ""

#: ../book/box/box_space.rst:1039
msgid ""
"The following function will display all fields in all tuples of ``_index``: "
"(notice that the fifth field gets special treatment as a map value and the sixth "
"or later fields get special treatment as arrays):"
msgstr ""

#: ../book/box/box_space.rst:1043
msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line, value\n"
"  for k, v in box.space._index:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"     while v[i] ~= nil do\n"
"      if i < 5 then\n"
"        value = v[i]\n"
"        end\n"
"      if i == 5 then\n"
"        if v[i].unique == true then\n"
"          value = 'true'\n"
"          end\n"
"        end\n"
"      if i > 5 then\n"
"        value = v[i][1][1] .. ' ' .. v[i][1][2]\n"
"        end\n"
"      line = line .. value .. ' '\n"
"      i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"    end\n"
"  return ta\n"
"end"
msgstr ""

#: ../book/box/box_space.rst:1073
msgid ""
"tarantool> example()\n"
"---\n"
"- - '272 0 primary tree true 0 str '\n"
"  - '280 0 primary tree true 0 num '\n"
"  - '280 1 owner tree tree 1 num '\n"
"  - '280 2 name tree true 2 str '\n"
"  - '281 0 primary tree true 0 num '\n"
"  - '281 1 owner tree tree 1 num '\n"
"  - '281 2 name tree true 2 str '\n"
"  - '288 0 primary tree true 0 num '\n"
"  - '288 2 name tree true 0 num '\n"
"  - '289 0 primary tree true 0 num '\n"
"  - '289 2 name tree true 0 num '\n"
"  - '296 0 primary tree true 0 num '\n"
"  - '296 1 owner tree tree 1 num '\n"
"  - '296 2 name tree true 2 str '\n"
"  - '297 0 primary tree true 0 num '\n"
"  - '297 1 owner tree tree 1 num '\n"
"  - '297 2 name tree true 2 str '\n"
"  - '304 0 primary tree true 0 num '\n"
"  - '304 1 owner tree tree 1 num '\n"
"  - '304 2 name tree true 2 str '\n"
"  - '305 0 primary tree true 0 num '\n"
"  - '305 1 owner tree tree 1 num '\n"
"  - '305 2 name tree true 2 str '\n"
"  - '312 0 primary tree true 1 num '\n"
"  - '312 1 owner tree tree 0 num '\n"
"  - '312 2 object tree tree 2 str '\n"
"  - '313 0 primary tree true 1 num '\n"
"  - '313 1 owner tree tree 0 num '\n"
"  - '313 2 object tree tree 2 str '\n"
"  - '320 0 primary tree true 0 num '\n"
"  - '320 1 uuid tree true 1 str '\n"
"  - '512 0 primary tree true 0 num '\n"
"  - '513 0 primary tree true 0 num '\n"
"  - '516 0 primary tree true 0 STR '\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:1117
msgid ""
"``_user`` is a system tuple set for support of the :ref:`authorization feature "
"<authentication>`."
msgstr ""

#: ../book/box/box_space.rst:1124
msgid ""
"``_priv`` is a system tuple set for support of the :ref:`authorization feature "
"<authentication>`."
msgstr ""

#: ../book/box/box_space.rst:1131
msgid ""
"``_cluster`` is a system tuple set for support of the :ref:`replication feature "
"<index-box_replication>`."
msgstr ""

#: ../book/box/box_space.rst:1138
msgid ""
"``_func`` is a system tuple set with function tuples made by :ref:`box.schema."
"func.create <box_schema-func_create>`."
msgstr ""

#: ../book/box/box_space.rst:1143
msgid "Example: use box.space functions to read _space tuples"
msgstr ""

#: ../book/box/box_space.rst:1145
msgid ""
"This function will illustrate how to look at all the spaces, and for each "
"display: approximately how many tuples it contains, and the first field of its "
"first tuple. The function uses Tarantool ``box.space`` functions ``len()`` and "
"``pairs()``. The iteration through the spaces is coded as a scan of the "
"``_space`` system tuple set, which contains metadata. The third field in "
"``_space`` contains the space name, so the key instruction ``space_name = v[3]`` "
"means ``space_name`` is the ``space_name`` field in the tuple of ``_space`` that "
"we've just fetched with ``pairs()``. The function returns a table:"
msgstr ""

#: ../book/box/box_space.rst:1155
msgid ""
"function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../book/box/box_space.rst:1179
msgid "And here is what happens when one invokes the function:"
msgstr ""

#: ../book/box/box_space.rst:1181
msgid ""
"tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:1201
msgid "Example: use box.space functions to organize a _space tuple"
msgstr ""

#: ../book/box/box_space.rst:1203
msgid ""
"The objective is to display field names and field types of a system space -- "
"using metadata to find metadata."
msgstr ""

#: ../book/box/box_space.rst:1206
msgid "To begin: how can one select the _space tuple that describes _space?"
msgstr ""

#: ../book/box/box_space.rst:1208
msgid ""
"A simple way is to look at the constants in box.schema, which tell us that there "
"is an item named SPACE_ID == 288, so these statements will retrieve the correct "
"tuple: |br| :codenormal:`box.space._space:select{288}` |br| or |br| :codenormal:"
"`box.space._space:select{box.schema.SPACE_ID}` |br|"
msgstr ""

#: ../book/box/box_space.rst:1215
msgid ""
"Another way is to look at the tuples in box.space._index, which tell us that "
"there is a secondary index named 'name' for space number 288, so this statement "
"also will retrieve the correct tuple: |br| :codenormal:`box.space._space.index."
"name:select{'_space'}`"
msgstr ""

#: ../book/box/box_space.rst:1220
msgid ""
"However, the retrieved tuple is not easy to read: |br| :codenormal:`tarantool>` :"
"codebold:`box.space._space.index.name:select{'_space'}` |br| :codenormal:`---` |"
"br| :codenormal:`- - [280, 1, '_space', 'memtx', 0, '', [{'name': 'id',` |br| |"
"nbsp| |nbsp| |nbsp| :codenormal:`'type': 'num'}, {'name': 'owner','type': 'num'},"
"` |br| |nbsp| |nbsp| |nbsp| :codenormal:`{'name': 'name','type': 'str'}, "
"{'name': 'engine',` |br| |nbsp| |nbsp| |nbsp| :codenormal:`'type': 'str'},"
"{'name': 'field_count', 'type': 'num'},` |br| |nbsp| |nbsp| |nbsp| :codenormal:"
"`{'name': 'flags','type': 'str'}, {'name': 'format',` |br| |nbsp| |nbsp| |nbsp| :"
"codenormal:`'type': '*'}]]` |br| |nbsp| |nbsp| |nbsp| :codenormal:`...`"
msgstr ""

#: ../book/box/box_space.rst:1231
msgid ""
"It looks disorganized because field number 7 has been formatted with recommended "
"names and data types. How can one get those specific sub-fields? Since it's "
"visible that field number 7 is an array of maps, this `for` loop will do the "
"organizing: |br| :codenormal:`local tuple_of_space, field_name, field_type` |"
"br| :codenormal:`tuple_of_space = box.space._space.index.name:select{'_space'}"
"[1]` |br| :codenormal:`for i = 1, #tuple_of_space[7], 1` |br| :codenormal:`do` |"
"br| |nbsp| |nbsp| |nbsp| :codenormal:`field_name = tuple_of_space[7][i]['name']` "
"|br| |nbsp| |nbsp| |nbsp| :codenormal:`field_type = tuple_of_space[7][i]"
"['type']` |br| |nbsp| |nbsp| |nbsp| :codenormal:`print(field_name .. ',' .."
"field_type)` |br| :codenormal:`end`"
msgstr ""

#: ../book/box/box_space.rst:1245
msgid ""
"And here is what happens when one executes the `for` loop: |br| :codenormal:`id,"
"num` |br| :codenormal:`owner,num` |br| :codenormal:`name,str` |br| :codenormal:"
"`engine,str` |br| :codenormal:`field_count,num` |br| :codenormal:`flags,str` |"
"br| :codenormal:`format,*`"
msgstr ""

#: ../book/box/box_tuple.rst:30
msgid "Submodule `box.tuple`"
msgstr "Вложенный модуль `box.tuple`"

#: ../book/box/box_tuple.rst:34
msgid ""
"The ``box.tuple`` submodule provides read-only access for the ``tuple`` userdata "
"type. It allows, for a single tuple: selective retrieval of the field contents, "
"retrieval of information about size, iteration over all the fields, and "
"conversion to a Lua table."
msgstr ""

#: ../book/box/box_tuple.rst:43
msgid ""
"Construct a new tuple from either a scalar or a Lua table. Alternatively, one "
"can get new tuples from tarantool's :ref:`select <box_space-select>` or :ref:"
"`insert <box_space-insert>` or :ref:`replace <box_space-replace>` or :ref:"
"`update <box_space-update>` requests, which can be regarded as statements that "
"do ``new()`` implicitly."
msgstr ""

#: ../book/box/box_tuple.rst:50
msgid "the value that will become the tuple contents."
msgstr ""

#: ../book/box/box_tuple.rst:52
msgid "a new tuple"
msgstr ""

#: ../book/box/box_tuple.rst:55
msgid ""
"In the following example, ``x`` will be a new table object containing one tuple "
"and ``t`` will be a new tuple object. Saying ``t`` returns the entire tuple "
"``t``."
msgstr ""

#: ../book/box/box_tuple.rst:61
msgid ""
"tarantool> x = box.space.tester:insert{\n"
"         >   33,\n"
"         >   tonumber('1'),\n"
"         >   tonumber64('2')\n"
"         > }:totable()\n"
"---\n"
"...\n"
"tarantool> t = box.tuple.new{'abc', 'def', 'ghi', 'abc'}\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- ['abc', 'def', 'ghi', 'abc']\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:82
msgid ""
"The ``#`` operator in Lua means \"return count of components\". So, if ``t`` is "
"a tuple instance, ``#t`` will return the number of fields."
msgstr ""

#: ../book/box/box_tuple.rst:87
msgid ""
"In the following example, a tuple named ``t`` is created and then the number of "
"fields in ``t`` is returned."
msgstr ""

#: ../book/box/box_tuple.rst:90
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> #t\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:102
msgid ""
"If ``t`` is a tuple instance, ``t:bsize()`` will return the number of bytes in "
"the tuple. It is useful to check this number when making changes to data, "
"because there is a fixed maximum: one megabyte. Every field has one or more "
"\"length\" bytes preceding the actual contents, so ``bsize()`` returns a value "
"which is slightly greater than the sum of the lengths of the contents."
msgstr ""

#: ../book/box/box_tuple.rst:112
msgid ""
"In the following example, a tuple named ``t`` is created which has three fields, "
"and for each field it takes one byte to store the length and three bytes to "
"store the contents, and a bit for overhead, so ``bsize()`` returns ``3*(1+3)+1``."
msgstr ""

#: ../book/box/box_tuple.rst:117
msgid ""
"tarantool> t = box.tuple.new{'aaa', 'bbb', 'ccc'}\n"
"---\n"
"...\n"
"tarantool> t:bsize()\n"
"---\n"
"- 13\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:129
msgid ""
"If ``t`` is a tuple instance, ``t[field-number]`` will return the field numbered "
"field-number in the tuple. The first field is ``t[1]``."
msgstr ""

#: ../book/box/box_tuple.rst:132
msgid "field value."
msgstr ""

#: ../book/box/box_tuple.rst:133
msgid "lua-value"
msgstr ""

#: ../book/box/box_tuple.rst:135
msgid ""
"In the following example, a tuple named ``t`` is created and then the second "
"field in ``t`` is returned."
msgstr ""

#: ../book/box/box_tuple.rst:138
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> t[2]\n"
"---\n"
"- Fld#2\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:151
msgid ""
"If ``t`` is a tuple instance, ``t:find(search-value)`` will return the number of "
"the first field in ``t`` that matches the search value, and ``t:findall(search-"
"value [, search-value ...])`` will return numbers of all fields in ``t`` that "
"match the search value. Optionally one can put a numeric argument ``field-"
"number`` before the search-value to indicate “start searching at field number "
"``field-number``.”"
msgstr ""

#: ../book/box/box_tuple.rst:158
msgid "the number of the field in the tuple."
msgstr ""

#: ../book/box/box_tuple.rst:161
msgid ""
"In the following example, a tuple named ``t`` is created and then: the number of "
"the first field in ``t`` which matches 'a' is returned, then the numbers of all "
"the fields in ``t`` which match 'a' are returned, then the numbers of all the "
"fields in t which match 'a' and are at or after the second field are returned."
msgstr ""

#: ../book/box/box_tuple.rst:167
msgid ""
"tarantool> t = box.tuple.new{'a', 'b', 'c', 'a'}\n"
"---\n"
"...\n"
"tarantool> t:find('a')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> t:findall('a')\n"
"---\n"
"- 1\n"
"- 4\n"
"...\n"
"tarantool> t:findall(2, 'a')\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:188
msgid ""
"If ``t`` is a tuple instance, :samp:`t:transform({start-field-number},{fields-to-"
"remove})` will return a tuple where, starting from field ``start-field-number``, "
"a number of fields (``fields-to-remove``) are removed. Optionally one can add "
"more arguments after ``fields-to-remove`` to indicate new values that will "
"replace what was removed."
msgstr ""

#: ../book/box/box_tuple.rst:194
msgid "base 1, may be negative"
msgstr ""

#: ../book/box/box_tuple.rst:200
msgid ""
"In the following example, a tuple named ``t`` is created and then, starting from "
"the second field, two fields are removed but one new one is added, then the "
"result is returned."
msgstr ""

#: ../book/box/box_tuple.rst:204
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:transform(2, 2, 'x')\n"
"---\n"
"- ['Fld#1', 'x', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:216
msgid ""
"If ``t`` is a tuple instance, ``t:unpack()`` will return all fields, ``t:"
"unpack(1)`` will return all fields starting with field number 1, ``t:"
"unpack(1,5)`` will return all fields between field number 1 and field number 5."
msgstr ""

#: ../book/box/box_tuple.rst:220
msgid "field(s) from the tuple."
msgstr ""

#: ../book/box/box_tuple.rst:221
msgid "lua-value(s)"
msgstr ""

#: ../book/box/box_tuple.rst:223
msgid ""
"In the following example, a tuple named ``t`` is created and then all its fields "
"are selected, then the result is returned."
msgstr ""

#: ../book/box/box_tuple.rst:226
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:unpack()\n"
"---\n"
"- Fld#1\n"
"- Fld#2\n"
"- Fld#3\n"
"- Fld#4\n"
"- Fld#5\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:242
msgid ""
"In Lua, ``lua-table-value:pairs()`` is a method which returns: ``function``, "
"``lua-table-value``, ``nil``. Tarantool has extended this so that ``tuple-value:"
"pairs()`` returns: ``function``, ``tuple-value``, ``nil``. It is useful for Lua "
"iterators, because Lua iterators traverse a value's components until an end "
"marker is reached."
msgstr ""

#: ../book/box/box_tuple.rst:248
msgid "function, tuple-value, nil"
msgstr ""

#: ../book/box/box_tuple.rst:249
msgid "function, lua-value, nil"
msgstr ""

#: ../book/box/box_tuple.rst:251
msgid ""
"In the following example, a tuple named ``t`` is created and then all its fields "
"are selected using a Lua for-end loop."
msgstr ""

#: ../book/box/box_tuple.rst:254
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in t:pairs() do\n"
"         >   tmp = tmp .. v\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Fld#1Fld#2Fld#3Fld#4Fld#5\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:276
msgid ""
"This function updates a tuple which is not in a space. Compare the function :"
"code:`box.space.`:samp:`{space-name}`:code:`:update{`:samp:`{key}, {format},` :"
"code:`{`:samp:`{field_number}, {value}`:code:`}...)`, which updates a tuple in a "
"space."
msgstr ""

#: ../book/box/box_tuple.rst:280
msgid ""
"Parameters: briefly: ``format`` indicates the type of update operation such as "
"'``=``' for 'assign new value', ``field_number`` indicates the field number to "
"change such as 2 for field number 2, ``value`` indicates the string which "
"operates on the field such as 'B' for a new assignable value = 'B'."
msgstr ""

#: ../book/box/box_tuple.rst:285
msgid ""
"For details: see the description for ``format``, ``field_number``, and ``value`` "
"in the section :ref:`box.space.space-name:update{key, format, {field_number, "
"value}...) <box_space-update>`."
msgstr ""

#: ../book/box/box_tuple.rst:288
msgid "new tuple"
msgstr ""

#: ../book/box/box_tuple.rst:291
msgid ""
"In the following example, a tuple named ``t`` is created and then its second "
"field is updated to equal 'B'."
msgstr ""

#: ../book/box/box_tuple.rst:294
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:update({{'=',2,'B'}})\n"
"---\n"
"- ['Fld#1', 'B', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:308
msgid ""
"This function will illustrate how to convert tuples to/from Lua tables and lists "
"of scalars:"
msgstr ""

#: ../book/box/box_tuple.rst:311
msgid ""
"tuple = box.tuple.new({scalar1, scalar2, ... scalar_n}) -- scalars to tuple\n"
"lua_table = {tuple:unpack()}                            -- tuple to Lua table\n"
"scalar1, scalar2, ... scalar_n = tuple:unpack()         -- tuple to scalars\n"
"tuple = box.tuple.new(lua_table)                        -- Lua table to tuple"
msgstr ""

#: ../book/box/box_tuple.rst:318
msgid ""
"Then it will find the field that contains 'b', remove that field from the tuple, "
"and display how many bytes remain in the tuple. The function uses Tarantool "
"``box.tuple`` functions ``new()``, ``unpack()``, ``find()``, ``transform()``, "
"``bsize()``."
msgstr ""

#: ../book/box/box_tuple.rst:323
msgid ""
"function example()\n"
"  local tuple1, tuple2, lua_table_1, scalar1, scalar2, scalar3, field_number\n"
"  local luatable1 = {}\n"
"  tuple1 = box.tuple.new({'a', 'b', 'c'})\n"
"  luatable1 = {tuple1:unpack()}\n"
"  scalar1, scalar2, scalar3 = tuple1:unpack()\n"
"  tuple2 = box.tuple.new(luatable1)\n"
"  field_number = tuple2:find('b')\n"
"  tuple2 = tuple2:transform(field_number, 1)\n"
"  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()\n"
"end"
msgstr ""

#: ../book/box/box_tuple.rst:339
msgid ""
"tarantool> example()\n"
"---\n"
"- tuple2 =\n"
"- ['a', 'c']\n"
"- ' # of bytes = '\n"
"- 5\n"
"..."
msgstr ""

#: ../book/box/index.rst:30
msgid "Database"
msgstr "Функционал СУБД"

#: ../book/box/index.rst:34
msgid "Data model"
msgstr "Модель данных"

#: ../book/box/index.rst:36
msgid ""
"This section describes how Tarantool stores values and what operations with data "
"it supports."
msgstr ""
"В этом разделе описывается то, как в Tarantool'е организовано хранение данных и "
"какие операции с данным он поддерживает."

#: ../book/box/index.rst:39
msgid ""
"If you tried out the :ref:`Starting Tarantool and making your first database "
"<user_guide_getting_started-first_database>` exercise from the last chapter, "
"then your database looks like this:"
msgstr ""
"Если вы уже выполнили тестовое задание из раздела :ref:`Первичный запуск "
"Tarantool'а и создание базы данных <user_guide_getting_started-first_database>` "
"в предыдущей главе, то ваша база данных имеет следующий вид:"

#: ../book/box/index.rst:43
msgid ""
"+--------------------------------------------+\n"
"|                                            |\n"
"| SPACE 'tester'                             |\n"
"| +----------------------------------------+ |\n"
"| |                                        | |\n"
"| | TUPLE SET 'tester'                     | |\n"
"| | +-----------------------------------+  | |\n"
"| | | Tuple: [ 1 ]                      |  | |\n"
"| | | Tuple: [ 2, 'Music' ]             |  | |\n"
"| | | Tuple: [ 3, 'length', 93 ]        |  | |\n"
"| | +-----------------------------------+  | |\n"
"| |                                        | |\n"
"| | INDEX 'primary'                        | |\n"
"| | +-----------------------------------+  | |\n"
"| | | Key: 1                            |  | |\n"
"| | | Key: 2                            |  | |\n"
"| | | Key: 3                            |  | |\n"
"| | +-----------------------------------+  | |\n"
"| |                                        | |\n"
"| +----------------------------------------+ |\n"
"+--------------------------------------------+"
msgstr ""
"+--------------------------------------------+\n"
"|                                            |\n"
"| ПРОСТРАНСТВО 'tester'                      |\n"
"| +----------------------------------------+ |\n"
"| |                                        | |\n"
"| | НАБОР КОРТЕЖЕЙ 'tester'                | |\n"
"| | +-----------------------------------+  | |\n"
"| | | Кортеж: [ 1 ]                     |  | |\n"
"| | | Кортеж: [ 2, 'Music' ]            |  | |\n"
"| | | Кортеж: [ 3, 'length', 93 ]       |  | |\n"
"| | +-----------------------------------+  | |\n"
"| |                                        | |\n"
"| | ИНДЕКС 'primary'                       | |\n"
"| | +-----------------------------------+  | |\n"
"| | | Ключ: 1                           |  | |\n"
"| | | Ключ: 2                           |  | |\n"
"| | | Ключ: 3                           |  | |\n"
"| | +-----------------------------------+  | |\n"
"| |                                        | |\n"
"| +----------------------------------------+ |\n"
"+--------------------------------------------+"

#: ../book/box/index.rst:69
msgid "Space"
msgstr "Пространство"

#: ../book/box/index.rst:71
msgid "A *space* -- 'tester' in the example -- is a container."
msgstr "*Пространство* с именем 'tester' в нашем примере — это контейнер."

#: ../book/box/index.rst:73
msgid ""
"When Tarantool is being used to store data, there is always at least one space. "
"There can be many spaces. Each space has a unique name specified by the user. "
"Each space has a unique numeric identifier which can be specified by the user "
"but usually is assigned automatically by Tarantool. Spaces always contain one "
"tuple set and one or more indexes."
msgstr ""
"Когда Tarantool используется для хранения данных, то он создает по меньшей мере "
"одно пространство (space). В общем же случае пространств может быть много. "
"Каждое пространство имеет уникальное имя, заданное пользователем, а также "
"уникальный числовой идентификатор, который тоже может быть задан пользователем, "
"но обычно назначается автоматически самим Tarantool'ом. Пространство всегда "
"содержит один набор кортежей и один или более индексов."

#: ../book/box/index.rst:81
msgid "Tuple set"
msgstr "Набор кортежей"

#: ../book/box/index.rst:83
msgid "A *tuple set* -- 'tester' in the example -- is a group of tuples."
msgstr ""
"*Набор кортежей* — в нашем примере он назван 'tester' — это группа кортежей."

#: ../book/box/index.rst:85
msgid ""
"There is always one tuple set in a space. The identifier of a tuple set is the "
"same as the space name -- 'tester' in the example."
msgstr ""
"Каждое пространство всегда содержит один набор кортежей. Идентификатор набора "
"кортежей совпадает с именем самого пространства, в нашем примере — `tester`."

#: ../book/box/index.rst:88
msgid ""
"A tuple fills the same role as a “row” or a “record”, and the components of a "
"tuple (which we call “fields”) fill the same role as a “row column” or “record "
"field”, except that: the fields of a tuple can be composite structures, such as "
"arrays or maps and don't need to have names. That's why there was no need to pre-"
"define the tuple set when creating the space, and that's why each tuple can have "
"a different number of elements. Tuples are stored as `MsgPack`_ arrays."
msgstr ""
"Кортеж (tuple) выполняет ту же роль, что \"строка\" или \"запись\", а компоненты "
"кортежа (его \"полЯ\") выполняют ту же роль, что \"поле столбца, соответствующее "
"данной строке\" или \"поле в записи\" за тем исключением, что поля кортежа могут "
"быть составными (например, они могут быть массивами или отображениями) и им не "
"нужны имена. Поэтому нет необходимости предварительно определять набор кортежей "
"при создании пространства, а каждый кортеж может иметь различное количество "
"элементов. Кортежи хранятся в виде `MsgPack`_-массивов."

#: ../book/box/index.rst:97
msgid ""
"Any given tuple may have any number of fields and the fields may have a variety "
"of types. The identifier of a field is the field's number, base 1. For example "
"“1” can be used in some contexts to refer to the first field of a tuple."
msgstr ""
"Кортеж может иметь любое количество полей, и это могут быть поля разных типов. "
"Идентификатором поля является его номер. Поля нумеруются, начиная с 1. Так, "
"например, “1” может использоваться в некоторых контекстах для обозначения "
"первого поля кортежа."

#: ../book/box/index.rst:101
msgid ""
"When Tarantool returns a tuple value, it surrounds strings with single quotes, "
"separates fields with commas, and encloses the tuple inside square brackets. For "
"example: ``[3, 'length', 93]``."
msgstr ""
"Когда Tarantool возвращает значение кортежа, он берет строки в одинарные "
"кавычки, отделяет поля с запятыми и заключает кортеж в квадратные скобки. "
"Например, ``[ 3, 'length', 93 ]``."

#: ../book/box/index.rst:109
msgid "Index"
msgstr "Индекс"

#: ../book/box/index.rst:111
msgid ""
"An *index* -- 'primary' in the example -- is a group of key values and pointers."
msgstr ""
"*Индекс* — в нашем примере он первичный — это совокупность значений ключей и "
"указателей."

#: ../book/box/index.rst:113
msgid ""
"In order for a tuple set to be useful, there must always be at least one index "
"in a space. There can be many indexes. As with spaces, the user can and should "
"specify the index name, and let Tarantool come up with a unique numeric "
"identifier (the \"index id\"). In our example there is one index and its name is "
"“primary”."
msgstr ""
"Чтобы набором кортежей было можно пользоваться, в пространстве необходим по "
"крайней мере один индекс. Вообще же индексов в пространстве может быть много. "
"Как и в случае с пространствами, пользователь может — и должен — указать имя "
"индекса, а Tarantool подставляет уникальный числовой идентификатор "
"(\"идентификатор индекса\"). В нашем примере всего один индекс с именем "
"“primary”."

#: ../book/box/index.rst:118
#, fuzzy
msgid ""
"An index may be *multi-part*, that is, the user can declare that an index key "
"value is taken from two or more fields in the tuple, in any order. An index may "
"be *unique*, that is, the user can declare that it would be illegal to have the "
"same key value twice. An index may have *one of four types*: HASH which is fast "
"and is best for exact-equality searches with unique keys, TREE which allows "
"partial-key searching and ordered results, BITSET which can be good for searches "
"that contain '=' and multiple ANDed conditions, and RTREE for spatial "
"coordinates. The first index is called the “*primary key*” index and it must be "
"unique; all other indexes are called “secondary” indexes."
msgstr ""
"Индекс может быть *составным*. Значение ключа в таком индексе составляется из "
"значений двух или более полей кортежа, причем они могут браться в любом порядке. "
"Индекс может быть *уникальным*. В этом случае один и тот же ключ не может "
"встречаться в индексе более одного раза. Также индекс может быть одного из "
"следующих *четырех типов*: HASH (он самый быстрый и самый экономный в плане "
"использования памяти, но он должен быть уникальным), TREE (он позволяет делать "
"поиск по части ключа и получать отсортированные результаты), BITSET (он хорош "
"для поиска с '=' и больших количеством AND-условий) или RTREE (для "
"пространственных координат). Первый индекс называется “*первичным*” (primary) и "
"должен быть уникальным. Все остальные индексы называются "
"“вторичными” (secondary)."

#: ../book/box/index.rst:128
msgid ""
"An index definition may include identifiers of tuple fields and their expected "
"types. The allowed types for indexed fields are:"
msgstr ""
"Индекс может содержать идентификаторы полей кортежа и типы данных для этих "
"полей. Индексированные поля могут содержать данные следующих типов:"

#: ../book/box/index.rst:131
msgid "``unsigned`` (unsigned integer between 0 and 18,446,744,073,709,551,615)"
msgstr ""
"``unsigned`` (беззнаковое целое число в диапазоне от 0 до "
"18,446,744,073,709,551,615)"

#: ../book/box/index.rst:132
msgid ""
"``integer`` (signed integer between -9,223,372,036,854,775,808 and "
"9,223,372,036,854,775,807)"
msgstr ""
"``integer`` (знаковое целое число в диапазоне от -9,223,372,036,854,775,808 до "
"9,223,372,036,854,775,807)"

#: ../book/box/index.rst:133
msgid "``number`` (unsigned integer or signed integer or floating-point value)"
msgstr ""
"``number`` (беззнаковое целое число, либо знаковое целое число, либо число с "
"плавающей точкой)"

#: ../book/box/index.rst:134
msgid "``string`` (string, any sequence of octets)"
msgstr "``string`` (строковое значение, т.е. любая последовательность октетов)"

#: ../book/box/index.rst:135
msgid "``scalar`` (boolean or number or string)"
msgstr "``scalar`` (логическое значение, либо число, либо строковое значение)"

#: ../book/box/index.rst:136
msgid ""
"``array`` (a series of numbers for use with :ref:`RTREE indexes <box_index-"
"rtree>`)"
msgstr ""
"``array`` (последовательность чисел для :ref:`RTREE-индексов <box_index-rtree>`)"

#: ../book/box/index.rst:138
msgid "Take our example, which has the request:"
msgstr "В рамках нашего примера рассмотрим следующий запрос:"

#: ../book/box/index.rst:140
msgid ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"
msgstr ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"

#: ../book/box/index.rst:144
msgid ""
"The effect is that, for all tuples in tester, field number 1 must exist and must "
"contain an unsigned integer."
msgstr ""
"В результате у всех кортежей в пространстве `tester` должно быть поле с номером "
"1, содержащее беззнаковое целое число."

#: ../book/box/index.rst:147
#, fuzzy
msgid ""
"Space definitions and index definitions are stored permanently in system spaces. "
"It is possible to add, drop, or alter the definitions at runtime, with some "
"restrictions. See syntax details for defining spaces and indexes in :ref:"
"`reference on Tarantool's \"box\" module <index-box_library>`."
msgstr ""
"Определения пространств и индексов хранятся в системных пространствах. Можно (с "
"некоторыми ограничениями) на ходу добавлять, удалять и менять эти определения. "
"Правила синтаксиса в определениях пространств и индексов даны в разделе :ref:"
"`Библиотека \"box\" <index-box_library>`."

#: ../book/box/index.rst:154
msgid "Data types"
msgstr "Типы данных"

#: ../book/box/index.rst:156
msgid "Tarantool can work with numbers, strings, booleans, tables, and userdata."
msgstr ""
"Tarantool работает с числами (numbers), строками (strings), логическими "
"значениями (booleans), таблицами (tables) и пользовательскими типами данных "
"(userdata)."

#: ../book/box/index.rst:159
msgid "General type"
msgstr "Общий тип"

#: ../book/box/index.rst:159
msgid "Specific type"
msgstr "Особый тип"

#: ../book/box/index.rst:159
msgid "What Lua ``type()`` would return"
msgstr "Результат Lua type()"

#: ../book/box/index.rst:161 ../book/box/index.rst:163 ../book/box/index.rst:165
#: ../book/box/index.rst:167
msgid "scalar"
msgstr "scalar"

#: ../book/box/index.rst:161
msgid "\"`number`_\""
msgstr "\"`number`_\""

#: ../book/box/index.rst:161
msgid "12345"
msgstr "12345"

#: ../book/box/index.rst:163
msgid "\"`string`_\""
msgstr "\"`string`_\""

#: ../book/box/index.rst:163
msgid "'A B C'"
msgstr "'A B C'"

#: ../book/box/index.rst:165
msgid "\"`boolean`_\""
msgstr "\"`boolean`_\""

#: ../book/box/index.rst:165
msgid "true"
msgstr "true"

#: ../book/box/index.rst:167
msgid "\"`nil`_\""
msgstr "\"`nil`_\""

#: ../book/box/index.rst:169 ../book/box/index.rst:171
msgid "compound"
msgstr "compound"

#: ../book/box/index.rst:169
msgid "Lua table"
msgstr "Lua table"

#: ../book/box/index.rst:169
msgid "\"`table`_\""
msgstr "\"`table`_\""

#: ../book/box/index.rst:169
msgid "table: 0x410f8b10"
msgstr "table: 0x410f8b10"

#: ../book/box/index.rst:171
msgid "\"`Userdata`_\""
msgstr "\"`Userdata`_\""

#: ../book/box/index.rst:171
msgid "12345: {'A B C'}"
msgstr "12345: {'A B C'}"

#: ../book/box/index.rst:181
#, fuzzy
msgid ""
"In Lua, a *number* is double-precision floating-point, but Tarantool allows both "
"integer and floating-point values. Tarantool will try to store a number as "
"floating-point if the value contains a decimal point or is very large (greater "
"than 100 billion = 1e14), otherwise Tarantool will store it as an integer. To "
"ensure that even very large numbers will be treated as integers, use the :ref:"
"`tonumber64 <other-tonumber64>` function, or the ``LL`` (Long Long) suffix, or "
"the ``ULL`` (Unsigned Long Long) suffix. Here are examples of numbers using "
"regular notation, exponential notation, the ULL suffix, and the tonumber64 "
"function: ``-55``, ``-2.7e+20``, ``100000000000000ULL``, "
"``tonumber64('18446744073709551615')``."
msgstr ""
"В языке Lua тип *number* (число) — это число с плавающей точкой двойной "
"точности, но в Tarantool'е можно использовать как целые числа, так и числа с "
"плавающей запятой. Tarantool по возможности сохраняет числовые значения в виде "
"чисел с плавающей точкой, если числовое значение содержит десятичную запятую или "
"если оно очень велико (более 100 триллионов = 1e14). Если в формате с плавающей "
"точкой сохранить не удается, то Tarantool сохраняет такое значение в виде целого "
"числа. Чтобы даже очень большие величины гарантированно обрабатывались как целые "
"числа, используйте функцию :ref:`tonumber64 <other-tonumber64>`, либо "
"приписывайте в конце суффикс LL (Long Long) или ULL (Unsigned Long Long). Вот "
"примеры записи чисел в различных представлениях (обычном, экспоненциальном, с "
"суффиксом ULL и с использованием функции tonumber64): ``-55``, ``-2.7e+20``, "
"``100000000000000ULL``, ``tonumber64('18446744073709551615')``."

#: ../book/box/index.rst:192
#, fuzzy
msgid ""
"For database storage, Tarantool uses MsgPack rules. Storage is variable-length, "
"so the smallest number requires only one byte but the largest number requires "
"nine bytes. When a field has an 'unsigned' index, all values must be unsigned "
"integers between 0 and 18,446,744,073,709,551,615."
msgstr ""
"Для хранения данных в базе Tarantool использует формат MsgPack. Данные при "
"хранении имеют переменную длину, поэтому для самого маленького числа потребуется "
"только один байт, а самое большее число потребует девять байтов. Если поле имеет "
"индекс 'unsigned', то оно может содержать только целые беззнаковые числа со "
"значениями в диапазоне от 0 до 18,446,744,073,709,551,615."

#: ../book/box/index.rst:197
msgid ""
"A *string* is a variable-length sequence of bytes, usually represented with "
"alphanumeric characters inside single quotes."
msgstr ""
"Тип *string* (строка) — это последовательность байтов, имеющая переменную длину. "
"Как правило, строки представлены в виде алфавитно-числовых символы, заключенных "
"в одинарные кавычки."

#: ../book/box/index.rst:200
msgid "A *boolean* is either ``true`` or ``false``."
msgstr ""
"Тип *boolean* (логический) может иметь только значения ``true`` или ``false``."

#: ../book/box/index.rst:202
msgid ""
"A *nil* type has only one possible value, also called *nil*, but often displayed "
"as *null*. Nils may be compared to values of any types with == (is-equal) or ~= "
"(is-not-equal), but other operations will not work. Nils may not be used in Lua "
"tables; the workaround is to use :ref:`yaml.NULL <yaml-null>` or :ref:`json.NULL "
"<json-null>` or :ref:`msgpack.NULL <msgpack-null>`."
msgstr ""
"Тип *nil* (нулевой) может иметь только одно значение, также называемое *nil*, но "
"часто отображаемое как *null*. Нулевое значение можно сравнивать со значениями "
"любых типов с помощью операторов == (равен) или ~= (не равен), но никакие другие "
"операции для нулевых значений не доступны. Нулевые значения также нельзя "
"использовать в Lua-таблицах; вместо нулевого значения в таком случае можно "
"указать :ref:`yaml.NULL <yaml-null>`, либо :ref:`json.NULL <json-null>`, либо :"
"ref:`msgpack.NULL <msgpack-null>`."

#: ../book/box/index.rst:208
msgid ""
"A *tuple* is returned in YAML format like ``- [120, 'a', 'b', 'c']``. A few "
"functions may return tables with multiple tuples. A scalar may be converted to a "
"tuple with only one field. A Lua table may contain all of a tuple's fields, but "
"not nil."
msgstr ""
"Тип *tuple* возвращается в формате YAML, например ``- [120, 'a', 'b', 'c']``. "
"Некоторые функции могут возвращать таблицы с несколькими кортежами. Скалярная "
"величина может быть конвертирована в кортеж с 1 полем. Lua-таблица может "
"содержать все типы полей, допустимые для кортежей, кроме нулевого типа (nil)."

#: ../book/box/index.rst:213
msgid ""
"Some of the data types may be used in :ref:`indexed fields "
"<details_about_index_field_types>`."
msgstr ""
"Некоторые из этих типов данных подходят для :ref:`индексируемых полей "
"<details_about_index_field_types>`."

#: ../book/box/index.rst:215
msgid "For more tuple examples see :ref:`box.tuple <box_tuple>`."
msgstr ""
"См. также примеры кортежей в разделе про модуль :ref:`box.tuple <box_tuple>`."

#: ../book/box/index.rst:219
msgid "Operations"
msgstr "Операции"

#: ../book/box/index.rst:221
msgid ""
"The basic operations are: the five data-change operations (``insert``, "
"``update``, ``upsert``, ``delete``, ``replace``), and the data-retrieval "
"operation (``select``). There are also minor operations like “ping” which can "
"only be used with the binary protocol. Also, there are :ref:`index iterator "
"<box_index-index_pairs>` operations, which can only be used with Lua code. "
"(Index iterators are for traversing indexes one key at a time, taking advantage "
"of features that are specific to an index type, for example evaluating Boolean "
"expressions when traversing BITSET indexes, or going in descending order when "
"traversing TREE indexes.)"
msgstr ""
"Основные операции — это пять операций для изменения данных (INSERT, UPDATE, "
"UPSERT, DELETE, REPLACE) и одна операция для возвращения данных (SELECT). Также "
"в Tarantool'е поддерживаются второстепенные операции типа PING, которые можно "
"использовать только в рамках бинарного протокола. Кроме того, в Tarantool'е есть "
"операции для :ref:`индекс-итераторов <box_index-index_pairs>`, которые можно "
"использовать только в коде на языке Lua. (Индекс-итераторы нужны для обхода "
"индексов от одного ключа к другому и дают возможность пользоваться "
"преимуществами разных типов индексов, например вычислять значение выражений "
"логического типа при обходе BITSET-индексов или двигаться в порядке убывания "
"значений при обходе TREE-индексов.)"

#: ../book/box/index.rst:231
msgid "Six examples of basic operations:"
msgstr "Шесть примеров основных операций:"

#: ../book/box/index.rst:233
msgid ""
"-- Add a new tuple to tuple set tester.\n"
"-- The first field, field[1], will be 999 (type is unsigned).\n"
"-- The second field, field[2], will be 'Taranto' (type is string).\n"
"tarantool> box.space.tester:insert{999, 'Taranto'}\n"
"\n"
"-- Update the tuple, changing field field[2].\n"
"-- The clause \"{999}\", which has the value to look up in\n"
"-- the index of the tuple's primary-key field, is mandatory\n"
"-- because update() requests must always have a clause that\n"
"-- specifies the primary key, which in this case is field[1].\n"
"-- The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment\n"
"-- will happen to field[2] with the new value.\n"
"tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})\n"
"\n"
"-- Upsert the tuple, changing field field[2] again.\n"
"-- The syntax of upsert is similar to the syntax of update,\n"
"-- but the return value will be different.\n"
"tarantool> box.space.tester:upsert({999, 'Taranted'}, {{'=', 2, 'Tarantism'}})\n"
"\n"
"-- Replace the tuple, adding a new field.\n"
"-- This is also possible with the update() request but\n"
"-- the update() request is usually more complicated.\n"
"tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}\n"
"\n"
"-- Retrieve the tuple.\n"
"-- The clause \"{999}\" is still mandatory, although it does not have to\n"
"-- mention the primary key.\n"
"tarantool> box.space.tester:select{999}\n"
"\n"
"-- Delete the tuple.\n"
"-- Once again the clause to identify the primary-key field is mandatory.\n"
"tarantool> box.space.tester:delete{999}"
msgstr ""
"-- Добавляем новый кортеж в набор кортежей с именем tester.\n"
"-- Первое поле, field[1], будет равно 999 (тип = unsigned).\n"
"-- Второе поле, field[2], будет равно 'Taranto' (тип = string).\n"
"tarantool> box.space.tester:insert{999, 'Taranto'}\n"
"\n"
"-- Обновляем кортеж, меняем значение поля field[2].\n"
"-- Условие \"{999}\", содержащее значение ключа, которое нужно\n"
"-- искать в первичном индексе, построенном по первому полю\n"
"-- кортежа, является обязательным, поскольку запросам update()\n"
"-- всегда требуется условие, определяющее значение первичного\n"
"-- ключа, в данном случае field[1].\n"
"-- Условие \"{{'=', 2, 'Tarantino'}}\" определяет, что полю field[2] нужно \n"
"-- присвоить новое значение.\n"
"tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})\n"
"\n"
"-- Выполняем операцию upsert() для кортежа и снова меняем\n"
"-- значение поля field[2].\n"
"-- Синтаксис запроса upsert() аналогичен синтаксису update(),\n"
"-- но возвращаемые значения у этих запросов разные.\n"
"tarantool> box.space.tester:upsert({999, 'Taranted'}, {{'=', 2, 'Tarantism'}})\n"
"\n"
"-- Производим замену кортежа с помощью replace(), добавляем новое поле.\n"
"-- Это можно сделать и с помощью запроса update(),\n"
"-- но такой вариант часто оказывается более сложным.\n"
"tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}\n"
"\n"
"-- Возвращаем значение кортежа.\n"
"-- Условие \"{999}\" все еще обязательно, хотя оно и не должно\n"
"-- содержать значение первичного ключа.\n"
"tarantool> box.space.tester:select{999}\n"
"\n"
"-- Удаляем кортеж.\n"
"-- Условие, определяющее значение первичного ключа,\n"
"-- снова является обязательным.\n"
"tarantool> box.space.tester:delete{999}"

#: ../book/box/index.rst:268
msgid "How does Tarantool do a basic operation? Let's take this example:"
msgstr ""
"Как Tarantool выполняет основные операции? Давайте рассмотрим это на следующем "
"примере:"

#: ../book/box/index.rst:270
msgid "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../book/box/index.rst:274
msgid "which, for those who know SQL, is equivalent to a statement like"
msgstr "Это аналогично следующему выражению на языке SQL:"

#: ../book/box/index.rst:276
msgid ""
"UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[[1]\" = 3"
msgstr ""
"UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[[1]\" = 3"

#: ../book/box/index.rst:280
#, fuzzy
msgid ""
"If this is happening on a remote client, then the client parses the statement "
"and changes it to a binary-protocol instruction which has already been checked, "
"and which the server can understand without needing to parse everything again. "
"The client ships a packet to the server."
msgstr ""
"Если запрос делается с удаленного клиента, то клиент разбирает введенное "
"выражение, проверяет на корректность и переводит его в формат инструкций "
"бинарного протокола, которые Tarantool-сервер сможет понять без повторного "
"разбора. Затем клиент отправляет всё в виде пакета на сторону сервера."

#: ../book/box/index.rst:285
#, fuzzy
msgid ""
"The server's “transaction processor” thread uses the primary-key index on "
"field[1] to find the location of the tuple in memory. It determines that the "
"tuple can be updated (not much can go wrong when you're merely changing an "
"unindexed field value to something shorter)."
msgstr ""
"Поток, выполняющий обработку транзакций на стороне сервера, использует первичный "
"индекс по полю field[1], чтобы найти нужный кортеж в памяти. Он проверяет, что "
"данный кортеж можно обновить (мы хотим лишь изменить значение не "
"индексированного поля, и вряд ли что-то пойдет не так в таком простом случае)."

#: ../book/box/index.rst:290
#, fuzzy
msgid ""
"The transaction processor thread sends a message to the write-ahead logging "
"(WAL) thread."
msgstr ""
"Поток обработки транзакций посылает сообщение другому потоку, который занимается "
"записью в WAL."

#: ../book/box/index.rst:293
#, fuzzy
msgid ""
"At this point, a *yield* takes place. To know the significance of that -- and "
"it's quite significant -- you have to know a few facts and a few new words."
msgstr ""
"В этот момент происходит *передача управления* (yield). Чтобы понять важность "
"этого события — а оно действительно важно, — нужно пояснить несколько фактов и "
"ввести ряд новых терминов."

#: ../book/box/index.rst:296
msgid "FACT 1:"
msgstr "ФАКТ #1:"

#: ../book/box/index.rst:299
#, fuzzy
msgid ""
"There is only one transaction processor thread. Some people are used to the idea "
"that there can be multiple threads operating on the database, with (say) thread "
"#1 reading row #x while thread #2 writes row #y. With Tarantool no such thing "
"ever happens. Only the transaction processor thread can access the database, and "
"there is only one transaction processor thread for each instance of the server."
msgstr ""
"В Tarantool'е есть только один поток обработки транзакций. Многие люди уже "
"привыкли к мысли, что потоков для обработки данных может быть много (например, "
"поток #1 читает данные из строки #x, в то время как поток #2 записывает данные в "
"столбец #y). В случае с Tarantool'ом такого не происходит. доступ к базе есть "
"только у потока обработки транзакций, и на каждый экземпляр Tarantool'а есть "
"только один такой поток."

#: ../book/box/index.rst:306
msgid "FACT 2:"
msgstr "ФАКТ #2:"

#: ../book/box/index.rst:309
#, fuzzy
msgid ""
"The transaction processor thread can handle many *fibers*. A fiber is a set of "
"computer instructions that may contain \"yield\" signals. The transaction "
"processor thread will execute all computer instructions until a yield, then "
"switch to execute the instructions of a different fiber. Thus (say) the thread "
"reads row #x for the sake of fiber #1, then writes row #y for the sake of fiber "
"#2."
msgstr ""
"Поток обработки транзакций может управлять множеством *файберов*. Файбер — это "
"набор инструкций, среди которых могут быть и сигналы \"передать управление\". "
"Поток обработки транзакций выполняет инструкции, пока не увидит такой сигнал, и "
"тогда он переключается на выполнение инструкций из другого файбера. Например, "
"таким образом поток обработки транзакций сначала выполняет чтение данных из "
"строки #x для файбера #1, а затем выполняет запись в строку #y для файбер #2."

#: ../book/box/index.rst:317
msgid "FACT 3:"
msgstr "ФАКТ #3:"

#: ../book/box/index.rst:320
#, fuzzy
msgid ""
"Yields must happen, otherwise the transaction processor thread would stick "
"permanently on the same fiber. There are :ref:`implicit yields <atomic-"
"the_implicit_yield_rules>`: every data-change operation or network-access causes "
"an implicit yield, and every statement that goes through the tarantool client "
"causes an implicit yield. And there are explicit yields: in a Lua function one "
"can and should add “yield” statements to prevent hogging. This is called "
"*cooperative multitasking*."
msgstr ""
"Без передачи управления не обойтись, т.к. иначе поток обработки транзакций "
"сможет выполнять инструкции только для одного файбера. Передача управления может "
"осуществляться один их двух способов. Первый — это :ref:`неявная передача "
"<atomic-the_implicit_yield_rules>`. Она делается при каждой операции, связанной "
"с изменением данных, при каждом обращении к сетевому соединению, а также при "
"каждом запросе, который передается через Tarantool-клиент. Второй способ "
"передачи управления — это явная передача. Ее можно — и нужно — вызывать внутри "
"Lua-функций с помощью инструкции “yield”, чтобы не допустить захвата процессора "
"одним файбером. Это называется *взаимная многозадачность*."

#: ../book/box/index.rst:327
msgid ""
"Since all data-change operations end with an implicit yield and an implicit "
"commit, and since no data-change operation can change more than one tuple, there "
"is no need for any locking. Consider, for example, a Lua function that does "
"three Tarantool operations:"
msgstr ""
"Поскольку все операции, связанные с изменением данных, заканчиваются неявной "
"передачей управления и неявным коммитом, и поскольку каждая такая операция может "
"затрагивать не более одного кортежа, то не возникает нужды в блокировках. Для "
"примера рассмотрим следующую Lua-функцию, которая осуществляет три операции в "
"Tarantool'е:"

#: ../book/box/index.rst:332
msgid ""
"s:select{999}             -- this does not yield and does not commit\n"
"s:update({...},{{...}})   -- this yields and commits\n"
"s:select{999}             -- this does not yield and does not commit"
msgstr ""
"s:select{999}             -- не происходит ни передачи управления, ни коммита\n"
"s:update({...},{{...}})   -- происходит и передача управления, и коммит\n"
"s:select{999}             -- не происходит ни передачи управления, ни коммита"

#: ../book/box/index.rst:338
msgid ""
"The combination “SELECT plus UPDATE” is an atomic transaction: the function "
"holds a consistent view of the database until the UPDATE ends. For the "
"combination “UPDATE plus SELECT” the view is not consistent, because after the "
"UPDATE the transaction processor thread can switch to another fiber, and delete "
"the tuple that was just updated."
msgstr ""
"Последовательность операций “SELECT + UPDATE” является атомарной транзакцией: "
"функция сохраняет базу данных в согласованном виде, пока не отработает UPDATE. А "
"в случае “UPDATE + SELECT” согласованности нет, поскольку после операции UPDATE "
"поток обработки транзакций может переключится на другой файбер и удалить тот "
"кортеж, что был обновлен в рамках предыдущей операции UPDATE."

#: ../book/box/index.rst:344
msgid ""
"Note re storage engine: vinyl handles yields differently, see :ref:`differences "
"between memtx and vinyl <vinyl_diff>`."
msgstr ""
"Примечание про движок: в движке vinyl передача управления происходит по-другому, "
"см. раздел про :ref:`различия между движками memtx и vinyl <vinyl_diff>`."

#: ../book/box/index.rst:347
msgid "Note re multi-request transactions"
msgstr "Примечание про составные транзакции:"

#: ../book/box/index.rst:349
msgid ""
"There is a way to delay yields. Read about execution atomicity in section :ref:"
"`Transaction control <transaction_control>`."
msgstr ""

#: ../book/box/index.rst:352
msgid ""
"Since locks don't exist, and disk writes only involve the write-ahead log, "
"transactions are usually fast. Also the Tarantool server may not be using up all "
"the threads of a powerful multi-core processor, so advanced users may be able to "
"start a second Tarantool server on the same processor without ill effects."
msgstr ""
"Посколько блокировки не используются, а запись на диск производится только при "
"работе с WAL-файлом, то транзакции в Tarantool'е обычно совершаются быстро. "
"Кроме того, если мы имеем дело с мощным многоядерным процессором, то Tarantool-"
"сервер может задействовать для работы не все потоки такого процессора, и "
"продвинутые пользователи могут безболезненно запускать второй Tarantool-сервер "
"на том же процессоре."

#: ../book/box/index.rst:357
msgid ""
"Additional examples of requests can be found in the Tarantool regression test "
"suite (https://github.com/tarantool/tarantool/tree/1.7/test/box). A complete "
"grammar of supported data-manipulation functions will come later in this chapter."
msgstr ""
"См. также примеры с запросами в регрессионных тестах для Tarantool'а (https://"
"github.com/tarantool/tarantool/tree/1.7/test/box). Полное описание грамматики "
"поддерживаемых в Tarantool'е функций для манипулирования данными см. далее в "
"этой главе."

#: ../book/box/index.rst:361
msgid ""
"Since not all Tarantool operations can be expressed with the data-manipulation "
"functions, or with Lua, to gain complete access to data manipulation "
"functionality one must use a :ref:`Perl, PHP, Python or other programming "
"language connector <index-box_connectors>`. The client/server protocol is open "
"and documented. See this :ref:`annotated BNF <box_protocol-iproto_protocol>`."
msgstr ""
"Не все операции в Tarantool'е можно выразить с помощью функций по "
"манипулированию данными или с помощью языка Lua. Чтобы получить доступ ко всем "
"возможностями манипулирования данными, вам понадобится :ref:`коннектор для Perl, "
"PHP, Python или другого языка программирования <index-box_connectors>`. Бинарный "
"клиент-серверный протокол для коннекторов является открытым. Документация по "
"нему доступна в виде аннотированных :ref:`BNF-диаграмм <box_protocol-"
"iproto_protocol>`."

#: ../book/box/index.rst:370
msgid "Persistence"
msgstr ""

#: ../book/box/index.rst:372
msgid ""
"Tarantool maintains a set of write-ahead log (WAL) files. There is a separate "
"thread -- the WAL writer -- which catches all requests that can change a "
"database, such as ``box.schema.create`` or ``box.space.insert``. Ordinarily the "
"WAL writer writes the request, along with administrative fields and flags, to a "
"WAL file immediately. This ensures data persistence, because, even if an in-"
"memory database is lost when the power goes off, Tarantool recovers it "
"automatically when it starts up again, by reading the WAL files and redoing the "
"requests (this is called the \"recovery process\"). Users can change the timing "
"of the WAL writer, or turn it off, by setting :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`."
msgstr ""
"Tarantool сохраняет данные и информацию об изменениях в нескольких WAL-файлах "
"(write-ahead log). Записью в WAL занимается отдельный поток. Он ловит все "
"запросы, которые могут привести к изменению данных в базе, например ``box.schema."
"create`` или ``box.space.insert``. Как правило, запись о запросе, включая "
"служебные поля и флаги, делается в WAL-файл немедленно. Это обеспечивает "
"сохранность данных, поскольку, даже если данные из памяти утеряны вследствие "
"перебоя в электроснабжении, Tarantool восстановит их автоматически при следующем "
"старте: он загрузит данные из WAL-файлов, а затем применит все записанные в WAL-"
"файлах запросы (это называется \"процесс восстановления\"). Пользователи могут "
"менять частоту записи или вовсе отключать запись в WAL с помощью параметра :ref:"
"`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."

#: ../book/box/index.rst:383
msgid ""
"Tarantool also maintains a set of snapshot files. A snapshot file is an on-disk "
"copy of the entire data set for a given moment. Instead of reading every WAL "
"file since the databases were created, the recovery process can load the latest "
"snapshot and then read only the WAL files that were produced after the snapshot "
"was made. A snapshot can be made even if there is no WAL file. Some snapshots "
"are automatic, or users can make them at any time with the :ref:`box.snapshot() "
"<admin-snapshot>` request."
msgstr ""
"Tarantool также сохраняет ряд файлов со статическими снимками данных "
"(snapshots). Файл со снимком — это дисковая копия всех данных в базе на какой-то "
"момент. Вместо того, чтобы зачитывать все WAL-файлы, появившиеся с момента "
"создания базы, Tarantool в процессе восстановления может загрузить самый свежий "
"снимок и затем зачитать только те WAL-файлы, которые были сделаны с момента "
"сохранения снимка. Снимки могут делаться автоматически, или же пользователи "
"могут создавать их сами в любой момент с помощью запроса :ref:`box.snapshot() "
"<admin-snapshot>`."

#: ../book/box/index.rst:391
msgid ""
"Details about the WAL writer and the recovery process are in the :ref:`Internals "
"<b_internals>` section."
msgstr ""
"См. подробности о работе потока записи в WAL в разделе  :ref:`Детали реализации "
"<b_internals>`."

#: ../book/box/index.rst:396
msgid "Data manipulation"
msgstr "Манипулирование данными"

#: ../book/box/index.rst:398
msgid ""
"The basic *data-manipulation* requests are: ``insert``, ``replace``, ``update``, "
"``upsert``, ``delete``, ``select``. All of them are part of the ``box`` library. "
"Most of them may return data. Usually both inputs and outputs are Lua tables."
msgstr ""
"Основные запросы для *манипулирования данными* — это ``insert``, ``replace``, "
"``update``, ``upsert``, ``delete``, ``select``. Все они реализованы в библиотеке "
"``box``. Многие из этих запросов могут возвращать данные. Как правило, и "
"вводимые, и возвращаемые значения являются Lua-таблицами."

#: ../book/box/index.rst:402
msgid ""
"The Lua syntax for data-manipulation functions can vary. Here are examples of "
"the variations with ``select`` requests; the same rules exist for the other data-"
"manipulation functions. Every one of the examples does the same thing: select a "
"tuple set from a space named 'tester' where the primary-key field value equals "
"1. For the examples there is an assumption that the numeric id of 'tester' is "
"512, which happens to be the case in our sandbox example only."
msgstr ""
"Lua-синтаксис в данных функциях может различаться. Далее приводятся варианты "
"таких различий на примере SELECT-запросов. Аналогичные правила существуют и для "
"остальных функций. В каждом из приведенных примеров выполняются следующие "
"действия: производится выборка по набору кортежей из пространства с именем "
"'tester', где значение поля, которое соответствует ключу в первичном индексе, "
"равно 1. Также во всех примерах мы подразумеваем, что числовой идентификатор "
"пространства 'tester' равен 512, но это верно только для нашей тестовой базы."

#: ../book/box/index.rst:411
msgid "First, there are five *object reference variations*:"
msgstr "Во-первых, есть пять *способов ссылки на объект*:"

#: ../book/box/index.rst:413
msgid ""
"-- #1 module . submodule . name\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 replace name with a literal in square brackets\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 replace name with a numeric id in square brackets\n"
"tarantool> box.space[512]:select{1}\n"
"-- #4 use a variable instead of a literal for the name\n"
"tarantool> variable = 'tester'\n"
"tarantool> box.space[variable]:select{1}\n"
"-- #5 use a variable for the entire object reference\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"
msgstr ""
"-- #1 имя_модуля . имя_вложенного_модуля . имя_объекта\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 вместо имени объекта указываем литерал в квадратных скобках\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 вместо имени объекта указываем числовой идентификатор в квадратных "
"скобках\n"
"tarantool> box.space[512]:select{1}\n"
"-- #4 вместо литерала, обозначающего имя объекта, указываем переменную\n"
"tarantool> variable = 'tester'\n"
"tarantool> box.space[variable]:select{1}\n"
"-- #5 указываем переменную вместо ссылки на весь объект\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"

#: ../book/box/index.rst:428
msgid ""
"Later examples in this manual will usually have the \":samp:`box.space.{tester}:`"
"\" form (#1); however, this is a matter of user preference and all the "
"variations exist in the wild."
msgstr ""
"Для примеров в остальной части документации мы будем, как правило, использовать "
"вариант синтаксиса #1, например \":samp:`box.space.{tester}:`\". Но вы можете с "
"тем же успехом пользоваться любым из пяти описанных выше вариантов."

#: ../book/box/index.rst:432
msgid ""
"Later descriptions in this manual will use the syntax \"``space_object:``\" for "
"references to objects which are spaces as in the above examples, and "
"\"``index_object:``\" for references to objects which are indexes (for example :"
"samp:`box.space.{tester}.index.{primary}:`)."
msgstr ""
"Также мы в дальнейшем будем использовать синтаксис типа  \":code:`space_object:`"
"\" для ссылки на пространства (как в приведенных выше примерах) и \":code:"
"`index_object:`\" для ссылки на индексы (например, :samp:`box.space.{tester}."
"index.{primary}:`)."

#: ../book/box/index.rst:437
msgid "Then, there are seven *parameter variations*:"
msgstr "Во-вторых, есть семь *способов задания параметров*:"

#: ../book/box/index.rst:439
msgid ""
"-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"
msgstr ""
"-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"

#: ../book/box/index.rst:458
msgid ""
"The primary-key value is enclosed in braces, and if it was a multi-part primary "
"key then the value would be multi-part, for example ``...select{1,2,3}``. The "
"braces can be enclosed inside parentheses — ``...select({...})`` — which are "
"optional unless it is necessary to pass something besides the primary-key value, "
"as in example #5. Literal values such as 1 (a scalar value) or {1} (a Lua table "
"value) may be replaced by variable names, as in examples #6 and #7. Although "
"there are special cases where braces can be omitted, they are preferable because "
"they signal \"Lua table\". Examples and descriptions in this manual have the "
"\"{1}\" form; however, this too is a matter of user preference and all the "
"variations exist in the wild."
msgstr ""
"Значение первичного ключа заключается в фигурные скобки. Если же этот первичный "
"ключ является составным, то и значение будет составным, например ``..."
"select{1,2,3}``. Фигурные скобки в свою очередь могут заключаться в круглые "
"скобки — например, ``...select({...})``. Это опциональный вариант синтаксиса, и "
"он необходим только в том случае, если нужно передать что-то помимо первичного "
"ключа, как в примере #5. Вместо значений-литералов — например, 1 (скалярное "
"значение) или {1} (Lua-таблица) — можно использовать имена переменных, как в "
"примерах #6 и #7. Хотя в некоторых случаях фигурные скобки можно опускать, мы "
"рекомендуем всегда их использовать. Так вы явно обозначите, что значение имеет "
"тип \"Lua-таблица\". В примерах и описаниях в документации мы везде используем "
"фигурные скобки, например \"{1}\".  Но как и в случае со ссылками на объект, вы "
"можете пользоваться любым допустимым вариантом синтаксиса."

#: ../book/box/index.rst:469
msgid ""
"All the data-manipulation functions operate on tuple sets but, since primary "
"keys are unique, the number of tuples in the tuple set is always 0 or 1. The "
"only exception is ``box.space...select``, which may accept either a primary-key "
"value or a secondary-key value."
msgstr ""
"Все функции для манипулирования данными оперируют наборами кортежей. Однако, "
"поскольку первичные ключи всегда уникальны, количество кортежей в таком наборе "
"всегда равно 0 или 1. Единственным исключением является функция ``box.space..."
"select``, которая может брать на вход как первичный, так и вторичный ключ."

#: ../book/box/index.rst:477
#, fuzzy
msgid "**Complexity factors that may affect data-manipulation functions**"
msgstr ""
"**Факторы, которые могут влиять на быстродействие функций для манипулирования "
"данными из библиотеки box**"

#: ../book/box/index.rst:483
msgid "Index size"
msgstr "Размер индекса"

#: ../book/box/index.rst:483
msgid ""
"The number of index keys is the same as the number of tuples in the data set. "
"For a TREE index, if there are more keys then the lookup time will be greater, "
"although of course the effect is not linear. For a HASH index, if there are more "
"keys then there is more RAM use, but the number of low-level steps tends to "
"remain constant."
msgstr ""
"Количество ключей в индексе равно количеству кортежей в наборе данных. В случае "
"с TREE-индексом: с ростом количества ключей увеличивается время поиска, хотя "
"зависимость здесь, конечно же, не линейная. В случае с HASH-индексом: с ростом "
"количества ключей увеличивается объем используемой памяти, но количество "
"низкоуровневых шагов остается примерно тем же."

#: ../book/box/index.rst:491
msgid "Index type"
msgstr "Тип индекса"

#: ../book/box/index.rst:491
msgid ""
"Typically a HASH index is faster than a TREE index if the number of tuples in "
"the tuple set is greater than one."
msgstr ""
"Как правило, поиск по HASH-индексу работает быстрее, чем по TREE-индексу, если в "
"наборе есть более одного кортежа."

#: ../book/box/index.rst:495
msgid "Number of indexes accessed"
msgstr "Количество обращений к индексам"

#: ../book/box/index.rst:495
msgid ""
"Ordinarily only one index is accessed to retrieve one tuple. But to update the "
"tuple, there must be N accesses if the tuple set has N different indexes."
msgstr ""
"Обычно для выборки значений одного кортежа используется только один индекс. Но "
"при обновлении значений в кортеже требуется N обращений, если у набора кортежей "
"есть N индексов."

#: ../book/box/index.rst:499
msgid "Number of tuples accessed"
msgstr "Количество обращений к кортежам"

#: ../book/box/index.rst:499
msgid ""
"A few requests, for example select, can retrieve multiple tuples. This factor is "
"usually less important than the others."
msgstr ""
"Некоторые запросы, например SELECT, могут возвращать несколько кортежей. Как "
"правило, это наименее важный фактор из всех."

#: ../book/box/index.rst:503
msgid "WAL settings"
msgstr "Настройки WAL"

#: ../book/box/index.rst:503
msgid ""
"The important setting for the write-ahead log is :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. If the setting causes no writing or "
"delayed writing, this factor is unimportant. If the setting causes every data-"
"change request to wait for writing to finish on a slow device, this factor is "
"more important than all the others."
msgstr ""
"Важным параметром для записи в WAL является :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. Если запись в WAL отключена или задана "
"запись с задержкой, но этот фактор не так важен. Если же запись в WAL "
"производится при каждом запросе на изменение данных, то при каждом таком запросе "
"приходится ждать, пока отработает обращение к более медленному диску, и данный "
"фактор становится важнее всех остальных."

#: ../book/box/index.rst:512
#, fuzzy
msgid ""
"In the discussion of each data-manipulation function, there will be a note about "
"which complexity factors might affect the function's resource usage."
msgstr ""
"Далее в описании каждой функции для манипулирования данными будет дано "
"примечание, какие из перечисленных выше факторов могут влиять на ее "
"быстродействие."

#: ../book/box/index.rst:517
msgid "Index operations"
msgstr "Операции с индексами"

#: ../book/box/index.rst:519
msgid ""
"Index operations are automatic: if a data-manipulation request changes a tuple, "
"then it also changes the index keys defined for the tuple. Therefore the user "
"only needs to know how and why to define."
msgstr ""
"Операции с индексами производятся автоматически. Если запрос по манипулированию "
"данными меняет данные в кортеже, то меняются и ключи в индексе для данного "
"кортежа. Поэтому пользователю нужно знать только как и зачем задавать индексы."

#: ../book/box/index.rst:523
msgid "The simple index-creation operation which has been illustrated before is"
msgstr ""
"Простая операция для создания индекса, которую мы рассматривали ранее, имела "
"следующий вид:"

#: ../book/box/index.rst:528
msgid ":samp:`box.space.{space-name}:create_index('{index-name}')`"
msgstr ":samp:`box.space.{имя-пространства}:create_index('{имя-индекса}')`"

#: ../book/box/index.rst:530
msgid ""
"By default, this creates a unique \"tree\" index on the first field of all "
"tuples (often called \"Field#1\"), which is assumed to be numeric."
msgstr ""
"По умолчанию, при этом создается TREE-индекс по первому полю (обычно его "
"называют \"Field#1\") для всех кортежей в пространстве. Предполагается, что "
"индексируемое поле является числовым."

#: ../book/box/index.rst:533 ../book/box/index.rst:600
msgid "These variations exist:"
msgstr "Также возможны следующие варианты:"

#: ../book/box/index.rst:535
msgid "An indexed field may be a string rather than a number."
msgstr "Индексируемое поле может быть строкой, а не числом."

#: ../book/box/index.rst:542
msgid ""
"For an ordinary index, the most common data types are 'unsigned' = any non-"
"negative integer, or 'string' = any series of bytes. Numbers are ordered "
"according to their point on the number line -- so 2345 is greater than 500 -- "
"while strings are ordered according to the encoding of the first byte then the "
"encoding of the second byte then the encoding of the third byte and so on -- so "
"'2345' is less than '500'."
msgstr ""
"Обычный индекс, как правило, строится по полям одного из двух типов: 'NUM' = "
"числовой (numeric) = любое неотрицательное целое число, либо 'STR' = строка "
"(string) = любая последовательность байтов. Числа в индексе упорядочены по "
"числовой прямой (например, число 2345 больше, чем число 500), а строки — по коду "
"первого байта, затем по коду второго, третьего и т.д. (и теперь строка '2345' "
"будет меньше, чем строка '500')."

#: ../book/box/index.rst:549
msgid ""
"For details about other index types see :ref:`create_index <box_space-"
"create_index>`."
msgstr ""
"Подробнее о других типах индексов см. в описании функции :ref:`create_index "
"<box_space-create_index>`."

#: ../book/box/index.rst:551
msgid "There may be more than one field."
msgstr "Индекс может строиться по нескольким полям."

#: ../book/box/index.rst:560
msgid ""
"For an ordinary index, the maximum number of parts is 255. The specification of "
"each part consists of a field number and a type."
msgstr ""
"В обычном индексе может быть максимум 255 частей. Каждая часть характеризуется "
"номером поля и его типом."

#: ../book/box/index.rst:563
msgid "The index does not have to be unique."
msgstr "Индекс может быть неуникальным."

#: ../book/box/index.rst:570
msgid ""
"The first index of a tuple set must be unique, but other indexes (\"secondary\" "
"indexes) may be non-unique."
msgstr ""
"Первичный индекс для кортежа должен строиться по уникальным значениям полей, но "
"остальные (вторичные) индексы могут строиться по неуникальным значениям."

#: ../book/box/index.rst:573
msgid "The index does not have to be a tree."
msgstr "Индекс может представлять собой не только дерево."

#: ../book/box/index.rst:580
msgid ""
"The two ordinary index types are 'tree' which is the default, and 'hash' which "
"must be unique and which may be faster. The third type is 'bitset' which is not "
"unique and which works best for combinations of binary values. The fourth type "
"is 'rtree' which is not unique and which works with arrays, instead of 'string' "
"or 'unsigned' values."
msgstr ""

#: ../book/box/index.rst:586
msgid ""
"The existence of indexes does not affect the syntax of data-change requests, but "
"does cause select requests to have more variety."
msgstr ""
"Наличие индексов никак не влияет на синтаксис запросов на изменение данных. А "
"вот SELECT-запросы, благодаря индексам, становятся более разнообразными."

#: ../book/box/index.rst:589
msgid "The simple select request which has been illustrated before is:"
msgstr "Вот простой SELECT-запрос, который мы рассматривали ранее:"

#: ../book/box/index.rst:594
msgid ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"
msgstr ":extsamp:`box.space.{*{имя-пространства}*}:select({*{значение}*})`"

#: ../book/box/index.rst:596
msgid ""
"By default, this looks for a single tuple via the first index. Since the first "
"index is always unique, the maximum number of returned tuples will be: one."
msgstr ""
"По умолчанию, такой запрос ищет нужный кортеж по значению в первом (первичном) "
"индексе. Поскольку первичный индекс всегда уникален, то данный запрос вернет не "
"более одного кортежа."

#: ../book/box/index.rst:602
msgid "The search can use comparisons other than equality."
msgstr ""
"Помимо условия равенства, при поиске могут использоваться и другие условия "
"сравнения."

#: ../book/box/index.rst:609
msgid ""
"The comparison operators are LT, LE, EQ, REQ, GE, GT for \"less than\", \"less "
"than or equal\", \"equal\", \"reversed equal\", \"greater than or equal\", "
"\"greater than\" respectively. Comparisons make sense if and only if the index "
"type is 'tree'."
msgstr ""
"Можно использовать следующие операторы сравнения: LT (меньше), LE (меньше или "
"равно), EQ (равно), REQ (неравно), GE (больше или равно), GT (больше). Сравнения "
"имеют смысл только для индексов типа 'tree'."

#: ../book/box/index.rst:614
msgid ""
"This type of search may return more than one tuple; if so, the tuples will be in "
"descending order by key when the comparison operator is LT or LE or REQ, "
"otherwise in ascending order."
msgstr ""
"Этот вариант поиска может вернуть более одного кортежа. В таком случае кортежи "
"будут отсортированы в порядке убывания по ключу (если использовался оператор LT, "
"LE или REQ), либо в порядке возрастания (во всех остальных случаях)."

#: ../book/box/index.rst:618
msgid "The search can use a secondary index."
msgstr "Поиск может производиться по вторичному индексу."

#: ../book/box/index.rst:625
msgid ""
"For a primary-key search, it is optional to specify an index name. For a "
"secondary-key search, it is mandatory."
msgstr ""
"При поиске по первичному индексу имя индекса можно не указывать. При поиске же "
"по вторичному индексу имя индекса указывать необходимо."

#: ../book/box/index.rst:628
msgid "The search may be for some or all key parts."
msgstr "Поиск может производиться как по всему ключу, так и по его частям."

#: ../book/box/index.rst:649
msgid "The search can be for all fields, using a table for the value:"
msgstr ""
"Поиск может производиться по всем полям (в этом случае используется таблица "
"значений):"

#: ../book/box/index.rst:656
msgid "or the search can be for one field, using a table or a scalar:"
msgstr ""
"Либо же по одному полю (в этом случае используется таблица или скалярное "
"значение):"

#: ../book/box/index.rst:663
msgid ""
"in the second case, the result will be two tuples: ``{1, 'A'}`` and ``{1, 'B'}"
"``. It's even possible to specify zero fields, causing all three tuples to be "
"returned."
msgstr ""
"Во втором случае Tarantool вернет два кортежа: ``{1, 'A'}`` и ``{1, 'B'}``. При "
"необходимости можно задать даже нулевые поля, в результате чего Tarantool вернет "
"все три кортежа."

#: ../book/box/index.rst:669
msgid "BITSET example:"
msgstr "Пример работы с BITSET-индексом:"

#: ../book/box/index.rst:671
msgid ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique=false,"
"type='BITSET', parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"
msgstr ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique=false,"
"type='BITSET', parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"

#: ../book/box/index.rst:682 ../book/box/index.rst:707
msgid "The result will be:"
msgstr "Мы получим следующий результат:"

#: ../book/box/index.rst:684
msgid ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."
msgstr ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."

#: ../book/box/index.rst:691
msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr "поскольку (7 AND 2) не равно 0 и (3 AND 2) не равно 0."

#: ../book/box/index.rst:693
msgid ""
"Searches on BITSET indexes can be for BITS_ANY_SET, BITS_ALL_SET, "
"BITS_ALL_NOT_SET, EQ, or ALL."
msgstr ""
"При поиске по BITSET-индексам можно использовать операторы BITS_ANY_SET, "
"BITS_ALL_SET, BITS_ALL_NOT_SET, EQ и ALL."

#: ../book/box/index.rst:696
msgid "RTREE example:"
msgstr "Пример работы с RTREE-индексом:"

#: ../book/box/index.rst:698
msgid ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> box.space.rtree_example:create_index('rtree',{unique=false,"
"type='RTREE', parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, {iterator = "
"'GT'})"
msgstr ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> box.space.rtree_example:create_index('rtree',{unique=false,"
"type='RTREE', parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, {iterator = "
"'GT'})"

#: ../book/box/index.rst:709
msgid ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."
msgstr ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."

#: ../book/box/index.rst:715
msgid ""
"because a rectangle whose corners are at coordinates 4,7,5,9 is entirely within "
"a rectangle whose corners are at coordinates 3,5,9,10."
msgstr ""
"поскольку прямоугольник с углами в координатах 4,7,5,9 лежит целиком внутри "
"прямоугольника с углами в координатах 3,5,9,10."

#: ../book/box/index.rst:718
msgid "Searches on RTREE indexes can be for GT, GE, LT, LE, OVERLAPS, or NEIGHBOR."
msgstr ""
"При поиске по RTREE-индексам можно использовать операторы GT, GE, LT, LE, "
"OVERLAPS и NEIGHBOR."

#: ../book/box/index.rst:724
msgid "Transaction control"
msgstr "Контроль транзакций"

#: ../book/box/atomic.rst:3
msgid ""
"In several places in this manual, it's been noted that Lua processes occur in "
"fibers on a single thread. That is why there can be a guarantee of execution "
"atomicity. That requires emphasis."
msgstr ""

#: ../book/box/atomic.rst:11
msgid "Cooperative multitasking environment"
msgstr "Среда взаимной многозадачности"

#: ../book/box/atomic.rst:13
msgid ""
"Tarantool uses cooperative multitasking: unless a running fiber deliberately "
"yields control, it is not preempted by some other fiber. But a running fiber "
"will deliberately yield when it encounters a \"yield point\": an explicit "
"`yield()` request, or an implicit yield due to an operating-system call. Any "
"system call which can block will be performed asynchronously, and any running "
"fiber which must wait for a system call will be preempted so that another ready-"
"to-run fiber takes its place and becomes the new running fiber. This model makes "
"all programmatic locks unnecessary: cooperative multitasking ensures that there "
"will be no concurrency around a resource, no race conditions, and no memory "
"consistency issues."
msgstr ""

#: ../book/box/atomic.rst:24
msgid ""
"When requests are small, for example simple UPDATE or INSERT or DELETE or "
"SELECT, fiber scheduling is fair: it takes only a little time to process the "
"request, schedule a disk write, and yield to a fiber serving the next client."
msgstr ""

#: ../book/box/atomic.rst:28
msgid ""
"However, a function might perform complex computations or might be written in "
"such a way that yields do not occur for a long time. This can lead to unfair "
"scheduling, when a single client throttles the rest of the system, or to "
"apparent stalls in request processing. Avoiding this situation is the "
"responsibility of the function's author. For the default memtx storage engine "
"some of the box calls, including the data-change requests :ref:`box.space..."
"insert <box_space-insert>` or :ref:`box.space...update <box_space-update>` or :"
"ref:`box.space...delete <box_space-delete>`, will usually cause yielding; "
"however, :ref:`box.space...select <box_space-select>` will not. A fuller "
"description will appear in section :ref:`Implicit yields <atomic-"
"the_implicit_yield_rules>`."
msgstr ""

#: ../book/box/atomic.rst:41
msgid ""
"Note re storage engine: vinyl has different rules: insert or update or delete "
"will very rarely cause a yield, but select can cause a yield."
msgstr ""

#: ../book/box/atomic.rst:45
msgid ""
"In the absence of transactions, any function that contains yield points may see "
"changes in the database state caused by fibers that preempt. Then the only safe "
"atomic functions for memtx databases would be functions which contain only one "
"database request, or functions which contain a select request followed by a data-"
"change request."
msgstr ""

#: ../book/box/atomic.rst:51
msgid ""
"At this point an objection could arise: \"It's good that a single data-change "
"request will commit and yield, but surely there are times when multiple data-"
"change requests must happen without yielding.\" The standard example is the "
"money-transfer, where $1 is withdrawn from account #1 and deposited into account "
"#2. If something interrupted after the withdrawal, then the institution would be "
"out of balance. For such cases, the ``begin ... commit|rollback`` block was "
"designed."
msgstr ""

#: ../book/box/atomic.rst:63
msgid ""
"Begin the transaction. Disable implicit yields until the transaction ends. "
"Signal that writes to the write-ahead log will be deferred until the transaction "
"ends. In effect the fiber which executes ``box.begin()`` is starting an \"active "
"multi-request transaction\", blocking all other fibers."
msgstr ""

#: ../book/box/atomic.rst:72
msgid "End the transaction, and make all its data-change operations permanent."
msgstr ""

#: ../book/box/atomic.rst:79
msgid ""
"End the transaction, but cancel all its data-change operations. An explicit call "
"to functions outside ``box.space`` that always yield, such as ``fiber.yield`` or "
"``fiber.sleep``, will have the same effect."
msgstr ""

#: ../book/box/atomic.rst:83
msgid ""
"The **requests in a transaction must be sent to the server as a single block**. "
"It is not enough to enclose them between ``begin`` and ``commit`` or "
"``rollback``. To ensure they are sent as a single block: put them in a function, "
"or put them all on one line, or use a delimiter so that multi-line requests are "
"handled together."
msgstr ""

#: ../book/box/atomic.rst:88
msgid ""
"**All database operations in a transaction should use the same storage engine**. "
"It is not safe to access tuple sets that are defined with ``{engine='vinyl'}`` "
"and also access tuple sets that are defined with ``{engine='memtx'}``, in the "
"same transaction."
msgstr ""

#: ../book/box/atomic.rst:97
msgid ""
"Assuming that in tuple set 'tester' there are tuples in which the third field "
"represents a positive dollar amount ... Start a transaction, withdraw from "
"tuple#1, deposit in tuple#2, and end the transaction, making its effects "
"permanent."
msgstr ""

#: ../book/box/atomic.rst:101
msgid ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."
msgstr ""

#: ../book/box/atomic.rst:121
#, fuzzy
msgid "Implicit yields"
msgstr "Правила неявной передачи управления"

#: ../book/box/atomic.rst:123
msgid ""
"The only explicit yield requests are :ref:`fiber.sleep() <fiber-sleep>` and :ref:"
"`fiber.yield() <fiber-yield>`, but many other requests \"imply\" yields because "
"Tarantool is designed to avoid blocking."
msgstr ""

#: ../book/box/atomic.rst:127
msgid ""
"The implicit yield requests are: :ref:`insert <box_space-insert>` :ref:`replace "
"<box_space-replace>` :ref:`update <box_space-update>` :ref:`upsert <box_space-"
"upsert>` :ref:`delete <box_space-delete>` (the \"data-change\" requests), and "
"functions in module :ref:`fio <fio-section>`, :ref:`net_box <net_box-module>`, :"
"ref:`console <console-module>`, or :ref:`socket <socket-module>` (the \"os\" and "
"\"network\" requests)."
msgstr ""

#: ../book/box/atomic.rst:134
msgid ""
"Note re storage engine: vinyl causes :ref:`select <box_space-select>` to be an "
"implicit yield request, but data-change requests may not be."
msgstr ""

#: ../book/box/atomic.rst:137
msgid ""
"The yield occurs just before a blocking syscall, such as a write to the Write-"
"Ahead Log (WAL) or a network message reception."
msgstr ""

#: ../book/box/atomic.rst:140
msgid ""
"Implicit yield requests are disabled by :ref:`box.begin <atomic-box_begin>`, and "
"enabled again by :ref:`commit <atomic-box_commit>`. Therefore the sequence"
msgstr ""

#: ../book/box/atomic.rst:874
msgid ""
"begin\n"
"implicit yield request #1\n"
"implicit yield request #2\n"
"implicit yield request #3\n"
"commit"
msgstr ""

#: ../book/box/atomic.rst:152
msgid ""
"will not cause implicit yield until the commit occurs (specifically: just before "
"the writes to the WAL, which are delayed until commit time). The commit request "
"is not itself an implicit yield request, it only enables yields caused by "
"earlier implicit yield requests."
msgstr ""

#: ../book/box/atomic.rst:157
msgid ""
"Despite their resemblance to implicit yield requests, :ref:`truncate <box_space-"
"truncate>` and :ref:`drop <box_space-drop>` do not cause implicit yield. Despite "
"their resemblance to functions of the fio module, functions of the :ref:`os <os-"
"module>` module do not cause implicit yield. Despite its resemblance to commit, :"
"ref:`rollback <atomic-box_rollback>` does not enable yields."
msgstr ""

#: ../book/box/atomic.rst:164
msgid ""
"If :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = 'none', then "
"implicit yielding is disabled, because there are no writes to the WAL."
msgstr ""

#: ../book/box/atomic.rst:167
msgid ""
"If a task is interactive -- sending requests to the server and receiving "
"responses -- then it involves network IO, and therefore there is an implicit "
"yield, even if the request that is sent to the server is not itself an implicit "
"yield request. Therefore the sequence"
msgstr ""

#: ../book/box/atomic.rst:903
msgid ""
"select\n"
"select\n"
"select"
msgstr ""

#: ../book/box/atomic.rst:179
msgid ""
"causes blocking if it is inside a function or Lua program being executed on the "
"server, but causes yielding if it is done as a series of transmissions from a "
"client, including a client which operates via telnet, via one of the connectors, "
"or via the MySQL and PostgreSQL rocks, or via the interactive mode when :ref:`"
"\"Using tarantool as a client\" <administration-using_tarantool_as_a_client>`."
msgstr ""

#: ../book/box/atomic.rst:185
msgid ""
"After a fiber has yielded and then has regained control, it immediately issues :"
"ref:`testcancel <fiber-testcancel>`."
msgstr ""

#: ../book/box/index.rst:730
msgid "Access control"
msgstr "Ограничение доступа"

#: ../book/box/authentication.rst:3
msgid ""
"Understanding the details of security is primarily an issue for administrators, "
"but ordinary users should at least skim this section so that they will have an "
"idea of how Tarantool makes it possible for administrators to prevent "
"unauthorized access to the database and to certain functions."
msgstr ""

#: ../book/box/authentication.rst:8
msgid ""
"Briefly: there is a method to guarantee with password checks that users really "
"are who they say they are (\"authentication\"). There is a _user space where "
"user names and password-hashes are stored. There are functions for saying that "
"certain users are allowed to do certain things (\"privileges\"). There is a "
"_priv space where privileges are stored. Whenever a user tries to do an "
"operation, there is a check whether the user has the privilege to do the "
"operation (\"access control\")."
msgstr ""

#: ../book/box/authentication.rst:18
msgid "Passwords"
msgstr ""

#: ../book/box/authentication.rst:20
msgid ""
"Each user may have a password. The password is any alphanumeric string. "
"Administrators should advise users to choose long unobvious passwords, but it is "
"ultimately up to the users to choose or change their own passwords."
msgstr ""

#: ../book/box/authentication.rst:24
msgid ""
"Tarantool passwords are stored in the _user space with a `Cryptographic hash "
"function`_ so that, if the password is 'x', the stored hashed-password is a long "
"string like '``lL3OvhkIPOKh+Vn9Avlkx69M/Ck=``'. When a client connects to a "
"Tarantool server, the server sends a random `Salt Value`_ which the client must "
"mix with the hashed-password before sending to the server. Thus the original "
"value 'x' is never stored anywhere except in the user's head, and the hashed "
"value is never passed down a network wire except when mixed with a random salt. "
"This system prevents malicious onlookers from finding passwords by snooping in "
"the log files or snooping on the wire. It is the same system that `MySQL "
"introduced several years ago`_ which has proved adequate for medium-security "
"installations. Nevertheless administrators should warn users that no system is "
"foolproof against determined long-term attacks, so passwords should be guarded "
"and changed occasionally."
msgstr ""

#: ../book/box/authentication.rst:39
msgid ""
"To get the hash-password of a string 'X', say ``box.schema.user.password('X')``. "
"To see more about the details of the algorithm for the purpose of writing a new "
"client application, read the `scramble.h`_ header file."
msgstr ""

#: ../book/box/authentication.rst:53
msgid "Users and the _user space"
msgstr ""

#: ../book/box/authentication.rst:55
msgid "The fields in the _user space are:"
msgstr ""

#: ../book/box/authentication.rst:57
msgid "the numeric id of the tuple"
msgstr ""

#: ../book/box/authentication.rst:58
msgid "the numeric id of the tuple's creator"
msgstr ""

#: ../book/box/authentication.rst:59
msgid "the user name"
msgstr ""

#: ../book/box/authentication.rst:60
msgid "the type"
msgstr ""

#: ../book/box/authentication.rst:61
msgid "optional password"
msgstr ""

#: ../book/box/authentication.rst:63
msgid ""
"There are four special tuples in the _user space: 'guest', 'admin', 'public', "
"and 'replication'."
msgstr ""

#: ../book/box/authentication.rst:73
msgid "ID"
msgstr ""

#: ../book/box/authentication.rst:75
msgid "guest"
msgstr ""

#: ../book/box/authentication.rst:75
msgid "0"
msgstr ""

#: ../book/box/authentication.rst:75
msgid ""
"Default when connecting remotely. Usually an untrusted user with few privileges."
msgstr ""

#: ../book/box/authentication.rst:78
msgid "admin"
msgstr ""

#: ../book/box/authentication.rst:78
msgid "1"
msgstr ""

#: ../book/box/authentication.rst:78
msgid ""
"Default when using ``tarantool`` as a console. Usually an administrative user "
"with all privileges."
msgstr ""

#: ../book/box/authentication.rst:81
msgid "public"
msgstr ""

#: ../book/box/authentication.rst:81
msgid "2"
msgstr ""

#: ../book/box/authentication.rst:81 ../book/box/authentication.rst:84
msgid "role"
msgstr ""

#: ../book/box/authentication.rst:81 ../book/box/authentication.rst:84
msgid "Not a user in the usual sense. Described later in section `Roles`_."
msgstr ""

#: ../book/box/authentication.rst:84
msgid "replication"
msgstr ""

#: ../book/box/authentication.rst:84
msgid "3"
msgstr ""

#: ../book/box/authentication.rst:89
msgid ""
"To select a row from the _user space, use ``box.space._user:select``. For "
"example, here is what happens with a select for user id = 0, which is the "
"'guest' user, which by default has no password:"
msgstr ""

#: ../book/box/authentication.rst:93
msgid ""
"tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."
msgstr ""

#: ../book/box/authentication.rst:100
msgid ""
"To change tuples in the _user space, do not use ordinary ``box.space`` functions "
"for insert or update or delete - the _user space is special so there are special "
"functions which have appropriate error checking."
msgstr ""

#: ../book/box/authentication.rst:104
msgid "To create a new user, say:"
msgstr ""

#: ../book/box/authentication.rst:1031
msgid ""
"box.schema.user.create(*user-name*)\n"
"box.schema.user.create(*user-name*, {if_not_exists = true})\n"
"box.schema.user.create(*user-name*, {password = *password*})."
msgstr ""

#: ../book/box/authentication.rst:113
msgid ""
"The :samp:`password={password}` specification is good because in a :ref:`URI "
"<index-uri>` (Uniform Resource Identifier) it is usually illegal to include a "
"user-name without a password."
msgstr ""

#: ../book/box/authentication.rst:116
msgid "To change the user's password, say:"
msgstr ""

#: ../book/box/authentication.rst:1043
msgid ""
"-- To change the current user's password\n"
"box.schema.user.passwd(*password*)\n"
"\n"
"-- To change a different user's password\n"
"box.schema.user.passwd(*user-name*, *password*)"
msgstr ""

#: ../book/box/authentication.rst:127
msgid ""
"(Usually it is only the admin user who can change a different user's password.)"
msgstr ""

#: ../book/box/authentication.rst:129
msgid "To drop a user, say:"
msgstr ""

#: ../book/box/authentication.rst:1056
msgid "box.schema.user.drop(*user-name*)."
msgstr ""

#: ../book/box/authentication.rst:136
msgid "To check whether a user exists, say:"
msgstr ""

#: ../book/box/authentication.rst:1063
msgid "box.schema.user.exists(*user-name*)"
msgstr ""

#: ../book/box/authentication.rst:143
msgid "which returns true or false."
msgstr ""

#: ../book/box/authentication.rst:145
msgid "To find what privileges a user has, say:"
msgstr ""

#: ../book/box/authentication.rst:1072
msgid "box.schema.user.info(*user-name*)"
msgstr ""

#: ../book/box/authentication.rst:154
msgid ""
"Here is a session which creates a new user with a strong password, selects a "
"tuple in the _user space, and then drops the user."
msgstr ""

#: ../book/box/authentication.rst:157
msgid ""
"tarantool> box.schema.user.create('JeanMartin', {password = 'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': 't3xjUpQdrt857O"
"+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/authentication.rst:172
msgid "The maximum number of users is 32."
msgstr ""

#: ../book/box/authentication.rst:178
msgid "Privileges and the _priv space"
msgstr ""

#: ../book/box/authentication.rst:180
msgid "The fields in the _priv space are:"
msgstr ""

#: ../book/box/authentication.rst:182
msgid "the numeric id of the user who gave the privilege (\"grantor_id\"),"
msgstr ""

#: ../book/box/authentication.rst:183
msgid "the numeric id of the user who received the privilege (\"grantee_id\"),"
msgstr ""

#: ../book/box/authentication.rst:184
msgid "the type of object - \"space\" or \"function\" or \"universe\","
msgstr ""

#: ../book/box/authentication.rst:185
msgid "the numeric id of the object,"
msgstr ""

#: ../book/box/authentication.rst:186
msgid ""
"the type of operation - \"read\" = 1, or \"write\" = 2, or \"execute\" = 4, or a "
"combination such as \"read,write,execute\"."
msgstr ""

#: ../book/box/authentication.rst:189
msgid "The function for granting a privilege is:"
msgstr ""

#: ../book/box/authentication.rst:1116
msgid ""
"box.schema.user.grant(*grantee*, *operation*, *object-type*, *object-name*[, "
"*options*])\n"
"-- OR\n"
"box.schema.user.grant(*grantee*, *operation*, 'universe' [, nil, *options*])"
msgstr ""

#: ../book/box/authentication.rst:198 ../book/box/authentication.rst:211
msgid "where 'universe' means 'all objects', and the optional grant-option can be:"
msgstr ""

#: ../book/box/authentication.rst:200
msgid ":samp:`grantor={grantor_name_or_id}` - string or number, for custom grantor"
msgstr ""

#: ../book/box/authentication.rst:201
msgid ""
":samp:`if_not_exists=true|false` - bool, do not throw error if user already has "
"the privilege"
msgstr ""

#: ../book/box/authentication.rst:203
msgid "The function for revoking a privilege is:"
msgstr ""

#: ../book/box/authentication.rst:1130
msgid ""
"box.schema.user.revoke(*grantee*, *operation*, *object-type*, *object-name*[, "
"*options*])\n"
"box.schema.user.revoke(*grantee*, *operation*, 'universe'[, nil, *options*])"
msgstr ""

#: ../book/box/authentication.rst:213
msgid ""
":samp:`if_not_exists=true|false` - bool, do not throw error if user already "
"lacks the privilege"
msgstr ""

#: ../book/box/authentication.rst:215
msgid ""
"For example, here is a session where the admin user gave the guest user the "
"privilege to read from a space named ``space55``, and then took the privilege "
"away:"
msgstr ""

#: ../book/box/authentication.rst:218
msgid ""
"tarantool> box.schema.user.grant('guest', 'read', 'space', 'space55')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'read', 'space', 'space55')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/authentication.rst:229
msgid ""
"Generally privileges are granted or revoked by the owner of the object (the user "
"who created it), or by the 'admin' user. Before dropping any objects or users, "
"steps should be taken to ensure that all their associated privileges have been "
"revoked."
msgstr ""

#: ../book/box/authentication.rst:236
msgid "Only the 'admin' user can grant privileges for the 'universe'."
msgstr ""

#: ../book/box/authentication.rst:240
msgid ""
"Only the creator of a space can drop, alter, or truncate the space. Only the "
"creator of a user can change a different user's password."
msgstr ""

#: ../book/box/authentication.rst:247
msgid "Functions and the _func space"
msgstr ""

#: ../book/box/authentication.rst:249
msgid "The fields in the _func space are:"
msgstr ""

#: ../book/box/authentication.rst:251
msgid "the numeric function id, a number,"
msgstr ""

#: ../book/box/authentication.rst:252
msgid "the function name"
msgstr ""

#: ../book/box/authentication.rst:253
msgid "flag"
msgstr ""

#: ../book/box/authentication.rst:254
msgid "possibly a language name."
msgstr ""

#: ../book/box/authentication.rst:256
msgid ""
"The _func space does not include the function's body. One continues to create "
"Lua functions in the usual way, by saying \":samp:`function {function_name} "
"() ... end`\", without adding anything in the _func space. The _func space only "
"exists for storing function tuples so that their names can be used within grant/"
"revoke functions."
msgstr ""

#: ../book/box/authentication.rst:262
msgid "The function for creating a _func tuple is:"
msgstr ""

#: ../book/box/authentication.rst:1189
msgid "box.schema.func.create(*function-name* [, *options*])"
msgstr ""

#: ../book/box/authentication.rst:269
msgid "The possible options are:"
msgstr ""

#: ../book/box/authentication.rst:271
msgid ":samp:`if_not_exists = {true|false}` - default = false,"
msgstr ""

#: ../book/box/authentication.rst:272
msgid ":samp:`setuid = {true|false}` - default = false,"
msgstr ""

#: ../book/box/authentication.rst:273
msgid ":samp:`language = {'LUA'|'C'}` - default = 'LUA'."
msgstr ""

#: ../book/box/authentication.rst:277
msgid "box.schema.func.create('f', {language = 'C', setuid = false})"
msgstr ""

#: ../book/box/authentication.rst:281
msgid ""
"Specifying :code:`if_not_exists=false` would cause ``error: Function '...' "
"already exists`` if the _func tuple already exists."
msgstr ""

#: ../book/box/authentication.rst:284
msgid ""
"Specifying :code:`setuid=true` would cause the setuid flag (the fourth field in "
"the _func tuple) to have a value meaning \"true\", and the effect of that is "
"that the function's caller is treated as the function's creator, with full "
"privileges. The setuid behavior does not apply for users who connect via :code:"
"`console.connect`."
msgstr ""

#: ../book/box/authentication.rst:289
msgid ""
"Specifying :code:`language='C'` would cause the language field (the fifth field "
"in the _func tuple) to have a value 'C', which means the function was written in "
"C. Tarantool functions are normally written in Lua but can be written in C as "
"well."
msgstr ""

#: ../book/box/authentication.rst:293
msgid "The function for dropping a _func tuple is:"
msgstr ""

#: ../book/box/authentication.rst:1220
msgid "box.schema.func.drop(*function-name*)"
msgstr ""

#: ../book/box/authentication.rst:300
msgid "The function for checking whether a _func tuple exists is:"
msgstr ""

#: ../book/box/authentication.rst:1227
msgid "box.schema.func.exists(*function-name*)"
msgstr ""

#: ../book/box/authentication.rst:307
msgid ""
"In the following example, a function named 'f7' is created, then it is put in "
"the _func space, then it is used in a ``box.schema.user.grant`` function, then "
"it is dropped:"
msgstr ""

#: ../book/box/authentication.rst:311
msgid ""
"tarantool> function f7()\n"
"         >   box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.func.drop('f7')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/authentication.rst:333
msgid "box.session and security"
msgstr ""

#: ../book/box/authentication.rst:335
msgid ""
"After a connection has taken place, the user has access to a \"session\" object "
"which has several functions. The ones which are of interest for security "
"purposes are:"
msgstr ""

#: ../book/box/authentication.rst:1264
msgid ""
"box.session.uid()         -- returns the id of the current user\n"
"box.session.user()        -- returns the name of the current user\n"
"box.session.su(*user-name*) -- allows changing current user to 'user-name'"
msgstr ""

#: ../book/box/authentication.rst:346
msgid ""
"If a user types requests directly on the Tarantool server in its :ref:"
"`interactive mode <administration-using_tarantool_as_a_client>`, or if a user "
"connects to the :ref:`admin port <administration-admin_ports>`, then the user by "
"default is 'admin' and has many privileges. If a user connects from an "
"application program via one of the :ref:`connectors <index-box_connectors>`, "
"then the user by default is 'guest' and has few privileges. Typically an admin "
"user will set up and configure objects, then grant privileges to appropriate non-"
"admin users. Typically a guest user will use ``box.session.su()`` to change into "
"a non-generic user to whom admin has granted more than the default privileges. "
"For example, admin might say:"
msgstr ""

#: ../book/box/authentication.rst:359
msgid ""
"box.space._user:insert{123456,0,'manager','user'}\n"
"box.schema.user.grant('manager', 'read', 'space', '_space')\n"
"box.schema.user.grant('manager', 'read', 'space', 'payroll')"
msgstr ""

#: ../book/box/authentication.rst:365
msgid "and later a guest user, who wishes to see the payroll, might say:"
msgstr ""

#: ../book/box/authentication.rst:367
msgid ""
"box.session.su('manager')\n"
"box.space.payroll:select{'Jones'}"
msgstr ""

#: ../book/box/authentication.rst:376
msgid "Roles"
msgstr ""

#: ../book/box/authentication.rst:378
msgid ""
"A role is a container for privileges which can be granted to regular users. "
"Instead of granting and revoking individual privileges, one can put all the "
"privileges in a role and then grant or revoke the role. Role information is in "
"the _user space but the third field - the type field - is 'role' rather than "
"'user'."
msgstr ""

#: ../book/box/authentication.rst:386
msgid ""
"If a role R1 is granted a privilege X, and user U1 is granted a privilege \"role "
"R1\", then user U1 in effect has privilege X. Then if a role R2 is granted a "
"privilege Y, and role R1 is granted a privilege \"role R2\", then user U1 in "
"effect has both privilege X and privilege Y. In other words, a user gets all the "
"privileges that are granted to a user's roles, directly or indirectly."
msgstr ""

#: ../book/box/authentication.rst:397
msgid "Create a new role."
msgstr ""

#: ../book/box/authentication.rst:401
msgid "Put a privilege in a role."
msgstr ""

#: ../book/box/authentication.rst:405
msgid "Take a privilege out of a role."
msgstr ""

#: ../book/box/authentication.rst:409
msgid "Drop a role."
msgstr ""

#: ../book/box/authentication.rst:413
msgid "Grant a role to a role."
msgstr ""

#: ../book/box/authentication.rst:417
msgid "Revoke a role from a role."
msgstr ""

#: ../book/box/authentication.rst:421
msgid ""
"Check whether a role exists. Returns (type = boolean) true if role-name "
"identifies a role, otherwise false."
msgstr ""

#: ../book/box/authentication.rst:428
msgid "Grant a role to a user."
msgstr ""

#: ../book/box/authentication.rst:432
msgid "Revoke a role from a user."
msgstr ""

#: ../book/box/authentication.rst:434
msgid ""
"There are two predefined roles. The first predefined role, named 'public', is "
"automatically assigned to new users when they are created with :samp:`box.schema."
"user.create({user-name})` - Therefore a convenient way to grant 'read' on space "
"'t' to every user that will ever exist is: :code:`box.schema.role."
"grant('public','read','space','t')`. The second predefined role, named "
"'replication', can be assigned by the 'admin' user to users who need to use "
"replication features."
msgstr ""

#: ../book/box/authentication.rst:444
msgid "Example showing a role within a role"
msgstr ""

#: ../book/box/authentication.rst:446
msgid ""
"In this example, a new user named U1 will insert a new tuple into a new space "
"named T, and will succeed even though user U1 has no direct privilege to do such "
"an insert -- that privilege is inherited from role R1, which in turn inherits "
"from role R2."
msgstr ""

#: ../book/box/authentication.rst:451
msgid ""
"-- This example will work for a user with many privileges, such as 'admin'\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('primary', {})\n"
"-- Create a user U1 so that later it's possible to say box.session.su('U1')\n"
"box.schema.user.create('U1')\n"
"-- Create two roles, R1 and R2\n"
"box.schema.role.create('R1')\n"
"box.schema.role.create('R2')\n"
"-- Grant role R2 to role R1 and role R1 to U1 (order doesn't matter)\n"
"box.schema.role.grant('R1', 'execute', 'role', 'R2')\n"
"box.schema.user.grant('U1', 'execute', 'role', 'R1')\n"
"-- Grant read and execute privileges to R2 (but not to R1 and not to U1)\n"
"box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
"box.schema.role.grant('R2', 'execute', 'universe')\n"
"-- Use box.session.su to say \"now become user U1\"\n"
"box.session.su('U1')\n"
"-- Next insert succeeds because U1 in effect has write privilege on T\n"
"box.space.T:insert{1}"
msgstr ""

#: ../book/box/index.rst:736
msgid "Triggers"
msgstr "Триггеры"

#: ../book/box/triggers.rst:4
msgid ""
"*Triggers*, also known as *callbacks*, are functions which the server executes "
"when certain events happen. Currently the main types of triggers are :ref:"
"`connection triggers <triggers-connection_triggers>`, which are executed when a "
"session begins or ends, and :ref:`replace triggers <triggers-replace_triggers>`, "
"which are for database events."
msgstr ""

#: ../book/box/triggers.rst:11
msgid "All triggers have the following characteristics:"
msgstr ""

#: ../book/box/triggers.rst:13
msgid ""
"They associate a `function` with an `event`. The request to \"define a trigger\" "
"consists of passing the name of the trigger's function to one of the \":samp:"
"`on_{event-name}()`\" functions: :code:`on_connect()`, :code:`on_auth()`, :code:"
"`on_disconnect()`, or :code:`on_replace()`."
msgstr ""

#: ../book/box/triggers.rst:17
msgid ""
"They are `defined by any user`. There are no privilege requirements for defining "
"triggers."
msgstr ""

#: ../book/box/triggers.rst:19
msgid ""
"They are called `after` the event. They are not called if the event ends "
"prematurely due to an error. (Exception: :code:`on_auth()` is called before the "
"event.)"
msgstr ""

#: ../book/box/triggers.rst:21
msgid ""
"They are in `server memory`. They are not stored in the database. Triggers "
"disappear when the server is shut down. If there is a requirement to make them "
"permanent, then the function definitions and trigger settings should be part of "
"an initialization script."
msgstr ""

#: ../book/box/triggers.rst:25
msgid ""
"They have `low overhead`. If a trigger is not defined, then the overhead is "
"minimal: merely a pointer dereference and check. If a trigger is defined, then "
"its overhead is equivalent to the overhead of calling a stored procedure."
msgstr ""

#: ../book/box/triggers.rst:28
msgid ""
"They can be `multiple` for one event. Triggers are executed in the reverse order "
"that they were defined in."
msgstr ""

#: ../book/box/triggers.rst:30
msgid ""
"They must work `within the event context`. If the function contains requests "
"which normally could not occur immediately after the event but before the return "
"from the event, effects are undefined. For example, putting ``os.exit()`` or "
"``box.rollback()`` in a trigger function would be bringing in requests outside "
"the event context."
msgstr ""

#: ../book/box/triggers.rst:35
msgid ""
"They are `replaceable`. The request to \"redefine a trigger\" consists of "
"passing the names of a new trigger function and an old trigger function to one "
"of the \"on `event-name` ...\" functions."
msgstr ""

#: ../book/box/triggers.rst:43
msgid "Connection triggers"
msgstr ""

#: ../book/box/triggers.rst:47
msgid ""
"Define a trigger for execution when a new session is created due to an event "
"such as :ref:`console.connect <console-connect>`. The trigger function will be "
"the first thing executed after a new session is created. If the trigger fails by "
"raising an error, the error is sent to the client and the connection is closed."
msgstr ""

#: ../book/box/triggers.rst:52 ../book/box/triggers.rst:79
#: ../book/box/triggers.rst:151 ../book/box/triggers.rst:182
msgid "function which will become the trigger function"
msgstr ""

#: ../book/box/triggers.rst:53 ../book/box/triggers.rst:80
#: ../book/box/triggers.rst:152 ../book/box/triggers.rst:183
msgid "existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../book/box/triggers.rst:54 ../book/box/triggers.rst:81
#: ../book/box/triggers.rst:184
msgid "nil or function list"
msgstr ""

#: ../book/box/triggers.rst:56 ../book/box/triggers.rst:83
#: ../book/box/triggers.rst:155 ../book/box/triggers.rst:186
msgid ""
"If the parameters are (nil, old-trigger-function-name), then the old trigger is "
"deleted."
msgstr ""

#: ../book/box/triggers.rst:60
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"
msgstr ""

#: ../book/box/triggers.rst:69
msgid ""
"If a trigger always results in an error, it may become impossible to connect to "
"the server to reset it."
msgstr ""

#: ../book/box/triggers.rst:74
msgid ""
"Define a trigger for execution after a client has disconnected. If the trigger "
"function causes an error, the error is logged but otherwise is ignored. The "
"trigger is invoked while the session associated with the client still exists and "
"can access session properties, such as box.session.id."
msgstr ""

#: ../book/box/triggers.rst:87
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"
msgstr ""

#: ../book/box/triggers.rst:98
msgid ""
"After the following series of requests, the server will write a message using "
"the :ref:`log <log>` module whenever any user connects or disconnects."
msgstr ""

#: ../book/box/triggers.rst:101
msgid ""
"function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. box.session."
"id()\n"
"  log.info(m)\n"
"end\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. box."
"session.id()\n"
"  log.info(m)\n"
"end\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"
msgstr ""

#: ../book/box/triggers.rst:116
msgid "Here is what might appear in the log file in a typical installation:"
msgstr ""

#: ../book/box/triggers.rst:118
msgid ""
"2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"
msgstr ""

#: ../book/box/triggers.rst:129
msgid "Authentication triggers"
msgstr ""

#: ../book/box/triggers.rst:133
msgid "Define a trigger for execution during authentication."
msgstr ""

#: ../book/box/triggers.rst:135
msgid ""
"The on_auth trigger function is invoked in these circumstances: (1) The :ref:"
"`console.connect <console-connect>` function includes an authentication check "
"for all users except 'guest'; for this case the on_auth trigger function is "
"invoked after the on_connect trigger function, if and only if the connection has "
"succeeded so far. (2) The binary protocol has a separate :ref:`authentication "
"packet <box_protocol-authentication>` -- for this case, connection and "
"authentication are considered to be separate steps."
msgstr ""

#: ../book/box/triggers.rst:142
msgid ""
"Unlike other trigger types, on_auth trigger functions are invoked `before` the "
"event. Therefore a trigger function like :code:`function auth_function () v = "
"box.session.user(); end` will set :code:`v` to \"guest\", the user name before "
"the authentication is done. To get the user name after the authentication is "
"done, use the special syntax: :code:`function auth_function (user_name) v = "
"user_name; end`"
msgstr ""

#: ../book/box/triggers.rst:148
msgid ""
"If the trigger fails by raising an error, the error is sent to the client and "
"the connection is closed."
msgstr ""

#: ../book/box/triggers.rst:159
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"
msgstr ""

#: ../book/box/triggers.rst:170
msgid "Replace triggers"
msgstr ""

#: ../book/box/triggers.rst:178
msgid ""
"Create a \"``replace trigger``\". The ``function-name`` will be executed "
"whenever a ``replace()`` or ``insert()`` or ``update()`` or ``upsert()`` or "
"``delete()`` happens to a tuple in ``<space-name>``."
msgstr ""

#: ../book/box/triggers.rst:190
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"
msgstr ""

#: ../book/box/triggers.rst:199
msgid ""
"At the time that a trigger is defined, it is automatically enabled - that is, it "
"will be executed. Replace triggers can be disabled with :samp:`box.space.{space-"
"name}:run_triggers(false)` and re-enabled with :samp:`box.space.{space-name}:"
"run_triggers(true)`."
msgstr ""

#: ../book/box/triggers.rst:208
msgid "tarantool> box.space.X:run_triggers(false)"
msgstr ""

#: ../book/box/triggers.rst:216
msgid ""
"The following series of requests will create a space, create an index, create a "
"function which increments a counter, create a trigger, do two inserts, drop the "
"space, and display the counter value - which is 2, because the function is "
"executed once after each insert."
msgstr ""

#: ../book/box/triggers.rst:221
msgid ""
"tarantool> s = box.schema.space.create('space53')\n"
"tarantool> s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> function replace_trigger()\n"
"         >   replace_counter = replace_counter + 1\n"
"         > end\n"
"tarantool> s:on_replace(replace_trigger)\n"
"tarantool> replace_counter = 0\n"
"tarantool> t = s:insert{1, 'First replace'}\n"
"tarantool> t = s:insert{2, 'Second replace'}\n"
"tarantool> s:drop()\n"
"tarantool> replace_counter"
msgstr ""

#: ../book/box/triggers.rst:237
#, fuzzy
msgid "Another example"
msgstr "Например:"

#: ../book/box/triggers.rst:239
msgid ""
"The following series of requests will associate an existing function named F "
"with an existing space named T, associate the function a second time with the "
"same space (so it will be called twice), disable all triggers of T, and delete "
"each trigger by replacing with ``nil``."
msgstr ""

#: ../book/box/triggers.rst:244
msgid ""
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"
msgstr ""

#: ../book/box/triggers.rst:256
msgid "Getting a list of triggers"
msgstr ""

#: ../book/box/triggers.rst:258
msgid "You can use:"
msgstr ""

#: ../book/box/triggers.rst:260
msgid ""
":code:`on_connect()` -- with no arguments -- to return a table of all connect-"
"trigger functions;"
msgstr ""

#: ../book/box/triggers.rst:262
msgid ":code:`on_auth()` to return all authentication-trigger functions;"
msgstr ""

#: ../book/box/triggers.rst:263
msgid ":code:`on_disconnect()` to return all disconnect-trigger functions;"
msgstr ""

#: ../book/box/triggers.rst:264
msgid ":code:`on_replace()` to return all replace-trigger functions."
msgstr ""

#: ../book/box/triggers.rst:266
msgid ""
"In the following example, we find that there are three functions associated "
"with :code:`on_connect` triggers, and execute the third function, which happens "
"to contain the line \"print('function #3')\". Then we delete the third trigger."
msgstr ""

#: ../book/box/triggers.rst:272
msgid ""
"tarantool> box.session.on_connect()\n"
"---\n"
"- - 'function: 0x416ab6f8'\n"
"  - 'function: 0x416ab6f8'\n"
"  - 'function: 0x416ad800'\n"
"...\n"
"\n"
"tarantool> box.session.on_connect()[3]()\n"
"function #3\n"
"---\n"
"...\n"
"tarantool> box.session.on_connect(nil, box.session.on_connect()[3])\n"
"---\n"
"..."
msgstr ""

#: ../book/box/index.rst:742
msgid "Limitations"
msgstr "Ограничения"

#: ../book/box/limitations.rst:3 ../book/box/limitations.rst:28
msgid "**Number of parts in an index**"
msgstr ""

#: ../book/box/limitations.rst:5 ../book/box/limitations.rst:30
msgid ""
"For TREE or HASH indexes, the maximum is 255 (``box.schema.INDEX_PART_MAX``). "
"For RTREE indexes, the maximum is 1 but the field is an ARRAY. For BITSET "
"indexes, the maximum is 1."
msgstr ""

#: ../book/box/limitations.rst:11 ../book/box/limitations.rst:36
msgid "**Number of indexes in a space**"
msgstr ""

#: ../book/box/limitations.rst:13 ../book/box/limitations.rst:38
msgid "128 (``box.schema.INDEX_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:17 ../book/box/limitations.rst:42
msgid "**Number of fields in a tuple**"
msgstr ""

#: ../book/box/limitations.rst:19 ../book/box/limitations.rst:44
msgid ""
"The theoretical maximum is 2147483647 (``box.schema.FIELD_MAX``). The practical "
"maximum is whatever is specified by the space's :ref:`field_count <box_space-"
"field_count>` member, or the maximum tuple length."
msgstr ""

#: ../book/box/limitations.rst:26 ../book/box/limitations.rst:51
msgid "**Number of bytes in a tuple**"
msgstr ""

#: ../book/box/limitations.rst:28 ../book/box/limitations.rst:53
msgid ""
"By default the value of :ref:`slab_alloc_maximal <cfg_storage-"
"slab_alloc_maximal>` is 1048576, and the maximum tuple length is approximately "
"one quarter of that: approximately 262,000 bytes. To increase it, when starting "
"the server, specify a larger value. For example :code:`box."
"cfg{slab_alloc_maximal=2*1048576}`."
msgstr ""

#: ../book/box/limitations.rst:36 ../book/box/limitations.rst:61
msgid "**Number of bytes in an index key**"
msgstr ""

#: ../book/box/limitations.rst:38 ../book/box/limitations.rst:63
msgid ""
"If a field in a tuple can contain a million bytes, then the index key can "
"contain a million bytes, so the maximum is determined by factors such as :ref:"
"`Number of bytes in a tuple <limitations_bytes_in_tuple>`, not by the index "
"support."
msgstr ""

#: ../book/box/limitations.rst:45 ../book/box/limitations.rst:70
msgid "**Number of spaces**"
msgstr ""

#: ../book/box/limitations.rst:47 ../book/box/limitations.rst:72
msgid "The theoretical maximum is 2147483647 (``box.schema.SPACE_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:51 ../book/box/limitations.rst:76
msgid "**Number of connections**"
msgstr ""

#: ../book/box/limitations.rst:53 ../book/box/limitations.rst:78
msgid ""
"The practical limit is the number of file descriptors that one can set with the "
"operating system."
msgstr ""

#: ../book/box/limitations.rst:58 ../book/box/limitations.rst:83
msgid "**Space size**"
msgstr ""

#: ../book/box/limitations.rst:60 ../book/box/limitations.rst:85
msgid ""
"The total maximum size for all spaces is in effect set by :ref:`slab_alloc_arena "
"<cfg_storage-slab_alloc_arena>`, which in turn is limited by the total available "
"memory."
msgstr ""

#: ../book/box/limitations.rst:66 ../book/box/limitations.rst:91
msgid "**Update operations count**"
msgstr ""

#: ../book/box/limitations.rst:68 ../book/box/limitations.rst:93
msgid ""
"The maximum number of operations that can be in a single update is 4000 "
"(``BOX_UPDATE_OP_CNT_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:73 ../book/box/limitations.rst:98
msgid "**Number of users and roles**"
msgstr ""

#: ../book/box/limitations.rst:75 ../book/box/limitations.rst:100
msgid "32 (BOX_USER_MAX)."
msgstr ""

#: ../book/box/limitations.rst:79 ../book/box/limitations.rst:104
msgid "**Length of an index name or space name or user name**"
msgstr ""

#: ../book/box/limitations.rst:81 ../book/box/limitations.rst:106
msgid "32 (``box.schema.NAME_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:85 ../book/box/limitations.rst:110
msgid "**Number of replicas in a cluster**"
msgstr ""

#: ../book/box/limitations.rst:87 ../book/box/limitations.rst:112
msgid "32 (``box.schema.REPLICA_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:91 ../book/box/limitations.rst:116
msgid ""
"For additional limitations which apply only to the vinyl storage engine, see "
"section :ref:`Differences between memtx and vinyl <vinyl_diff>`."
msgstr ""

#: ../book/box/index.rst:750
msgid "Vinyl storage engine"
msgstr "Дисковый движок vinyl"

#: ../book/box/vinyl.rst:3
msgid ""
"A storage engine is a set of very-low-level routines which actually store and "
"retrieve tuple values. Tarantool offers a choice of two storage engines:"
msgstr ""

#: ../book/box/vinyl.rst:6
msgid ""
"memtx (the in-memory storage engine) is the default and was the first to arrive."
msgstr ""

#: ../book/box/vinyl.rst:9
msgid ""
"vinyl (the on-disk storage engine) is a working key-value engine and will "
"especially appeal to users who like to see data go directly to disk, so that "
"recovery time might be shorter and database size might be larger. On the other "
"hand, vinyl lacks some functions and options that are available with memtx. "
"Where that is the case, the relevant description in this manual will contain a "
"note beginning with the words \"Note re storage engine\". See also a coverage "
"for all :ref:`the differences between memtx and vinyl <vinyl_diff>` further on "
"this page."
msgstr ""

#: ../book/box/vinyl.rst:18
msgid ""
"To specify that the engine should be vinyl, add the clause ``engine = 'vinyl'`` "
"when creating a space, for example: ``space = box.schema.space.create('name', "
"{engine='vinyl'})``."
msgstr ""

#: ../book/box/vinyl.rst:26
msgid "Differences between memtx and vinyl storage engines"
msgstr "Различия между движками memtx и vinyl"

#: ../book/box/vinyl.rst:28
msgid ""
"The primary difference between memtx and vinyl is that memtx is an \"in-memory\" "
"engine while vinyl is an \"on-disk\" engine. An in-memory storage engine is "
"generally faster, and the memtx engine is justifiably the default for Tarantool, "
"but there are two situations where an on-disk engine such as vinyl would be "
"preferable:"
msgstr ""

#: ../book/box/vinyl.rst:34
msgid ""
"when the database is larger than the available memory and adding more memory is "
"not a realistic option;"
msgstr ""

#: ../book/box/vinyl.rst:36
msgid ""
"when the server frequently goes down due to errors or a simple desire to save "
"power -- bringing the server back up and restoring a memtx database into memory "
"takes time."
msgstr ""

#: ../book/box/vinyl.rst:40
msgid ""
"Here are behavior differences which affect programmers. All of these differences "
"have been noted elsewhere in sentences that begin with the words \"Note re "
"storage engine: vinyl\"."
msgstr ""

#: ../book/box/vinyl.rst:44
msgid ""
"With memtx, the index type can be TREE or HASH or RTREE or BITSET. |br| With "
"vinyl, the only index type is TREE."
msgstr ""

#: ../book/box/vinyl.rst:47
msgid ""
"With memtx, :ref:`create_index <box_space-create_index>` can be done at any "
"time. |br| With vinyl, secondary indexes must be created before tuples are "
"inserted."
msgstr ""

#: ../book/box/vinyl.rst:50
msgid ""
"With memtx, for index searches, ``nil`` is considered to be equal to any scalar. "
"|br| With vinyl, ``nil`` or missing parts are not allowed."
msgstr ""

#: ../book/box/vinyl.rst:53
msgid "With memtx, temporary spaces are supported. |br| With vinyl, they are not."
msgstr ""

#: ../book/box/vinyl.rst:56
msgid ""
"With memtx, the :ref:`alter() <box_index-alter>` and :ref:`len() <box_space-"
"len>` and :ref:`random() <box_index-random>` and :ref:`auto_increment() "
"<box_space-auto_increment>` and :ref:`truncate() <box_space-truncate>` functions "
"are supported. |br| With vinyl, they are not."
msgstr ""

#: ../book/box/vinyl.rst:61
msgid ""
"With memtx, the :ref:`count() <box_index-count>` function takes a constant "
"amount of time. |br| With vinyl, it takes a variable amount of time depending on "
"index size."
msgstr ""

#: ../book/box/vinyl.rst:65
msgid ""
"With memtx, delete will return deleted tuple, if any. |br| With vinyl, delete "
"will always return nil."
msgstr ""

#: ../book/box/vinyl.rst:68
msgid ""
"It was explained :ref:`earlier <index-yields_must_happen>` that memtx does not "
"\"yield\" on a select request, it yields only on data-change requests. However, "
"vinyl does yield on a select request, or on an equivalent such as ``get()`` or "
"``pairs()``. This has significance for :ref:`cooperative multitasking <atomic-"
"cooperative_multitasking>`."
msgstr ""

#: ../book/box/vinyl.rst:76
msgid "Vinyl features"
msgstr ""

#: ../book/box/vinyl.rst:78
msgid "Full ACID compliance"
msgstr ""

#: ../book/box/vinyl.rst:79
msgid "Multi-Version Concurrency Control (MVCC)"
msgstr ""

#: ../book/box/vinyl.rst:80
msgid "Pure Append-Only"
msgstr ""

#: ../book/box/vinyl.rst:81
msgid "Multi-threaded (Client access and Engine scalability)"
msgstr ""

#: ../book/box/vinyl.rst:82
msgid "Multi-databases support (Single environment and WAL)"
msgstr ""

#: ../book/box/vinyl.rst:83
msgid ""
"Multi-Statement and Single-Statement Transactions (Snapshot Isolation (SI), "
"multi-databases)"
msgstr ""

#: ../book/box/vinyl.rst:85
msgid ""
"Asynchronous or synchronous transaction execution (Callback triggered versus "
"blocking)"
msgstr ""

#: ../book/box/vinyl.rst:87
msgid ""
"Separate storage formats: key-value (Default), or document (Keys are part of "
"value)"
msgstr ""

#: ../book/box/vinyl.rst:89
msgid "Update without read"
msgstr ""

#: ../book/box/vinyl.rst:90
msgid "Consistent Cursors"
msgstr ""

#: ../book/box/vinyl.rst:91
msgid "Prefix search"
msgstr ""

#: ../book/box/vinyl.rst:92
msgid "Point-in-Time Snapshots"
msgstr ""

#: ../book/box/vinyl.rst:93
msgid "Versional database creation and asynchronous shutdown/drop"
msgstr ""

#: ../book/box/vinyl.rst:94
msgid "Asynchronous Online/Hot Backup"
msgstr ""

#: ../book/box/vinyl.rst:95
msgid "Compression (Per region, both lz4 and zstd are supported)"
msgstr ""

#: ../book/box/vinyl.rst:96
msgid "Metadata Compression (By default)"
msgstr ""

#: ../book/box/vinyl.rst:97
msgid "Key Compression (Compress key duplicates, including suffixes)"
msgstr ""

#: ../book/box/vinyl.rst:98
msgid "Easy to use (Minimalist API)"
msgstr ""

#: ../book/box/vinyl.rst:99
msgid "Easy to integrate (Native support of using as storage engine)"
msgstr ""

#: ../book/box/vinyl.rst:100
msgid ""
"Easy to write bindings (Very FFI-friendly, API designed to be stable in future)"
msgstr ""

#: ../book/box/vinyl.rst:101
msgid "Easy to build in (Amalgamated, compiles into two C files)"
msgstr ""

#: ../book/box/vinyl.rst:102
msgid "Event loop friendly"
msgstr ""

#: ../book/box/vinyl.rst:103
msgid "Zero-Configuration (Tuned by default)"
msgstr ""

#: ../book/box/vinyl.rst:104
msgid "Implemented as a small library **written in C** with zero dependencies"
msgstr ""

#: ../book/box/vinyl.rst:105
msgid "BSD Licensed"
msgstr ""

#: ../book/box/vinyl.rst:107
msgid ""
"It is appropriate for databases that cannot fit in memory, where access via "
"secondary keys is not required."
msgstr ""

#: ../book/box/vinyl.rst:110
msgid "In vinyl terminology:"
msgstr ""

#: ../book/box/vinyl.rst:112
msgid "There is one **Environment**."
msgstr ""

#: ../book/box/vinyl.rst:113
msgid ""
"An Environment has N **Databases** - a vinyl database is like a Tarantool "
"`space`."
msgstr ""

#: ../book/box/vinyl.rst:114
msgid "A Database has N **Ranges**."
msgstr ""

#: ../book/box/vinyl.rst:115
msgid "A Range has one **Range File**."
msgstr ""

#: ../book/box/vinyl.rst:116
msgid "A Range File has N **Runs**."
msgstr ""

#: ../book/box/vinyl.rst:117
msgid "A Run has N **Regions** - a vinyl Region is like a B-tree `page`."
msgstr ""

#: ../book/box/vinyl.rst:118
msgid ""
"A Region has **keys** and **values** - a vinyl key-value is like a Tarantool "
"`tuple`."
msgstr ""

#: ../book/box/vinyl.rst:120
msgid ""
"A key and its associated value are together, so when one accesses a key one gets "
"the whole tuple. In other words, in vinyl the data is stored in the index. There "
"are up to two in-memory copies of an index, as well as the copy in the Range "
"File."
msgstr ""

#: ../book/box/vinyl.rst:124
msgid ""
"For operations that insert or update tuples - called Set operations in vinyl - "
"vinyl makes changes to in-memory copies of the index, and writes to Tarantool's "
"Write-ahead Log. A scheduler assigns tasks to multiple background threads for "
"transferring index data from memory to disk, and for reorganizing Runs. To "
"support transactions, Set operations can be delayed until an explicit commit. If "
"multiple users access the same tuples simultaneously, the concurrency control "
"method is `MVCC`_ and the isolation level is `Snapshot`_."
msgstr ""

#: ../book/box/vinyl.rst:135
msgid ""
"Formally, in terms of disk accesses, vinyl has the following algorithmic "
"complexity:"
msgstr ""

#: ../book/box/vinyl.rst:137
msgid ""
"**Set** - the worst case is O(*1*) append-only key writes to the Write-Ahead Log "
"+ in-memory Range index searches + in-memory index inserts"
msgstr ""

#: ../book/box/vinyl.rst:139
msgid ""
"**Delete** - the worst case is O(*1*) key writes and in-memory index inserts "
"(the same as **Set**)"
msgstr ""

#: ../book/box/vinyl.rst:141
msgid ""
"**Get** - the worst case is `amortized`_ O(*max\\_run\\_count\\_per\\_node*) "
"random Region reads from a single Range file, which itself does in-memory index "
"search + in-memory Region search"
msgstr ""

#: ../book/box/vinyl.rst:144
msgid ""
"**Range** - queries, the worst case of full Database scan is amortized O(*total"
"\\_Region\\_count*) + in-memory key-index searches for each Range"
msgstr ""

#: ../book/box/vinyl.rst:151
msgid "Under the hood"
msgstr "А что там \"под капотом\"?"

#: ../book/box/vinyl.rst:153
msgid "In this section, to illustrate internals, we will discuss this example:"
msgstr ""

#: ../book/box/vinyl.rst:155
msgid ""
"filling an empty database with one million tuples (we'll call them \"keys\" to "
"emphasize the indexed nature)"
msgstr ""

#: ../book/box/vinyl.rst:157
msgid "reading all stored tuples in the original order."
msgstr ""

#: ../book/box/vinyl.rst:161
msgid "Inserting the first 200.000 keys"
msgstr ""

#: ../book/box/vinyl.rst:163
msgid ""
"During the first 200,000 Set operations, inserted keys first go to the in-memory "
"index. To maintain persistence, information about each Set operation is written "
"to Tarantool's Write-ahead Log."
msgstr ""

#: ../book/box/vinyl.rst:171
msgid ""
"At this point, we have keys in an in-memory index and records in the Write-ahead "
"Log."
msgstr ""

#: ../book/box/vinyl.rst:175
msgid "Inserting the next 300.000 keys"
msgstr ""

#: ../book/box/vinyl.rst:177
msgid ""
"As the in-memory index becomes too large for available memory, the index must be "
"copied from memory to disk. The on-disk copy of the in-memory index is called a "
"Run. To save the Run, a new file is created, the Range File. We will call it "
"**db file** for this example."
msgstr ""

#: ../book/box/vinyl.rst:182
msgid ""
"The scheduler wakes a worker thread in the background, a Run Creation Thread. "
"The thread creates a second in-memory index. If there are Set operations taking "
"place while the thread is working, their contention effect will be small because "
"they will operate on the second in-memory index."
msgstr ""

#: ../book/box/vinyl.rst:191
msgid ""
"When the Run Creation Thread finishes the task, the first in-memory index is "
"freed."
msgstr ""

#: ../book/box/vinyl.rst:200
msgid "Inserting the next 200.000 keys"
msgstr ""

#: ../book/box/vinyl.rst:202
msgid ""
"Several times, the in-memory index becomes too large and a Run Creation Thread "
"transfers the keys to a Run. The Runs have been appended to the end of db file. "
"The number of created Runs becomes large."
msgstr ""

#: ../book/box/vinyl.rst:210
msgid ""
"There is a user-settable maximum number of Runs per Range. When the number of "
"Runs reaches this maximum, the vinyl scheduler wakes a **Compaction Thread** for "
"the db file. The Compaction Thread merges the keys in all the Runs, and creates "
"one or more new db files."
msgstr ""

#: ../book/box/vinyl.rst:219
msgid ""
"Now there are multiple pairs of in-memory indexes, and each pair has an "
"associated db file. The combination of the in-memory indexes and the db file is "
"called a **Range**, and the db file is called a **Range File**."
msgstr ""

#: ../book/box/vinyl.rst:227
msgid ""
"Thus the contents of a Range are: a range of sorted key values, stored in Runs "
"of a Range File and (when necessary) in memory. Since the ranges do not overlap, "
"each Range can be handled independently. Therefore, while one of the background "
"threads is working on Range 1, another background thread can be working on Range "
"2, without contention. That means that all the background operations (Run "
"Creation, Compaction, Garbage Collection, and Backup) can take place in parallel "
"on multiple threads."
msgstr ""

#: ../book/box/vinyl.rst:235
msgid "The foregoing explanation will now be repeated with different wording."
msgstr ""

#: ../book/box/vinyl.rst:237
msgid ""
"Before the Compaction there was one Range, which was created automatically when "
"the Database was initialized. The Range had:"
msgstr ""

#: ../book/box/vinyl.rst:240
msgid "an in-memory index with some keys in it,"
msgstr ""

#: ../book/box/vinyl.rst:241
msgid "a Range File with several Runs,"
msgstr ""

#: ../book/box/vinyl.rst:242
msgid ""
"a Write-Ahead Log file recording the Set operations, in the order they happened."
msgstr ""

#: ../book/box/vinyl.rst:244
msgid ""
"The number of Runs became too big, so the vinyl scheduler starts the Compaction "
"Thread and creates two new Ranges."
msgstr ""

#: ../book/box/vinyl.rst:251
msgid ""
"So, each of the two new Range Files contains half of the keys that were in the "
"original Range. The Range's in-memory indexes are split in the same way."
msgstr ""

#: ../book/box/vinyl.rst:254
msgid ""
"After the splitting, vinyl must take into account that: while the Compaction was "
"going on in the background, there might have been more Set operations taking "
"place in parallel. These Set operations would have changed one of the in-memory "
"indexes, and these changes too will be merged."
msgstr ""

#: ../book/box/vinyl.rst:259
msgid ""
"When the Compaction Thread finishes, the original Range is deleted, and "
"information about the new Ranges is inserted into an in-memory **Range Index**."
msgstr ""

#: ../book/box/vinyl.rst:266
msgid ""
"This Range Index is used for all Set operations and all searches. Since the "
"Range Index has the minimum and maximum key values that are in each Range, it is "
"straightforward to scan it to find what Range would contain a particular key "
"value."
msgstr ""

#: ../book/box/vinyl.rst:276
msgid "Inserting the last 300.000 keys"
msgstr ""

#: ../book/box/vinyl.rst:278
msgid ""
"The final 300,000 Set operations take place; the background threads continue to "
"create new Runs and do more Compactions. After the millionth insertion, the "
"Database has four Ranges."
msgstr ""

#: ../book/box/vinyl.rst:286
msgid ""
"The inserting is done. Now, because the words \"memory\" and \"disk\" have "
"appeared in this explanation several times, here are a few words about how vinyl "
"is designed to use these resources most efficiently:"
msgstr ""

#: ../book/box/vinyl.rst:290
msgid ""
"If there is more memory available, then Run Creation and Compaction will be less "
"frequent, and there will be fewer disk accesses."
msgstr ""

#: ../book/box/vinyl.rst:292
msgid ""
"The best vinyl performance will occur if there is no setting of a memory limit, "
"but this must be balanced against other considerations, such as requirements for "
"the memtx storage engine. If there is a setting of a memory limit, the vinyl "
"scheduler will give priority to the Ranges that have the largest in-memory "
"indexes, so that the largest memory blocks are freed first."
msgstr ""

#: ../book/box/vinyl.rst:297
msgid ""
"To make the most of hard drives and Flash, vinyl will delay operations that "
"require disk access (except the writing of the Write-ahead Log which is "
"specially tunable), so that the accesses are done in large sequential blocks."
msgstr ""

#: ../book/box/vinyl.rst:300
msgid "Overwriting does not occur; vinyl is an \"append-only\" engine."
msgstr ""

#: ../book/box/vinyl.rst:304
msgid "Reading million keys"
msgstr ""

#: ../book/box/vinyl.rst:306
msgid ""
"We will now start to read the million rows in the order that they were inserted, "
"which was random."
msgstr ""

#: ../book/box/vinyl.rst:313
msgid ""
"During the Get (search), vinyl first finds the correct Range by looking in the "
"Range Index. Then it searches the Range's first in-memory index, and/or the "
"Range's second in-memory index, and/or each Run of the Range, starting from the "
"end of the Range File."
msgstr ""

#: ../book/box/vinyl.rst:318
msgid ""
"Remember that a Run is divided into Regions, which are like what would be called "
"\"pages\" or \"blocks\" in a B-tree. For each Run, there is a list of the "
"Regions and their minimum/maximum key values - the Region Index - as well as "
"some metadata."
msgstr ""

#: ../book/box/vinyl.rst:327
msgid ""
"Region Indexes are loaded into memory when the Database is opened. Since the "
"Database's Range Index and the Region Indexes are normally in-memory, searching "
"and retrieving a tuple might require only zero or one disk accesses. However, "
"when memory is limited and there are many Runs, search time may rise. For each "
"additional Run there is a possible additional disk access during a search. Also, "
"it is impossible to maintain memory limits without doing a Run Creation process, "
"because new Set operations might occur more quickly than the Compaction process "
"can run."
msgstr ""

#: ../book/box/vinyl.rst:340
msgid ""
"Vinyl is read optimized. It is very likely that the most recently created Runs "
"(hot data) will be in the file system cache. The scheduler will give priority to "
"the Ranges which have the largest in-memory indexes and the most Runs."
msgstr ""

#: ../book/box/vinyl.rst:345
msgid ""
"The scheduler may also try to arrange that a Range will have only one Run, which "
"will ensure the average number of disk seeks for each search is O(*1*)."
msgstr ""

#: ../book/connectors/index.rst:30
msgid "Connectors"
msgstr "Коннекторы"

#: ../book/connectors/index.rst:32
msgid "This chapter documents APIs for various programming languages."
msgstr "В этой главе описаны API для различных языков программирования."

#: ../book/connectors/index.rst:36
msgid "Protocol"
msgstr "Протокол"

#: ../book/connectors/index.rst:38
msgid ""
"Tarantool's binary protocol was designed with a focus on asynchronous I/O and "
"easy integration with proxies. Each client request starts with a variable-length "
"binary header, containing request id, request type, server id, log sequence "
"number, and so on."
msgstr ""
"Бинарный протокол для передачи данных в Tarantool'е был разработан с учетом "
"потребностей асинхронного ввода-вывода. Основная его задача — облегчить "
"интеграцию Tarantool'а с клиентскими приложениями. Клиентский запрос в Tarantool-"
"протоколе начинается с бинарного заголовка переменной длины. В заголовке "
"указывается идентификатор и тип запроса, идентификатор сервера, номер записи в "
"журнале и т.д."

#: ../book/connectors/index.rst:43
msgid ""
"The mandatory length, present in request header simplifies client or proxy I/O. "
"A response to a request is sent to the client as soon as it is ready. It always "
"carries in its header the same type and id as in the request. The id makes it "
"possible to match a request to a response, even if the latter arrived out of "
"order."
msgstr ""
"Также в заголовке обязательно указывается длина запроса, что облегчает обработку "
"данных. Ответ на запрос посылается по мере готовности. В заголовке ответа "
"указывается тот же идентификатор и тип запроса, что и в изначальном запросе. По "
"идентификатору можно легко соотнести запрос с ответом, даже если ответ был "
"получен не в порядке отсылки запросов."

#: ../book/connectors/index.rst:49
msgid ""
"Unless implementing a client driver, you needn't concern yourself with the "
"complications of the binary protocol. Language-specific drivers provide a "
"friendly way to store domain language data structures in Tarantool. A complete "
"description of the binary protocol is maintained in annotated Backus-Naur form "
"in the source tree: please see the page about :ref:`Tarantool's binary protocol "
"<box_protocol-iproto_protocol>`."
msgstr ""
"Вдаваться в тонкости реализации Tarantool-протокола нужно только при разработке "
"нового коннектора для Tarantool'а — см. :ref:`полное описание бинарного "
"протокола в Tarantool'е <box_protocol-iproto_protocol>` в виде аннотированных "
"BNF-диаграмм (Backus-Naur Form). В остальных случаях достаточно взять уже "
"существующий коннектор для нужного вам языка программирования. Такие коннекторы "
"позволяют легко хранить структуры данных из разных языков в формате Tarantool'а."

#: ../book/connectors/index.rst:58
msgid "Packet example"
msgstr "Пример пакета данных"

#: ../book/connectors/index.rst:60
msgid ""
"The Tarantool API exists so that a client program can send a request packet to "
"the server, and receive a response. Here is an example of a what the client "
"would send for :samp:`box.space[513]:insert{'A', 'BB'}`. The BNF description of "
"the components is on the page about :ref:`Tarantool's binary protocol "
"<box_protocol-iproto_protocol>`."
msgstr ""
"С помощью Tarantool API клиентские программы могут посылать в адрес Tarantool-"
"сервера пакеты с запросами и получать на них ответы. Вот пример исходящего "
"пакета, который будет сформирован для запроса :code:`box.space[513]:insert{'A', "
"'BB'}`. Описания компонентов запроса (в виде BNF-диаграмм) вы найдете на "
"странице о :ref:`бинарном протоколе в Tarantool'е <box_protocol-"
"iproto_protocol>`."

#: ../book/connectors/index.rst:76
msgid "Component"
msgstr "Компонент"

#: ../book/connectors/index.rst:76
msgid "Byte #0"
msgstr "Байт #0"

#: ../book/connectors/index.rst:76
msgid "Byte #1"
msgstr "Байт #1"

#: ../book/connectors/index.rst:76
msgid "Byte #2"
msgstr "Байт #2"

#: ../book/connectors/index.rst:76
msgid "Byte #3"
msgstr "Байт #3"

#: ../book/connectors/index.rst:78
msgid "code for insert"
msgstr "код для вставки"

#: ../book/connectors/index.rst:78 ../book/connectors/index.rst:82
msgid "02"
msgstr "02"

#: ../book/connectors/index.rst:80
msgid "rest of header"
msgstr "остаток заголовка"

#: ../book/connectors/index.rst:80
msgid "..."
msgstr "..."

#: ../book/connectors/index.rst:82
msgid "2-digit number: space id"
msgstr "число из 2 цифр: ID пространства"

#: ../book/connectors/index.rst:82
msgid "cd"
msgstr "cd"

#: ../book/connectors/index.rst:82
msgid "01"
msgstr "01"

#: ../book/connectors/index.rst:84
msgid "code for tuple"
msgstr "код для кортежа"

#: ../book/connectors/index.rst:84
msgid "21"
msgstr "21"

#: ../book/connectors/index.rst:86
msgid "1-digit number: field count = 2"
msgstr "число из 1 цифры: количество полей = 2"

#: ../book/connectors/index.rst:86
msgid "92"
msgstr "92"

#: ../book/connectors/index.rst:88
msgid "1-character string: field[1]"
msgstr "строка из 1 символа: поле[1]"

#: ../book/connectors/index.rst:88
msgid "a1"
msgstr "a1"

#: ../book/connectors/index.rst:88
msgid "41"
msgstr "41"

#: ../book/connectors/index.rst:90
msgid "2-character string: field[2]"
msgstr "строка из 2 символов: поле[2]"

#: ../book/connectors/index.rst:90
msgid "a2"
msgstr "a2"

#: ../book/connectors/index.rst:90
msgid "42"
msgstr "42"

#: ../book/connectors/index.rst:93
msgid ""
"Now, you could send that packet to the Tarantool server, and interpret the "
"response (the page about :ref:`Tarantool's binary protocol <box_protocol-"
"iproto_protocol>` has a description of the packet format for responses as well "
"as requests). But it would be easier, and less error-prone, if you could invoke "
"a routine that formats the packet according to typed parameters. Something like :"
"samp:`response=tarantool_routine(\"insert\",513,\"A\",\"B\");`. And that is why "
"APIs exist for drivers for Perl, Python, PHP, and so on."
msgstr ""
"Теперь получившийся пакет можно послать Tarantool-серверу и затем "
"проинтерпретировать полученный ответ (описания компонентов ответа вы найдете на "
"той же странице о :ref:`бинарном протоколе в Tarantool'е <box_protocol-"
"iproto_protocol>`). Но более простым и верным способом будет вызвать процедуру, "
"которая за вас сформирует готовый пакет с заданными параметрами. Что-то вроде :"
"samp:`response=tarantool_routine(\"insert\",513,\"A\",\"B\");`. Для этого в "
"Tarantool'е существуют API для Perl, Python, PHP и других программных языков."

#: ../book/connectors/index.rst:106
msgid "Setting up the server for connector examples"
msgstr "Настройка окружения для примеров работы с коннекторами"

#: ../book/connectors/index.rst:108
msgid ""
"This chapter has examples that show how to connect to the Tarantool server via "
"the Perl, PHP, Python, and C connectors. The examples contain hard code that "
"will work if and only if the following conditions are met:"
msgstr ""
"В этой главе приводятся примеры того, как можно установить соединение с "
"Tarantool-сервером с помощью коннекторов для языков Perl, PHP, Python и C. "
"Обратите внимание, что в примерах исходного кода указаны фиксированные значения "
"для элементов тестового окружения, поэтому для корректной работы всех примеров "
"нужно соблюсти следующие условия:"

#: ../book/connectors/index.rst:112
msgid ""
"the server (tarantool) is running on localhost (127.0.0.1) and is listening on "
"port 3301 (:samp:`box.cfg.listen = '3301'`),"
msgstr ""
"Tarantool-сервер запущен на локальной машине (``localhost = 127.0.0.1``), а "
"прослушивание для него настроено на порту 3301 (:samp:`box.cfg.listen = '3301'`),"

#: ../book/connectors/index.rst:115
msgid ""
"space ``examples`` has id = 999 (:samp:`box.space.examples.id = 999`) and has a "
"primary-key index for a numeric field (:samp:`box.space[999].index[0].parts[1]."
"type = \"unsigned\"`),"
msgstr ""
"в базе есть пространство ``examples`` с идентификатором 999 (:samp:`box.space."
"examples.id = 999`) и у него есть первичный индекс, построенный по ключу "
"числового типа (:samp:`box.space[999].index[0].parts[1].type = \"unsigned\"`),"

#: ../book/connectors/index.rst:119
msgid "user 'guest' has privileges for reading and writing."
msgstr "для пользователя 'guest' настроены привилегии на чтение и запись."

#: ../book/connectors/index.rst:121
msgid ""
"It is easy to meet all the conditions by starting the server and executing this "
"script:"
msgstr ""
"Такое тестовое окружение легко настроить, запустив Tarantool-сервер локально и "
"выполнив следующие запросы:"

#: ../book/connectors/index.rst:124
msgid ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"
msgstr ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"

#: ../book/connectors/__java.rst:3
msgid "Java"
msgstr "Java"

#: ../book/connectors/__java.rst:5
msgid "See http://github.com/tarantool/tarantool-java/."
msgstr "См. http://github.com/tarantool/tarantool-java/."

#: ../book/connectors/__go.rst:3
msgid "Go"
msgstr "Go"

#: ../book/connectors/__go.rst:5
msgid "Please see https://github.com/mialinx/go-tarantool."
msgstr "См. https://github.com/mialinx/go-tarantool."

#: ../book/connectors/__r.rst:3
msgid "R"
msgstr "R"

#: ../book/connectors/__r.rst:5
msgid "See https://github.com/thekvs/tarantoolr."
msgstr "См. https://github.com/thekvs/tarantoolr."

#: ../book/connectors/__perl.rst:3
msgid "Perl"
msgstr "Perl"

#: ../book/connectors/__perl.rst:5
msgid ""
"The most commonly used Perl driver is `DR::Tarantool <http://search.cpan.org/"
"~unera/DR-Tarantool/>`_. It is not supplied as part of the Tarantool repository; "
"it must be installed separately. The most common way to install it is with "
"`CPAN, the Comprehensive Perl Archive Network <https://en.wikipedia.org/wiki/"
"Cpan>`_. ``DR::Tarantool`` requires other modules which should be installed "
"first. For example, on Ubuntu, the installation could look like this:"
msgstr ""
"Наиболее популярным Tarantool-коннектором для языка Perl является `DR::Tarantool "
"<http://search.cpan.org/~unera/DR-Tarantool/>`_. Он устанавливается отдельно от "
"Tarantool'а, например с помощью :program:`cpan` (см. `CPAN, the Comprehensive "
"Perl Archive Network <https://en.wikipedia.org/wiki/Cpan>`_), и требует "
"предварительной установки еще несколько зависимых модулей. Вот пример установки "
"этого коннектора под Ubuntu:"

#: ../book/connectors/__perl.rst:13
msgid ""
"$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction\n"
"$ sudo cpan install Coro\n"
"$ sudo cpan install Test::Pod\n"
"$ sudo cpan install Test::Spelling\n"
"$ sudo cpan install PAR::Dist\n"
"$ sudo cpan install List::MoreUtils\n"
"$ sudo cpan install DR::Tarantool"
msgstr ""
"$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction\n"
"$ sudo cpan install Coro\n"
"$ sudo cpan install Test::Pod\n"
"$ sudo cpan install Test::Spelling\n"
"$ sudo cpan install PAR::Dist\n"
"$ sudo cpan install List::MoreUtils\n"
"$ sudo cpan install DR::Tarantool"

#: ../book/connectors/__perl.rst:24
msgid ""
"Here is a complete Perl program that inserts ``[99999,'BB']`` into "
"``space[999]`` via the Perl API. Before trying to run, check that the server is "
"listening at ``localhost:3301`` and that the space ``examples`` exists, as :ref:"
"`described earlier <index-connector_setting>`. To run, paste the code into a "
"file named :file:`example.pl` and say :samp:`perl example.pl`. The program will "
"connect using an application-specific definition of the space. The program will "
"open a socket connection with the Tarantool server at ``localhost:3301``, then "
"send an INSERT request, then — if all is well — end without displaying any "
"messages. If Tarantool is not running on ``localhost`` with listen port = 3301, "
"the program will print “Connection refused”."
msgstr ""
"Далее приводится пример полноценной программы на языке Perl, которая "
"осуществляет вставку кортежа ``[99999,'BB']`` в пространство ``space[999]`` с "
"помощью Tarantool API для языка Perl. Перед запуском данной программы проверьте, "
"что ваше тестовое окружение настроено так, как :ref:`описано выше <index-"
"connector_setting>` (у Tarantool-сервера задан порт для прослушивания и в базе "
"создано пространство ``examples``). Чтобы запустить тестовую программу, "
"сохраните ее исходный код в файл с именем :file:`example.pl` и выполните "
"команду :samp:`perl example.pl`. Программа установит соединение, используя "
"указанное в ней описание пространства, откроет сокет для соединения с Tarantool-"
"сервером по адресу ``localhost:3301``, пошлет INSERT-запрос, а затем — если всё "
"хорошо — закончит работу без каких-либо сообщений. Если окажется, что Tarantool-"
"сервер не запущен на прослушивание по указанному адресу, то программа выдаст "
"сообщение об ошибке “Connection refused”."

#: ../book/connectors/__perl.rst:36
msgid ""
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # look for tarantool on "
"localhost\n"
"  port    => 3301,                             # on port 3301\n"
"  user    => 'guest',                          # username. one could also say "
"'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # definition of space[999] ...\n"
"      name => 'examples',                      #   space[999] name = 'examples'\n"
"      default_type => 'STR',                   #   space[999] field type is "
"'STR' if undefined\n"
"      fields => [ {                            #   definition of space[999]."
"fields ...\n"
"          name => 'field1', type => 'NUM' } ], #     space[999].field[1] "
"name='field1',type='NUM'\n"
"      indexes => {                             #   definition of space[999] "
"indexes ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"
msgstr ""
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # поиск Tarantool-сервера по "
"адресу localhost\n"
"  port    => 3301,                             # на порту 3301\n"
"  user    => 'guest',                          # имя пользователя; здесь же "
"можно добавить 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # определение пространства "
"space[999] ...\n"
"      name => 'examples',                      # имя пространства space[999] = "
"'examples'\n"
"      default_type => 'STR',                   # если тип поля в space[999] не "
"задан, то = 'STR'\n"
"      fields => [ {                            # определение полей в "
"пространстве space[999] ...\n"
"          name => 'field1', type => 'NUM' } ], # имя поля space[999]."
"field[1]='field1', тип ='NUM'\n"
"      indexes => {                             # определение индексов "
"пространства space[999] ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"

#: ../book/connectors/__perl.rst:60
msgid ""
"The example program uses field type names 'STR' and 'NUM' instead of 'string' "
"and 'unsigned', due to a temporary Perl limitation."
msgstr ""
"Из-за существующих ограничений в языке Perl, вместо полей типа 'string' и "
"'unsigned' в тестовой программе указаны поля типа 'STR' и 'NUM'."

#: ../book/connectors/__perl.rst:63
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `DR::Tarantool CPAN repository "
"<http://search.cpan.org/~unera/DR-Tarantool/>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для "
"полноценной работы с Tarantool'ом с помощью Perl API, пожалуйста, обратитесь к "
"документации из `CPAN-репозитория DR::Tarantool <http://search.cpan.org/~unera/"
"DR-Tarantool/>`_."

#: ../book/connectors/__php.rst:3
msgid "PHP"
msgstr "PHP"

#: ../book/connectors/__php.rst:5
msgid ""
"The PHP driver is `tarantool-php <https://github.com/tarantool/tarantool-php>`_. "
"It is not supplied as part of the Tarantool repository; it must be installed "
"separately. It can be installed with :program:`git`. It requires other modules "
"which should be installed first. For example, on Ubuntu, the installation could "
"look like this:"
msgstr ""
"Tarantool-коннектор для языка PHP называется `tarantool-php <https://github.com/"
"tarantool/tarantool-php>`_. Он устанавливается отдельно от Tarantool'а с "
"помощью :program:`git` и требует предварительной установки еще несколько "
"зависимых модулей. Вот пример установки этого коннектора под Ubuntu:"

#: ../book/connectors/__php.rst:11
msgid ""
"$ sudo apt-get install php5-cli\n"
"$ sudo apt-get install php5-dev\n"
"$ sudo apt-get install php-pear\n"
"$ cd ~\n"
"$ git clone https://github.com/tarantool/tarantool-php.git\n"
"$ cd tarantool-php\n"
"$ phpize\n"
"$ ./configure\n"
"$ make\n"
"$ # make install is optional"
msgstr ""
"$ sudo apt-get install php5-cli\n"
"$ sudo apt-get install php5-dev\n"
"$ sudo apt-get install php-pear\n"
"$ cd ~\n"
"$ git clone https://github.com/tarantool/tarantool-php.git\n"
"$ cd tarantool-php\n"
"$ phpize\n"
"$ ./configure\n"
"$ make\n"
"$ # make install is optional"

#: ../book/connectors/__php.rst:25
msgid ""
"At this point there is a file named :file:`~/tarantool-php/modules/tarantool."
"so`. PHP will only find it if the PHP initialization file :file:`php.ini` "
"contains a line like :samp:`extension=./tarantool.so`, or if PHP is started with "
"the option :samp:`-d extension=~/tarantool-php/modules/tarantool.so`."
msgstr ""
"После отработки всех команд будет создан файл с именем :file:`~/tarantool-php/"
"modules/tarantool.so`. PHP увидит его, только если в файле инициализации :file:"
"`php.ini` есть строка вида :samp:`extension=./tarantool.so`, либо если при "
"запуске PHP вы укажете опцию :samp:`-d extension=~/tarantool-php/modules/"
"tarantool.so`."

#: ../book/connectors/__php.rst:30
msgid ""
"Here is a complete PHP program that inserts ``[99999,'BB']`` into a space named "
"``examples`` via the PHP API. Before trying to run, check that the server is "
"listening at ``localhost:3301`` and that the space ``examples`` exists, as :ref:"
"`described earlier <index-connector_setting>`. To run, paste the code into a "
"file named :file:`example.php` and say :samp:`php -d extension=~/tarantool-php/"
"modules/tarantool.so example.php`. The program will open a socket connection "
"with the Tarantool server at ``localhost:3301``, then send an INSERT request, "
"then — if all is well — print \"Insert succeeded\". If the tuple already exists, "
"the program will print “Duplicate key exists in unique index 'primary' in space "
"'examples'”."
msgstr ""
"Далее приводится пример полноценной программы на языке PHP, которая осуществляет "
"вставку кортежа ``[99999,'BB']`` в пространство ``examples`` с помощью Tarantool "
"API для языка PHP. Перед запуском данной программы проверьте, что ваше тестовое "
"окружение настроено так, как :ref:`описано выше <index-connector_setting>` (у "
"Tarantool-сервера задан порт для прослушивания и в базе создано пространство "
"``examples``). Чтобы запустить тестовую программу, сохраните ее исходный код в "
"файл с именем :file:`example.php` и выполните команду :samp:`php -d extension=~/"
"tarantool-php/modules/tarantool.so example.php`. Программа откроет сокет для "
"соединения с Tarantool-сервером по адресу ``localhost:3301``, пошлет INSERT-"
"запрос, а затем — если всё хорошо — выдаст сообщение \"Insert succeeded\". Если "
"окажется, что такой кортеж уже существует, то программа выдаст сообщение об "
"ошибке “Duplicate key exists in unique index 'primary' in space 'examples'”."

#: ../book/connectors/__php.rst:41
msgid ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', array(99999, 'BB'));\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo \"Exception: \", $e->getMessage(), \"\\n\";\n"
"}"
msgstr ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', array(99999, 'BB'));\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo \"Exception: \", $e->getMessage(), \"\\n\";\n"
"}"

#: ../book/connectors/__php.rst:53
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool-php project at "
"GitHub <https://github.com/tarantool/tarantool-php>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для "
"полноценной работы с Tarantool'ом с помощью PHP API, пожалуйста, обратитесь к "
"документации из `проекта tarantool-php на GitHub <https://github.com/tarantool/"
"tarantool-php>`_."

#: ../book/connectors/__python.rst:3
msgid "Python"
msgstr "Python"

#: ../book/connectors/__python.rst:5
msgid ""
"Here is a complete Python program that inserts ``[99999,'Value','Value']`` into "
"space ``examples`` via the high-level Python API."
msgstr ""
"Далее приводится пример полноценной программы на языке Python, которая "
"осуществляет вставку кортежа ``[99999,'Value','Value']`` в пространство "
"``examples`` с помощью высокоуровневого Tarantool API для языка Python. "

#: ../book/connectors/__python.rst:8
msgid ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"
msgstr ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"

#: ../book/connectors/__python.rst:17
msgid ""
"To prepare, paste the code into a file named :file:`example.py` and install the "
"``tarantool-python`` connector with either :samp:`pip install tarantool\\>0.4` "
"to install in :file:`/usr` (requires **root** privilege) or :samp:`pip install "
"tarantool\\>0.4 --user` to install in :file:`~` i.e. user's default directory. "
"Before trying to run, check that the server is listening at ``localhost:3301`` "
"and that the space ``examples`` exists, as :ref:`described earlier <index-"
"connector_setting>`. To run the program, say :samp:`python example.py`. The "
"program will connect to the server, will send the request, and will not throw "
"any exception if all went well. If the tuple already exists, the program will "
"throw ``tarantool.error.DatabaseError: (3, \"Duplicate key exists in unique "
"index 'primary' in space 'examples'\")``."
msgstr ""
"Перед запуском данной программы проверьте, что ваше тестовое окружение настроено "
"так, как :ref:`описано выше <index-connector_setting>` (у Tarantool-сервера "
"задан порт для прослушивания и в базе создано пространство ``examples``), и "
"установите коннектор ``tarantool-python``. Для установки коннектора "
"воспользуйтесь либо командой :samp:`pip install tarantool\\>0.4` (для установки "
"в директорию :file:`/usr`; вам потребуются права уровня  **root**), либо "
"командой :samp:`pip install tarantool\\>0.4 --user` (для установки в директорию :"
"file:`~`, т.е. в используемую по умолчанию директорию текущего пользователя). "
"Чтобы запустить тестовую программу, сохраните ее исходный код в файл с именем :"
"file:`example.py` и выполните команду :samp:`python example.py`. Программа "
"установит соединение с Tarantool-сервером, пошлет запрос и не сгенерирует "
"никакого исключения, если всё прошло хорошо. Если окажется, что такой кортеж уже "
"существует, то программа сгенерирует исключение :samp:`tarantool.error."
"DatabaseError: (3, \"Duplicate key exists in unique index 'primary' in space "
"'examples'\")`."

#: ../book/connectors/__python.rst:29
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool-python project at "
"GitHub <http://github.com/tarantool/tarantool-python>`_. For an example of using "
"Python API with `queue managers for Tarantool <https://github.com/tarantool/"
"queue>`_, see `queue-python project at GitHub <https://github.com/tarantool/"
"queue-python>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для "
"полноценной работы с Tarantool'ом с помощью Python API, пожалуйста, обратитесь к "
"документации из `проекта tarantool-python на GitHub <http://github.com/tarantool/"
"tarantool-python>`_. А на странице `проекта queue-python на GitHub <https://"
"github.com/tarantool/queue-python>`_ вы сможете найти примеры использования "
"Python API для работы с `очередями сообщений в Tarantool'е <https://github.com/"
"tarantool/queue>`_."

#: ../book/connectors/__c.rst:3
msgid "C"
msgstr "C"

#: ../book/connectors/__c.rst:5
msgid "Here follow two examples of using Tarantool's high-level C API."
msgstr ""
"В этом разделе даны два примера использования высокоуровневого API для "
"Tarantool'а и языка C."

#: ../book/connectors/__c.rst:9
msgid "Example 1"
msgstr "Пример 1"

#: ../book/connectors/__c.rst:11
msgid ""
"Here is a complete C program that inserts :code:`[99999,'B']` into space :code:"
"`examples` via the high-level C API."
msgstr ""
"Далее приводится пример полноценной программы на языке C, которая осуществляет "
"вставку кортежа ``[99999,'B']`` в пространство ``examples`` с помощью "
"высокоуровневого Tarantool API для языка C. "

#: ../book/connectors/__c.rst:14
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* See note = SETUP */\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* See note = CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* See note = MAKE REQUEST "
"*/\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* See note = SEND REQUEST "
"*/\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* See note = GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* See below = TEARDOWN */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* См. ниже = НАСТРОЙКА */\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* См. ниже = СОЕДИНЕНИЕ */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* См. ниже = СОЗДАНИЕ "
"ЗАПРОСА */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* См. ниже = ОТПРАВКА "
"ЗАПРОСА */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* См. ниже = ПОЛУЧЕНИЕ "
"ОТВЕТА */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* См. ниже = ЗАВЕРШЕНИЕ */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"

#: ../book/connectors/__c.rst:44
msgid ""
"Paste the code into a file named :file:`example.c` and install ``tarantool-c``. "
"One way to install ``tarantool-c`` (using Ubuntu) is:"
msgstr ""
"Скопируйте исходный код программы в файл с именем :file:`example.c` и установите "
"коннектор ``tarantool-c``. Вот один из способов установки ``tarantool-c`` (под "
"Ubuntu):"

#: ../book/connectors/__c.rst:47
msgid ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"
msgstr ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"

#: ../book/connectors/__c.rst:57 ../book/connectors/__c.rst:288
msgid "To compile and link the program, say:"
msgstr ""
"Чтобы скомпилировать и слинковать тестовую программу, выполните следующую "
"команду:"

#: ../book/connectors/__c.rst:59
msgid ""
"$ # sometimes this is necessary:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"
msgstr ""
"$ # иногда это необходимо:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"

#: ../book/connectors/__c.rst:65
msgid ""
"Before trying to run, check that the server is listening at ``localhost:3301`` "
"and that the space ``examples`` exists, as :ref:`described earlier <index-"
"connector_setting>`. To run the program, say :samp:`./example`. The program will "
"connect to the server, and will send the request. If Tarantool is not running on "
"localhost with listen address = 3301, the program will print “Connection "
"refused”. If the insert fails, the program will print \"Insert failed\" and an "
"error number (see all error codes in the source file `/src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_)."
msgstr ""
"Перед запуском программы проверьте, что ваше тестовое окружение настроено так, "
"как :ref:`описано выше <index-connector_setting>` (у Tarantool-сервера задан "
"порт для прослушивания и в базе создано пространство ``examples``). Чтобы "
"запустить тестовую программу, выполните команду :samp:`./example`. Программа "
"установит соединение с Tarantool-сервером и пошлет запрос. Если окажется, что "
"Tarantool-сервер не запущен на прослушивание по указанному адресу, то программа "
"выдаст сообщение об ошибке “Connection refused”. А если не пройдет INSERT-"
"запрос, то программа выдаст сообщение \"Insert failed\" и код ошибки (все коды "
"ошибок в Tarantool'е см. в исходном файле `/src/box/errcode.h <https://github."
"com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_)."

#: ../book/connectors/__c.rst:77
msgid "Here are notes corresponding to comments in the example program."
msgstr ""
"Далее следуют примечания, на которые мы ссылались в комментариях к исходному "
"коду тестовой программы."

#: ../book/connectors/__c.rst:79
msgid "**SETUP:** The setup begins by creating a stream."
msgstr "**НАСТРОЙКА:** Настройка начинается с создания потока (``tnt_stream``)."

#: ../book/connectors/__c.rst:81
msgid ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"
msgstr ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"

#: ../book/connectors/__c.rst:86
msgid ""
"In this program, the stream will be named ``tnt``. Before connecting on the "
"``tnt`` stream, some options may have to be set. The most important option is "
"TNT_OPT_URI. In this program, the URI is ``localhost:3301``, since that is where "
"the Tarantool server is supposed to be listening."
msgstr ""
"В нашей тестовой программе поток назван ``tnt``. Перед установкой соединения "
"нужно задать ряд настроечных опций. Самая важная из них — TNT_OPT_URI. Для этой "
"опции указана URI-строка ``localhost:3301``, т.е. адрес, по которому должно быть "
"настроено прослушивание на стороне Tarantool-сервера."

#: ../book/connectors/__c.rst:92 ../book/connectors/__c.rst:108
#: ../book/connectors/__c.rst:136 ../book/connectors/__c.rst:156
#: ../book/connectors/__c.rst:181 ../book/connectors/__c.rst:200
msgid "Function description:"
msgstr "Описание функции:"

#: ../book/connectors/__c.rst:425
msgid ""
"`struct tnt_stream *tnt_net(struct tnt_stream *s)`\n"
"`int tnt_set(struct tnt_stream *s, int option, variant option-value)`"
msgstr ""
"`struct tnt_stream *tnt_net(struct tnt_stream *s)`\n"
"`int tnt_set(struct tnt_stream *s, int option, variant option-value)`"

#: ../book/connectors/__c.rst:100
msgid ""
"**CONNECT:** Now that the stream named ``tnt`` exists and is associated with a "
"URI, this example program can connect to the server."
msgstr ""
"**СОЕДИНЕНИЕ:** Теперь когда мы создали поток с именем ``tnt`` и связали его с "
"конкретным URI, наша программа может устанавливать соединение с Tarantool-"
"сервером."

#: ../book/connectors/__c.rst:103
msgid ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"
msgstr ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"

#: ../book/connectors/__c.rst:441
msgid "int tnt_connect(struct tnt_stream \\*s)"
msgstr "int tnt_connect(struct tnt_stream \\*s)"

#: ../book/connectors/__c.rst:115
msgid ""
"The connection might fail for a variety of reasons, such as: the server is not "
"running, or the URI contains an invalid password. If the connection fails, the "
"return value will be -1."
msgstr ""
"Попытка соединения может и не удаться, например если Tarantool-сервер не запущен "
"или в URI-строке указан неверный пароль. В случае неудачи функция "
"``tnt_connect()`` вернет -1."

#: ../book/connectors/__c.rst:119
msgid ""
"**MAKE REQUEST:** Most requests require passing a structured value, such as the "
"contents of a tuple."
msgstr ""
"**СОЗДАНИЕ ЗАПРОСА:** В большинстве запросов требуется передавать "
"структурированные данные, например содержимое кортежа."

#: ../book/connectors/__c.rst:122
#, python-format
msgid ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"
msgstr ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"

#: ../book/connectors/__c.rst:127
#, python-format
msgid ""
"In this program, the request will be an INSERT, and the tuple contents will be "
"an integer and a string. This is a simple serial set of values, that is, there "
"are no sub-structures or arrays. Therefore it is easy in this case to format "
"what will be passed using the same sort of arguments that one would use with a C "
"``printf()`` function: ``%d`` for the integer, ``%s`` for the string, then the "
"integer value, then a pointer to the string value."
msgstr ""
"В данной программе мы используем запрос INSERT, а кортеж содержит целое число и "
"строку.  Это простой набор значений без каких-либо вложенных структур или "
"массивов. И передаваемые значения мы можем указать самым простым образом — "
"аналогично тому, как это сделано в стандартной C-функции ``printf()``: ``%d`` "
"для обозначения целого числа, ``%s`` для обозначения строки, затем числовое "
"значение, затем указатель на строковое значение."

#: ../book/connectors/__c.rst:469
msgid "ssize_t tnt_object_format(struct tnt_stream \\*s, const char \\*fmt, ...)"
msgstr "ssize_t tnt_object_format(struct tnt_stream \\*s, const char \\*fmt, ...)"

#: ../book/connectors/__c.rst:143
msgid ""
"**SEND REQUEST:** The database-manipulation requests are analogous to the "
"requests in the box library."
msgstr ""
"**ОТПРАВКА ЗАПРОСА:** Отправка запросов на изменение данных в базе делается "
"аналогично тому, как это делается в Tarantool-библиотеке ``box``."

#: ../book/connectors/__c.rst:146
msgid ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"
msgstr ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"

#: ../book/connectors/__c.rst:151
msgid ""
"In this program, the choice is to do an INSERT request, so the program passes "
"the ``tnt_stream`` that was used for connection (``tnt``) and the ``tnt_stream`` "
"that was set up with :c:func:`tarantoolc:tnt_object_format` (``tuple``)."
msgstr ""
"В данной программе мы делаем INSERT-запрос. В этом запросе мы передаем поток "
"``tnt``, который ранее использовали для установки соединения, и поток :code:"
"`tuple`, который также ранее настроили с помощью функции :c:func:`tarantoolc:"
"tnt_object_format`."

#: ../book/connectors/__c.rst:489
msgid ""
"ssize_t tnt_insert(struct tnt_stream \\*s, uint32_t space, struct tnt_stream "
"\\*tuple)\n"
"ssize_t tnt_replace(struct tnt_stream \\*s, uint32_t space, struct tnt_stream "
"\\*tuple)\n"
"ssize_t tnt_select(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream \\*key)\n"
"ssize_t tnt_update(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream \\*key, struct tnt_stream \\*ops)"
msgstr ""
"ssize_t tnt_insert(struct tnt_stream \\*s, uint32_t space, struct tnt_stream "
"\\*tuple)\n"
"ssize_t tnt_replace(struct tnt_stream \\*s, uint32_t space, struct tnt_stream "
"\\*tuple)\n"
"ssize_t tnt_select(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream \\*key)\n"
"ssize_t tnt_update(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream \\*key, struct tnt_stream \\*ops)"

#: ../book/connectors/__c.rst:169
msgid ""
"**GET REPLY:** For most requests, the client will receive a reply containing "
"some indication whether the result was successful, and a set of tuples."
msgstr ""
"**ПОЛУЧЕНИЕ ОТВЕТА:** На большинство запросов клиент получает ответ, который "
"содержит информацию о том, был ли данный запрос успешно выполнен, а также "
"содержит набор кортежей."

#: ../book/connectors/__c.rst:172
#, python-format
msgid ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"
msgstr ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"

#: ../book/connectors/__c.rst:179
msgid "This program checks for success but does not decode the rest of the reply."
msgstr ""
"Данная программа проверяет, был ли запрос выполнен успешно, но никак не "
"интерпретирует оставшуюся часть ответа."

#: ../book/connectors/__c.rst:514
msgid ""
"struct tnt_reply \\*tnt_reply_init(struct tnt_reply \\*r)\n"
"tnt->read_reply(struct tnt_stream \\*s, struct tnt_reply \\*r)\n"
"void tnt_reply_free(struct tnt_reply \\*r)"
msgstr ""
"struct tnt_reply \\*tnt_reply_init(struct tnt_reply \\*r)\n"
"tnt->read_reply(struct tnt_stream \\*s, struct tnt_reply \\*r)\n"
"void tnt_reply_free(struct tnt_reply \\*r)"

#: ../book/connectors/__c.rst:190
msgid ""
"**TEARDOWN:** When a session ends, the connection that was made with :c:func:"
"`tarantoolc:tnt_connect()` should be closed, and the objects that were made in "
"the setup should be destroyed."
msgstr ""
"**ЗАВЕРШЕНИЕ:** По окончании сессии нам нужно закрыть соединение, созданное с "
"помощью функции :c:func:`tarantoolc:tnt_connect()`, и удалить объекты, созданные "
"на этапе настройки."

#: ../book/connectors/__c.rst:194
msgid ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"
msgstr ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"

#: ../book/connectors/__c.rst:533
msgid ""
"void tnt_close(struct tnt_stream \\*s)\n"
"void tnt_stream_free(struct tnt_stream \\*s)"
msgstr ""
"void tnt_close(struct tnt_stream \\*s)\n"
"void tnt_stream_free(struct tnt_stream \\*s)"

#: ../book/connectors/__c.rst:210
msgid "Example 2"
msgstr "Пример 2"

#: ../book/connectors/__c.rst:212
msgid ""
"Here is a complete C program that selects, using index key ``[99999]``, from "
"space ``examples`` via the high-level C API. To display the results, the program "
"uses functions in the `MsgPuck <http://rtsisyk.github.io/msgpuck/>`_ library "
"which allow decoding of `MessagePack <https://en.wikipedia.org/wiki/"
"MessagePack>`_  arrays."
msgstr ""
"Далее приводится еще один пример полноценной программы на языке C, которая "
"осуществляет выборку по индекс-ключу ``[99999]`` из пространства ``examples`` с "
"помощью высокоуровневого Tarantool API для языка C. Для вывода результатов в "
"этой программе используются функции из библиотеки `MsgPuck <http://rtsisyk."
"github.io/msgpuck/>`_. Эти функции нужны для декодирования массивов значений в "
"формате `MessagePack <https://en.wikipedia.org/wiki/MessagePack>`_."

#: ../book/connectors/__c.rst:218
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* tuple = search key */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, &str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* кортеж tuple = ключ для поиска "
"*/\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, &str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"

#: ../book/connectors/__c.rst:285
msgid ""
"Similarly to the first example, paste the code into a file named :file:`example2."
"c`."
msgstr ""
"Аналогично первому примеру, сохраните исходный код программы в файле с именем :"
"file:`example2.c`."

#: ../book/connectors/__c.rst:290
msgid "$ gcc -o example2 example2.c -ltarantool"
msgstr "$ gcc -o example2 example2.c -ltarantool"

#: ../book/connectors/__c.rst:294
msgid "To run the program, say :samp:`./example2`."
msgstr "Для запуска программы выполните команду :samp:`./example2`."

#: ../book/connectors/__c.rst:296
msgid ""
"The two example programs only show a few requests and do not show all that's "
"necessary for good practice. See more in the `tarantool-c documentation at "
"GitHub <http://github.com/tarantool/tarantool-c>`_."
msgstr ""
"В этих двух программах мы привели пример использования лишь двух запросов. Для "
"полноценной работы с Tarantool'ом с помощью C API, пожалуйста, обратитесь к "
"документации из `проекта tarantool-c на GitHub <http://github.com/tarantool/"
"tarantool-c>`_."

#: ../book/connectors/__results.rst:4
msgid "Interpreting function return values"
msgstr "Интерпретация возвращаемых значений"

#: ../book/connectors/__results.rst:6
msgid ""
"For all connectors, calling a function via Tarantool causes a return in the "
"MsgPack format. If the function is called using the connector's API, some "
"conversions may occur. All scalar values are returned as tuples (with a MsgPack "
"type-identifier followed by a value); all non-scalar values are returned as a "
"group of tuples (with a MsgPack array-identifier followed by the scalar values). "
"If the function is called via the binary protocol command layer -- \"eval\" -- "
"rather than via the connector's API, no conversions occur."
msgstr ""
"При работе с любым Tarantool-коннектором функции, вызванные с помощью "
"Tarantool'а, возвращают значения в формате MsgPack. Если функция была вызвана "
"через API коннектора, то формат возвращаемых значений будет следующим: скалярные "
"значения возвращаются в виде кортежей (сначала идет идентификатор типа из "
"формата MsgPack, а затем идет значение); все прочие (не скалярные) значения "
"возвращаются в виде групп кортежей (сначала идет идентификатор массива в формате "
"MsgPack, а затем идут скалярные значения). Но если функция была вызвана в рамках "
"бинарного протокола (с помощью команды ``eval``), а не через API коннектора, то "
"подобных изменений формата возвращаемых значений не происходит."

#: ../book/connectors/__results.rst:14
msgid ""
"In the following example, a Lua function will be created. Since it will be "
"accessed externally by a 'guest' user, a ``grant`` of an execute privilege will "
"be necessary. The function returns an empty array, a scalar string, two "
"booleans, and a short integer. The values are the ones described in the table :"
"ref:`Common Types and MsgPack Encodings <msgpack-"
"common_types_and_msgpack_encodings>`."
msgstr ""
"Далее приводится пример создания Lua-функции. Поскольку эту функцию будет "
"вызывать внешний пользователь 'guest', то нужно настроить привилегии на "
"исполнение с помощью ``grant``. Эта функция возвращает пустой массив, строку-"
"скаляр, два логических значения и короткое целое число. Значение будут теми же, "
"что описаны в разделе про MsgPack в таблице :ref:`Стандартные типы в MsgPack-"
"кодировке <msgpack-common_types_and_msgpack_encodings>`."

#: ../book/connectors/__results.rst:20
msgid ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept "
"requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept "
"requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."

#: ../book/connectors/__results.rst:36
msgid ""
"Here is a C program which calls the function. Although C is being used for the "
"example, the result would be precisely the same if the calling program was "
"written in Perl, PHP, Python, Go, or Java."
msgstr ""
"Далее идет пример программы на C, из который мы вызываем эту Lua-функцию. Хотя в "
"примере использован код на C, результат будет одинаковым, на каком бы языке ни "
"была написана вызываемая программа: Perl, PHP, Python, Go или Java."

#: ../book/connectors/__results.rst:40
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);            /* SETUP */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                        /* CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);       /* MAKE REQUEST */\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL); /* CALL function f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   tnt_request_set_tuple(req1, arg);\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                    /* SEND REQUEST */\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);   /* GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data;/* PRINT REPLY */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                    /* TEARDOWN */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);            /* НАСТРОЙКА */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                        /* СОЕДИНЕНИЕ */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);       /* СОЗДАНИЕ ЗАПРОСА */\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL); /* ВЫЗОВ function f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   tnt_request_set_tuple(req1, arg);\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                    /* ОТПРАВКА ЗАПРОСА */\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);   /* ПОЛУЧЕНИЕ ОТВЕТА */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data;/* ВЫВОД ОТВЕТА */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                    /* ЗАВЕРШЕНИЕ */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"

#: ../book/connectors/__results.rst:80
msgid "When this program is executed, it will print:"
msgstr "По завершении программа выведет на экран следующие значения:"

#: ../book/connectors/__results.rst:82
msgid "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"
msgstr "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"

#: ../book/connectors/__results.rst:86
msgid ""
"The first five bytes -- ``dd 0 0 0 5`` -- are the MsgPack encoding for \"32-bit "
"array header with value 5\" (see `MsgPack specification <http://github.com/"
"msgpack/msgpack/blob/master/spec.md>`_). The rest are as described in the table :"
"ref:`Common Types and MsgPack Encodings <msgpack-"
"common_types_and_msgpack_encodings>`."
msgstr ""
"Первые пять байт — ``dd 0 0 0 5`` — это фрагмент данных в формате MsgPack, "
"означающий \"32-битный заголовок массива со значением 5\" (см. `спецификацию на "
"формат MsgPack <http://github.com/msgpack/msgpack/blob/master/spec.md>`_). "
"Остальные значения описаны в таблице :ref:`Стандартные типы в MsgPack-кодировке "
"<msgpack-common_types_and_msgpack_encodings>`."

#: ../book/faq.rst:30
msgid "FAQ"
msgstr "Вопросы и ответы"

#: ../book/faq.rst:41 ../book/faq.rst:46 ../book/faq.rst:53 ../book/faq.rst:64
#: ../book/faq.rst:70 ../book/faq.rst:77 ../book/faq.rst:82
msgid "Q: |br| A: |br|"
msgstr "Вопрос: |br| Ответ: |br|"

#: ../book/faq.rst:41
msgid ""
"Why Tarantool? |br| Tarantool is the latest generation of a family of in-memory "
"data servers developed for web applications. It is the result of practical "
"experience and trials within Mail.Ru since development began in 2008."
msgstr ""
"Почему Tarantool? |br| Tarantool — это in-memory сервер баз данных последнего "
"поколения, предназначенный для работы с веб-приложениями. Разработка ведется с "
"учетом многолетнего опыта использования Tarantool'а в стенах Mail.Ru. Первый "
"релиз состоялся в 2008 году."

#: ../book/faq.rst:46
msgid ""
"Why Lua? |br| Lua is a lightweight, fast, extensible multi-paradigm language. "
"Lua also happens to be very easy to embed. Lua coroutines relate very closely to "
"Tarantool fibers, and Lua architecture works well with Tarantool internals. Lua "
"acts well as a stored program language for Tarantool, although connecting with "
"other languages is also easy."
msgstr ""
"Почему Lua? |br| Lua — это легкий, быстрый и расширяемый язык, позволяющий "
"использовать различные парадигмы программирования. Lua также легко встраивается "
"в различные приложения. Ко-рутины (coroutines) в Lua близко соотносятся с "
"файберами (fibers) в Tarantool'е, а вся Lua-архитектура гладко ложится на его "
"внутреннюю реализацию. Lua — это первый язык, на котором можно писать хранимые "
"процедуры для Tarantool'а. В будущем список поддерживаемых языков планируется "
"расширить."

#: ../book/faq.rst:53
msgid ""
"What's the key advantage of Tarantool? |br| Tarantool provides a rich database "
"feature set (HASH, TREE, RTREE, BITSET indexes, secondary indexes, composite "
"indexes, transactions, triggers, asynchronous replication) in a flexible "
"environment of a Lua interpreter. |br| These two properties make it possible to "
"be a fast, atomic and reliable in-memory data server which handles non-trivial "
"application-specific logic. The advantage over traditional SQL servers is in "
"performance: low-overhead, lock-free architecture means Tarantool can serve an "
"order of magnitude more requests per second, on comparable hardware. The "
"advantage over NoSQL alternatives is in flexibility: Lua allows flexible "
"processing of data stored in a compact, denormalized format."
msgstr ""
"В чем состоит главное преимущество Tarantool'а? |br| Tarantool предоставляет "
"богатый набор функций по работе с базами данных (HASH, TREE, RTREE, BitSet-"
"индексы, вторичные индексы, составные индексы, транзакции, триггеры, асинхронная "
"репликация), и всё это — в гибкой среде Lua-интерпретатора. |br| Эти два "
"обстоятельства делают Tarantool быстрым и надежным in-memory сервером баз данных "
"с атомарными операциями и сложной логикой на стороне сервера. Преимуществом "
"Tarantool'а по сравнению с традиционными SQL СУБД является его высокая "
"производительность: низкие накладные расходы и безблокировочная архитектура "
"позволяют Tarantool'у обрабатывать на порядок больше запросов в секунду на "
"аналогичном оборудовании. Преимущество же перед другими NoSQL СУБД заключается в "
"большей гибкости Tarantool'а: язык Lua позволяет гибко обрабатывать данные, "
"хранящиеся в компактном, ненормализованном формате."

#: ../book/faq.rst:64
msgid ""
"What are your development plans? |br| We continuously improve server "
"performance. On the feature front, automatic sharding and synchronous "
"replication, and a subset of SQL are the major goals for 2016-2018. We have an "
"open roadmap to which we encourage anyone to add feature requests."
msgstr ""
"Каковы ваши планы по развитию? |br| Мы постоянно улучшаем производительность "
"серверной части. Наши главные цели на 2016-2018 год — это автоматический шардинг "
"и синхронная репликация, а также частичная поддержка SQL. План работ находится в "
"открытом доступе, и все желающие могут оставлять запросы на добавление "
"функционала."

#: ../book/faq.rst:70
msgid ""
"Who is developing Tarantool? |br| There is an engineering team employed by Mail."
"Ru -- check out our commit logs on `github.com/tarantool <http://github.com/"
"tarantool/>`_. The development is fully open. Most of the connectors' authors, "
"and the maintainers for different distributions, come from the wider community."
msgstr ""
"Кто разрабатывает Tarantool? |br| Во-первых, этим занимается команда разработки "
"в Mail.Ru — см. историю коммитов на `github.com/tarantool <http://github.com/"
"tarantool/>`_. Вся разработка ведется открытым образом. Кроме того, активную "
"роль играют члены сообщества разработчиков Tarantool'а. Их силами было создано "
"большинство коннекторов и ведутся доработки под разные дистрибутивы."

#: ../book/faq.rst:77
msgid ""
"How serious is Mail.Ru about Tarantool? |br| Tarantool is an open source "
"project, distributed under a BSD license, so it does not depend on any one "
"sponsor. However, it is an integral part of the Mail.Ru backbone, so it gets a "
"lot of support from Mail.Ru."
msgstr ""
"Насколько серьезны планы Mail.Ru в отношении Tarantool'а? |br| Tarantool — это "
"проект с открытым кодом, распространяемый под лицензией BSD, поэтому он не "
"зависит от внешних спонсоров. В то же время, Tarantool — это часть "
"технологического \"костяка\" Mail.Ru, и поэтому он пользуется сильной поддержкой "
"со стороны Mail.Ru."

#: ../book/faq.rst:82
msgid ""
"Are there problems associated with being an in-memory server? |br| The principal "
"storage engine is designed for RAM plus persistent storage. It is immune to data "
"loss because there is a write-ahead log. Its memory-allocation and compression "
"techniques ensure there is no waste. And if Tarantool runs out of memory, then "
"it will stop accepting updates until more memory is available, but will continue "
"to handle read and delete requests without difficulty. However, for databases "
"which are much larger than the available RAM space, Tarantool has a second "
"storage engine which is only limited by the available disk space."
msgstr ""
"Возникают ли проблемы из-за того, что Tarantool является in-memory решением? |"
"br| Основной движок баз данных в Tarantool'е работает с оперативной памятью, но "
"при этом он гарантирует сохранность данных благодаря механизму WAL (write ahead "
"log), т.е. журналу упреждающей записи. Также в Tarantool'е используются "
"технологии сжатия и распределения данных, которые позволяют использовать все "
"виды памяти наиболее эффективно. Если Tarantool сталкивается с нехваткой "
"оперативной памяти, то он приостанавливает прием запросов на изменение данных до "
"тех пор, пока не появится свободная память, но при этом с успехом продолжает "
"обработку запросов на чтение и удаление данных. А для больших баз, где объем "
"данных значительно превосходит имеющийся объем оперативной памяти, у Tarantool'а "
"есть второй движок, чьи возможности ограничены лишь размером жесткого диска."

#: ../book/index.rst:30
msgid "User's Guide"
msgstr "Руководство пользователя"

#: ../book/intro.rst:28
msgid "Preface"
msgstr "Предисловие"

#: ../book/intro.rst:30
msgid ""
"Welcome to Tarantool! This is the User's Guide. We recommend reading it first, "
"and consulting :ref:`Reference <reference>` materials for more detail "
"afterwards, if needed."
msgstr ""
"Добро пожаловать в мир Tarantool! Сейчас вы читаете \"Руководство пользователя"
"\". Мы советуем начинать именно с него, а затем переходить к :ref:`\"Справочникам"
"\" <reference>`, если вам понадобятся более подробные сведения."

#: ../book/intro.rst:36
msgid "How to read the documentation"
msgstr "Как пользоваться документацией"

#: ../book/intro.rst:38
msgid ""
"To get started, you can either *download the whole Tarantool package* as "
"described in the first part of :ref:`Chapter 2 \"Getting Started\" "
"<user_guide_getting_started>`, or you can skip the download and *connect to the "
"online Tarantool server* running on the web at http://try.tarantool.org. Either "
"way, as the first tryout, you can follow the introductory example \"Starting "
"Tarantool and making your first database\" from :ref:`the second part of Chapter "
"2 <user_guide_getting_started-first_database>`. If you want more hands-on "
"experience, proceed to the :ref:`\"Tutorials\" <tutorials>` part after you are "
"through with Chapter 2."
msgstr ""
"Знакомство с Tarantool'ом вы можете начать с того, что скачаете готовый "
"установочный пакет (как описано в начале :ref:`главы 2 \"Начало работы\" "
"<user_guide_getting_started>`) или воспользуетесь нашим онлайн-стендом на http://"
"try.tarantool.org. В любом случае для первого знакомства вы можете выполнить "
"тренировочный пример \"Первичный запуск Tarantool'а и создание базы данных\" из "
"второй части главы 2. После этого вы можете заглянуть в наш :ref:`\"Практикум\" "
"<tutorials>`, где содержится еще больше практических заданий."

#: ../book/intro.rst:50
msgid ""
":ref:`Chapter 3 \"Database\" <database-chapter>` is about using Tarantool as a "
"NoSQL DBMS, whereas :ref:`Chapter 4 \"Application server\" <app_server>` is "
"about using Tarantool as an application server."
msgstr ""
"В :ref:`главе 3 \"Функционал СУБД\" <database-chapter>` рассказано о "
"возможностях Tarantool'а как NoSQL СУБД, а в :ref:`главе 4 \"Сервер приложений\" "
"<app_server>` — о возможностях Tarantool'а как сервера приложений Lua."

#: ../book/intro.rst:54
msgid ""
":ref:`Chapter 5 \"Server administration\" <server_admin>` is primarily for "
"administrators."
msgstr ""
":ref:`Глава 5 \"Администрирование серверной части\" <server_admin>` "
"предназначена в первую очередь для системных администраторов."

#: ../book/intro.rst:57
msgid ""
":ref:`Chapter 6 \"Connectors\" <index-box_connectors>` is strictly for users who "
"are connecting from a different language such as C or Perl or Python — other "
"users will find no immediate need for this chapter."
msgstr ""
":ref:`Глава 6 \"Коннекторы\" <index-box_connectors>` актуальна только для тех "
"пользователей, которые хотят устанавливать соединение с Tarantool'ом с помощью "
"программ на других языках программирования (например C, Perl или Python) — для "
"прочих пользователей эта глава неактуальна."

#: ../book/intro.rst:61
msgid ""
":ref:`Chapter 7 \"FAQ\" <faq>` gives answers to some frequently asked questions "
"about Tarantool."
msgstr ""
":ref:`Глава 7 \"Вопросы и ответы\" <faq>` содержит ответы на некоторые часто "
"задаваемые вопросы о Tarantool'е."

#: ../book/intro.rst:64
msgid ""
"For experienced users, there are also :ref:`Reference <reference>` materials, a :"
"ref:`Contributor's Guide <contrib_guide>` and an extensive set of comments in "
"the source code."
msgstr ""
"Опытным же пользователям будут полезны :ref:`\"Справочники\" <reference>`, :ref:`"
"\"Руководство участника проекта\" <contrib_guide>` и комментарии в исходном коде."

#: ../book/intro.rst:70
msgid "Getting in touch with the Tarantool community"
msgstr "Как связаться с сообществом разработчиков Tarantool'а"

#: ../book/intro.rst:72
msgid ""
"Please report bugs or make feature requests at http://github.com/tarantool/"
"tarantool/issues."
msgstr ""
"Оставить сообщение о найденых дефектах или сделать запрос на новый функционал "
"можно тут: http://github.com/tarantool/tarantool/issues"

#: ../book/intro.rst:74
msgid ""
"You can contact developers directly in `telegram <http://telegram.me/"
"tarantool>`_ or in a Tarantool discussion group (`English <https://groups.google."
"com/forum/#!forum/tarantool>`_ or `Russian <https://googlegroups.com/group/"
"tarantool-ru>`_)."
msgstr ""
"Пообщаться напрямую с командой разработки Tarantool'а можно в `telegram <http://"
"telegram.me/tarantool>`_ или на форумах (`англоязычном <https://groups.google."
"com/forum/#!forum/tarantool>`_ или `русскоязычном <https://googlegroups.com/"
"group/tarantool-ru>`_)."

#: ../book/user_guide_getting_started.rst:30
msgid "Getting started"
msgstr "Начало работы"

#: ../book/user_guide_getting_started.rst:32
msgid ""
"This chapter shows how to download, how to install, and how to start Tarantool "
"for the first time."
msgstr ""
"В этой главе рассказывается, как скачать, установить и начать работать с "
"Tarantool'ом с нуля."

#: ../book/user_guide_getting_started.rst:35
msgid ""
"For production, if possible, you should download a binary (executable) package. "
"This will ensure that you have the same build of the same version that the "
"developers have. That makes analysis easier if later you need to report a "
"problem, and avoids subtle problems that might happen if you used different "
"tools or different parameters when building from source. The section about "
"binaries is \":ref:`user_guide_getting_started-"
"downloading_and_installing_a_binary_package`\"."
msgstr ""
"Для промышленной эксплуатации рекомендуется скачать бинарный (исполняемый) "
"пакет. Тогда вы гарантированно получите сборку той же версии, что и у "
"разработчиков. Это существенно упростит поиск ошибок, если вам в будущем "
"понадобится помощь, а также позволит избежать проблем из-за того, что вы "
"использовали инструменты или параметры отличные от тех, что использовали при "
"сборке сами разработчики. См. раздел “:ref:`user_guide_getting_started-"
"downloading_and_installing_a_binary_package`”."

#: ../book/user_guide_getting_started.rst:42
msgid ""
"For development, you will want to download a source package and make the binary "
"by yourself using a C/C++ compiler and common tools. Although this is a bit "
"harder, it gives more control. And the source packages include additional files, "
"for example the Tarantool test suite. The section about source is \":ref:"
"`Building from source <building_from_source>`\" in :ref:`Contributor's Guide "
"<contrib_guide>`."
msgstr ""
"Для разработческих целей вы можете скачать исходные файлы и собрать бинарный "
"пакет самостоятельно с помощью компилятора C/C++ и обычных инструментов для "
"сборки. Хотя это и более трудный способ получить бинарный пакет, но он дает вам "
"больший контроль над результатом. Также в состав исходных файлов входят "
"дополнительные пакеты, например набор тестов для Tarantool'а. См. раздел \":ref:"
"`Сборка из исходных файлов <building_from_source>`\" в \":ref:`Руководстве "
"участника проекта <contrib_guide>`\"."

#: ../book/user_guide_getting_started.rst:49
msgid ""
"If the installation has already been done, then you should try it out. So we've "
"provided some instructions that you can use to make a temporary “sandbox”. In a "
"few minutes you can start the server and type in some database-manipulation "
"statements. The section about the sandbox is \":ref:`user_guide_getting_started-"
"first_database`\"."
msgstr ""
"После установки вы можете сразу опробовать Tarantool в действии. Ниже вы найдете "
"инструкции по созданию безопасной тестовой среды. Всего за несколько минут вы "
"сможете запустить Tarantool-сервер и задать несколько инструкций по "
"манипулированию данными. См. раздел \":ref:`user_guide_getting_started-"
"first_database`”."

#: ../book/user_guide_getting_started.rst:59
msgid "Downloading and installing a binary package"
msgstr "Скачивание и установка бинарного пакета"

#: ../book/user_guide_getting_started.rst:61
msgid ""
"Binary packages for two Tarantool versions -- for the stable 1.6 and the latest "
"1.7 -- are provided at http://tarantool.org/download.html. An automatic build "
"system creates, tests and publishes packages for every push into the 1.7 branch."
msgstr ""
"Бинарные пакеты для двух версий Tarantool'а — стабильной 1.6 и самой свежей 1.7 "
"— выложены на странице http://tarantool.org/download.html. При каждом изменении "
"исходного кода на GitHub (репозиторий http://github.com/tarantool/tarantool, "
"ветка \"1.7\") происходит сборка, автоматическое тестирование и выкладка "
"бинарных пакетов на вышеуказанную страницу."

#: ../book/user_guide_getting_started.rst:65
msgid ""
"To download and install the package that's appropriate for your OS, start a "
"shell (terminal) and enter the command-line instructions provided for your OS at "
"http://tarantool.org/download.html."
msgstr ""
"Чтобы скачать и установить бинарный пакет для вашей операционной системы, "
"откройте терминал с командной строкой и введите инструкции, которые даны для "
"вашей операционной системы на странице http://tarantool.org/download.html."

#: ../book/user_guide_getting_started.rst:73
msgid "Starting Tarantool and making your first database"
msgstr "Первичный запуск Tarantool'а и создание базы данных"

#: ../book/user_guide_getting_started.rst:75
#: ../book/user_guide_getting_started.rst:85
msgid "Here is how to create a simple test database after installing."
msgstr ""
"Далее рассказывается, как создать простую тестовую базу данных после установки "
"Tarantool'а."

#: ../book/user_guide_getting_started.rst:77
msgid ""
"Create a new directory. It's just for tests, you can delete it when the tests "
"are over."
msgstr ""
"Создайте новую директорию. Она понадобится только для тестовых целей, и ее можно "
"будет удалить по окончании экспериментов."

#: ../book/user_guide_getting_started.rst:80
msgid ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"
msgstr ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"

#: ../book/user_guide_getting_started.rst:87
msgid "Start the server. The server name is tarantool."
msgstr "Запустите Tarantool-сервер. Имя программы — :program:`tarantool`."

#: ../book/user_guide_getting_started.rst:89
msgid ""
"$ # if you downloaded a binary with apt-get or yum, say this:\n"
"$ /usr/bin/tarantool\n"
"$ # if you downloaded and untarred a binary\n"
"$ # tarball to ~/tarantool, say this:\n"
"$ ~/tarantool/bin/tarantool\n"
"$ # if you built from a source download, say this:\n"
"$ ~/tarantool/src/tarantool"
msgstr ""
"$ # Если вы скачали бинарный пакет с помощью apt-get или yum, введите:\n"
"$ /usr/bin/tarantool\n"
"$ # Если вы скачали бинарный пакет в формате TAR\n"
"$ # и разархивировали его в директорию ~/tarantool, введите:\n"
"$ ~/tarantool/bin/tarantool\n"
"$ # Если вы собрали Tarantool из исходных файлов, введите:\n"
"$ ~/tarantool/src/tarantool"

#: ../book/user_guide_getting_started.rst:99
msgid ""
"The server starts in interactive mode and outputs a command prompt. To turn on "
"the database, :ref:`configure <box_introspection-box_cfg>` it. This minimal "
"example is sufficient:"
msgstr ""
"Tarantool-сервер запускается в интерактивном режиме и выводит приглашение "
"командной строки. Чтобы создать базу данных, задайте ее настройки с помощью "
"вызова :ref:`box.cfg <box_introspection-box_cfg>`. Вот пример минимальной "
"конфигурации:"

#: ../book/user_guide_getting_started.rst:103
msgid "tarantool> box.cfg{listen = 3301}"
msgstr "tarantool> box.cfg{listen = 3301}"

#: ../book/user_guide_getting_started.rst:107
msgid ""
"If all goes well, you will see the server displaying progress as it initializes, "
"something like this:"
msgstr ""
"Если все в порядке, то Tarantool-сервер начнет в прогрессе отображать процесс "
"инициализации, например:"

#: ../book/user_guide_getting_started.rst:110
msgid ""
"tarantool> box.cfg{listen = 3301}\n"
"2015-08-07 09:41:41.077 ... version 1.7.0-1216-g73f7154\n"
"2015-08-07 09:41:41.077 ... log level 5\n"
"2015-08-07 09:41:41.078 ... mapping 1073741824 bytes for a shared arena...\n"
"2015-08-07 09:41:41.079 ... initialized\n"
"2015-08-07 09:41:41.081 ... initializing an empty data directory\n"
"2015-08-07 09:41:41.095 ... creating './00000000000000000000.snap.inprogress'\n"
"2015-08-07 09:41:41.095 ... saving snapshot './00000000000000000000.snap."
"inprogress'\n"
"2015-08-07 09:41:41.127 ... done\n"
"2015-08-07 09:41:41.128 ... primary: bound to 0.0.0.0:3301\n"
"2015-08-07 09:41:41.128 ... ready to accept requests"
msgstr ""
"tarantool> box.cfg{listen = 3301}\n"
"2015-08-07 09:41:41.077 ... version 1.7.0-1216-g73f7154\n"
"2015-08-07 09:41:41.077 ... log level 5\n"
"2015-08-07 09:41:41.078 ... mapping 1073741824 bytes for a shared arena...\n"
"2015-08-07 09:41:41.079 ... initialized\n"
"2015-08-07 09:41:41.081 ... initializing an empty data directory\n"
"2015-08-07 09:41:41.095 ... creating './00000000000000000000.snap.inprogress'\n"
"2015-08-07 09:41:41.095 ... saving snapshot './00000000000000000000.snap."
"inprogress'\n"
"2015-08-07 09:41:41.127 ... done\n"
"2015-08-07 09:41:41.128 ... primary: bound to 0.0.0.0:3301\n"
"2015-08-07 09:41:41.128 ... ready to accept requests"

#: ../book/user_guide_getting_started.rst:124
msgid ""
"Now that the server is up, you could start up a different shell and connect to "
"its primary port with:"
msgstr ""
"Поскольку Tarantool-сервер уже запущен, вы можете запустить новый терминал и "
"присоединиться к основному порту Tarantool-сервера, введя следующую команду:"

#: ../book/user_guide_getting_started.rst:127
msgid "$ telnet 0 3301"
msgstr "$ telnet 0 3301"

#: ../book/user_guide_getting_started.rst:131
msgid ""
"but for example purposes it is simpler to just leave the server running in "
"\"interactive mode\". On production machines the :ref:`interactive mode "
"<administration-using_tarantool_as_a_client>` is just for administrators, but "
"because it's convenient for learning it will be used for most examples in this "
"manual. Tarantool is waiting for the user to type instructions."
msgstr ""
"но пока что будет лучше оставить Tarantool-сервер работать в интерактивном "
"режиме. На промышленных серверах :ref:`интерактивный режим <administration-"
"using_tarantool_as_a_client>` нужен лишь для администрирования, однако для "
"наглядности большинство примеров в данном руководстве даны именно в "
"интерактивном режиме. Итак, Tarantool ждет от вас ввода инструкций."

#: ../book/user_guide_getting_started.rst:138
msgid "To create the first space and the first :ref:`index <box_index>`, try this:"
msgstr "Создайте первое пространство и первый :ref:`индекс <box_index>`:"

#: ../book/user_guide_getting_started.rst:140
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })"

#: ../book/user_guide_getting_started.rst:148
msgid ""
"To insert three “tuples” (our name for “records”) into the first “space” of the "
"database try this:"
msgstr ""
"Выполните вставку трех \"кортежей\" (tuple) в первое \"пространство\" (space) из "
"вашей базы данных:"

#: ../book/user_guide_getting_started.rst:151
msgid ""
"tarantool> t = s:insert({1})\n"
"tarantool> t = s:insert({2, 'Music'})\n"
"tarantool> t = s:insert({3, 'Length', 93})"
msgstr ""
"tarantool> t = s:insert({1})\n"
"tarantool> t = s:insert({2, 'Music'})\n"
"tarantool> t = s:insert({3, 'Length', 93})"

#: ../book/user_guide_getting_started.rst:157
msgid ""
"To select a tuple from the first space of the database, using the first defined "
"key, try this:"
msgstr ""
"Произведите выборку кортежа из первого пространства в базе по первому указанному "
"ключу:"

#: ../book/user_guide_getting_started.rst:160
msgid "tarantool> s:select{3}"
msgstr "tarantool> s:select{3}"

#: ../book/user_guide_getting_started.rst:164
msgid "Your terminal screen should now look like this:"
msgstr "Вот что должно отображаться на вашем терминале к этому моменту:"

#: ../book/user_guide_getting_started.rst:166
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"2015-06-10 12:04:18.158 ... creating './00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Music'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Length', 93}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Length', 93]\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"2015-06-10 12:04:18.158 ... creating './00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Music'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Length', 93}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Length', 93]\n"
"...\n"
"tarantool>"

#: ../book/user_guide_getting_started.rst:190
msgid "Now, to prepare for the example in the next section, try this:"
msgstr ""
"Далее, чтобы подготовиться к тестовому примеру в следующем разделе, введите:"

#: ../book/user_guide_getting_started.rst:192
msgid "tarantool> box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""
"tarantool> box.schema.user.grant('guest', 'read,write,execute', 'universe')"

#: ../book/user_guide_getting_started.rst:198
msgid "Connecting remotely"
msgstr "Установка удаленного соединения"

#: ../book/user_guide_getting_started.rst:200
msgid ""
"In the previous section the first request was with ``box.cfg{listen = 3301}``. "
"The ``listen`` value can be any form of URI (uniform resource identifier); in "
"this case it's just a local port: port 3301. It's possible to send requests to "
"the listen URI via:"
msgstr ""
"В предыдущем разделе ваш первый запрос был :samp:`box.cfg{listen = 3301}`. "
"Значением ``listen`` может быть любой URI (универсальный код ресурса), в данном "
"случае — просто номер локального порта (3301). Вы можете отправлять запросы на "
"URI для прослушивания с помощью:"

#: ../book/user_guide_getting_started.rst:205
msgid "telnet,"
msgstr "telnet,"

#: ../book/user_guide_getting_started.rst:206
msgid ""
"a connector (which will be the subject of the \":ref:`index-box_connectors`\" "
"chapter),"
msgstr "коннектора (см. главу \":ref:`index-box_connectors`\"),"

#: ../book/user_guide_getting_started.rst:208
msgid ""
"another instance of Tarantool via the :ref:`console module <console-module>`,"
msgstr ""
"другого экземпляра Tarantool'а с помощью :ref:`console module <console-module>`, "
"либо"

#: ../book/user_guide_getting_started.rst:209
msgid "``tarantoolctl connect``."
msgstr "``tarantoolctl connect``."

#: ../book/user_guide_getting_started.rst:211
msgid "Let's try (d)."
msgstr "Давайте попробуем вариант с ``tarantoolctl connect``."

#: ../book/user_guide_getting_started.rst:213
msgid ""
"Switch to another terminal. On Linux, for example, this means starting another "
"instance of a Bash shell. There is no need to use cd to switch to the ``~/"
"tarantool_sandbox`` directory."
msgstr ""
"Переключитесь на другой терминал. Например, в Linux-системе для этого нужно "
"запустить новый экземпляр Bash. При этом вам не потребуется вызывать cd, чтобы "
"переключиться на директорию :code:`~/tarantool_sandbox`."

#: ../book/user_guide_getting_started.rst:217
msgid "Start the tarantoolctl utility:"
msgstr "Запустите утилиту ``tarantoolctl``:"

#: ../book/user_guide_getting_started.rst:222
msgid ":extsamp:`$ {**{tarantoolctl connect '3301'}**}`"
msgstr ":extsamp:`$ {**{tarantoolctl connect '3301'}**}`"

#: ../book/user_guide_getting_started.rst:224
msgid ""
"This means \"use the :ref:`tarantoolctl connect utility <administration-"
"tarantoolctl_connect>` to connect to the Tarantool server that's listening on "
"``localhost:3301``.\""
msgstr ""
"Данная команда означает \"использовать утилиту :ref:`tarantoolctl "
"<administration-tarantoolctl_connect>` для соединения с Tarantool-сервером, "
"который слушает на ``localhost:3301``.\""

#: ../book/user_guide_getting_started.rst:227
msgid "Try this request:"
msgstr "Введите следующий запрос:"

#: ../book/user_guide_getting_started.rst:232
msgid "tarantool> {**{box.space.tester:select{2}}**}"
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../book/user_guide_getting_started.rst:234
msgid ""
"This means \"send a request to that Tarantool server, and display the result\". "
"The result in this case is one of the tuples that was inserted earlier. Your "
"terminal screen should now look like this:"
msgstr ""
"Это означает \"послать запрос тому Tarantool-серверу и вывести результат на "
"экран.\" Результатом в данном случае будет один из кортежей, что вы вставляли "
"ранее. На терминале теперь должно отображаться примерно следующее:"

#: ../book/user_guide_getting_started.rst:238
msgid ""
"$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Music']\n"
"...\n"
"\n"
"localhost:3301>"
msgstr ""
"$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Music']\n"
"...\n"
"\n"
"localhost:3301>"

#: ../book/user_guide_getting_started.rst:249
msgid ""
"You can repeat ``box.space...:insert{}`` and ``box.space...:select{}`` "
"indefinitely, on either Tarantool instance. When the testing is over: To drop "
"the space: ``s:drop()``. To stop tarantoolctl: Ctrl+C or Ctrl+D. To stop "
"tarantool (an alternative): :ref:`os.exit() <os-exit>`. To stop tarantool (from "
"another terminal): ``sudo pkill -f tarantool``. To destroy the test: ``rm -r ~/"
"tarantool_sandbox``."
msgstr ""
"Вы можете повторно вводить команды :code:`box.space...:insert{}` и :code:`box."
"space...:select{}` сколько угодно раз, на любом экземпляре Tarantool'а. В конце "
"тестирования воспользуйтесь следующими командами. Чтобы удалить пространство: :"
"code:`s:drop()`. Чтобы остановить  ``tarantoolctl``: Ctrl+C или Ctrl+D. Чтобы "
"остановить Tarantool (альтернативный вариант): :ref:`os.exit() <os-exit>`. Чтобы "
"остановить Tarantool (с другого терминала): :code:`sudo pkill -f tarantool`. "
"Чтобы удалить тестовую базу: :code:`rm -r ~/tarantool_sandbox`."

#: ../book/user_guide_getting_started.rst:256
msgid ""
"**To review...** If you followed all the instructions in this chapter, then so "
"far you have: installed Tarantool from a binary repository, started up the "
"Tarantool server, inserted and selected tuples."
msgstr ""

#~ msgid ""
#~ "The two ordinary index types are 'tree' which is the default, and 'hash' "
#~ "which must be unique and which may be faster or smaller. The third type is "
#~ "'bitset' which is not unique and which works best for combinations of binary "
#~ "values. The fourth type is 'rtree' which is not unique and which works with "
#~ "arrays, instead of 'string' or 'unsigned' values."
#~ msgstr ""
#~ "Чаще всего индекс — это дерево (по умолчанию) или хеш (в этом случае индекс "
#~ "должен быть уникальным; в определенных случаях такой индекс занимает меньше "
#~ "места и поиск по нему работает быстрее). Третий тип индекса — это набор битов "
#~ "(bitset); это неуникальный индекс, предназначенный для работы с различными "
#~ "бинарными значениями. Четвертый тип индекса — это R-дерево; это тоже "
#~ "неуникальный индекс, предназначенный для работы с массивами, а не со строками "
#~ "или беззнаковыми числами."

#~ msgid ""
#~ "**To review...** If you followed all the instructions in this chapter, then "
#~ "so far you have: installed Tarantool from either a binary or a source "
#~ "repository, started up the Tarantool server, inserted and selected tuples."
#~ msgstr ""
#~ "Если вы выполнили все инструкции из этой главы, то к данному моменту вы уже "
#~ "установили Tarantool (из бинарного пакета, либо из исходных файлов), "
#~ "запустили Tarantool-сервер, а также выполнили вставку и выборку кортежей."
